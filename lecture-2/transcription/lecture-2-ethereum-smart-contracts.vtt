WEBVTT

00:00.000 --> 00:05.000
Так, отлично. Значит, сегодня у нас, в общем-то, как раз вторая лекция.

00:05.240 --> 00:11.820
Мы опять, как и в первой лекции, мы попробуем довольно-таки быстро обозреть,

00:11.960 --> 00:15.920
как душами смарт-контракты эфирные, как они работают для того,

00:16.020 --> 00:19.580
чтобы вы дальше могли выбирать себе курсовые проекты,

00:19.680 --> 00:22.560
может быть, там, потыкать где-то в код, как бы посмотреть.

00:23.880 --> 00:27.400
Первая домашка, соответственно, тоже к курсу, как бы это, по сути,

00:27.400 --> 00:31.540
внести дифы в Solidity код, вот, особо не пугайтесь,

00:31.640 --> 00:35.260
он достаточно легко, как бы, читается, и модифицировать его тоже, как бы, несложно.

00:36.520 --> 00:39.460
Вот, сложности, как бы, смарт-контрактов, они, на самом деле, в понимании

00:39.460 --> 00:43.360
таких низкоуровневых механизмов, вот, как бы, в самом, там, грубо говоря,

00:43.440 --> 00:48.240
написании кода, там, большого количества каких-то таких страшных тонкостей нет.

00:49.500 --> 00:50.640
Вот, значит, поехали.

00:52.280 --> 00:57.240
Возвращаясь к процессингу транзакций, то есть на этот раз мы уже их посмотрели,

00:57.400 --> 01:01.840
затем со стороны клиента, то есть как это выглядит вообще общение со смарт-контрактами

01:01.840 --> 01:04.940
для клиентов, то есть для ваших, там, пользователей, вот.

01:05.880 --> 01:12.440
Ну, например, предположим, я зашел на какой-то сайт, который посвящен финансам,

01:12.740 --> 01:17.600
я сейчас нахожусь в тестовой сети, сейчас уже не помню в какой, в Герле.

01:18.460 --> 01:21.080
Вы ее, кстати говоря, будете довольно часто использовать, возможно,

01:21.080 --> 01:27.080
имеет смысл, как бы, туда, как бы, деплоить свои, не знаю, там, проекты,

01:27.400 --> 01:31.280
то есть вы можете там разворачивать свои контракты, пользоваться этой сетью спокойно.

01:32.100 --> 01:36.740
В Герле сейчас наиболее из всех вот этих вот тестовых сетей, как видите, там много.

01:37.840 --> 01:41.020
Ринки бай уже, как бы, скоро будет деприкейтед.

01:42.540 --> 01:46.640
Герле сейчас наиболее такая свежая, как бы, которая поддерживает последнюю версию эфира,

01:46.640 --> 01:52.020
как бы, так что, значит, в ней, собственно, и, скорее всего, придется работать.

01:52.820 --> 01:53.500
Очень удобно.

01:53.900 --> 01:56.640
А там есть копия сайта, ну, кстати, да, в отличие, как бы, от источника,

01:57.400 --> 02:03.800
остальных от Web2 сервисов, в Web3 можно взять и скопировать свой сервис

02:03.800 --> 02:06.280
и запустить его в тестовые сети с игрушечным эфиром.

02:06.780 --> 02:11.000
Представьте, если бы у вас был там Тинькофф или Сбер, как бы, с игрушечными рублями,

02:11.000 --> 02:17.000
как бы, но стопроцентно повторяющий полностью, абсолютно всю бизнес-логику основного приложения.

02:18.580 --> 02:18.980
Ну, вот.

02:19.940 --> 02:22.900
Там, на самом деле, такие же, такие и есть, как бы, штуки,

02:23.080 --> 02:26.880
и недавно в Сбере была какая-то дичайшая бага как раз с тестовой версией приложения.

02:27.400 --> 02:30.080
Значит, для взаимодействия со смарт-контрактом,

02:30.480 --> 02:34.660
то есть для отправки вот такой же, вот такой вот транзакции,

02:35.300 --> 02:39.420
вот, в которой, как я говорил, находятся вот здесь вот в импуте,

02:39.700 --> 02:43.420
закодировано, какую функцию данного смарт-контракта я хочу вызвать.

02:43.620 --> 02:46.600
То есть я хочу бросить транзакцию вот на этот адрес

02:46.600 --> 02:50.200
и вызвать такую-то функцию с такими-то парами.

02:50.320 --> 02:52.880
Они здесь упакованы, конечно, но, тем не менее,

02:54.000 --> 02:55.160
выглядит это следующим образом.

02:55.160 --> 02:57.260
Ну, там, предположим, я хочу там включить,

02:57.400 --> 03:01.880
не знаю, свой, там, эфир, как калатору.

03:02.780 --> 03:05.180
Я сейчас отправлю, по сути, как бы, функцию, которая говорит,

03:05.320 --> 03:09.440
типа, разреши мне посылать, там, не знаю, эфир в этот смарт-контракт.

03:09.500 --> 03:11.440
То есть у него внутри произойдет запись.

03:12.180 --> 03:14.020
Для клиента это выглядит вот таким вот образом.

03:14.640 --> 03:17.220
То есть у него всплывает вот этот вот метамаск

03:17.220 --> 03:21.600
или какой там у вас есть, там, не знаю, там, кошелек там какой-нибудь

03:21.600 --> 03:24.120
и предлагает эту транзакцию подписать.

03:24.120 --> 03:26.200
Я эту транзакцию подтверждаю.

03:27.400 --> 03:30.220
Я не отправляю никакого эфира, вот.

03:30.240 --> 03:32.720
Но мне, конечно, придется заплатить за эту транзакцию.

03:32.880 --> 03:33.700
Сейчас надо нажать.

03:34.680 --> 03:35.080
Вот.

03:36.020 --> 03:37.640
И все, транзакция, как бы, поехала.

03:38.420 --> 03:40.820
Я жду, пока она, там, что-то там заманится,

03:40.940 --> 03:43.240
пока майнеры ее примут, пока они включат блок,

03:43.360 --> 03:44.300
пока, как бы, но...

03:44.300 --> 03:49.200
Я тоже не особо любитель плюс-сайза, да и таковым не являюсь.

03:49.680 --> 03:51.080
Я думаю, что...

03:51.080 --> 03:52.500
Никита, выключи микрофон.

03:54.020 --> 03:54.420
Да.

03:54.860 --> 03:57.080
И, соответственно, теперь, когда транзакция дошла,

03:57.400 --> 03:59.000
то собновился, вот.

03:59.120 --> 04:02.040
И, соответственно, эфир, как бы, теперь у меня включен.

04:02.100 --> 04:04.780
Я могу теперь его, там, например, не знаю, там,

04:05.120 --> 04:08.440
какое-то количество этого эфира положить, там, не знаю, процент, например.

04:09.200 --> 04:10.720
Будет выглядеть все точно так же.

04:11.620 --> 04:14.540
В чем, как бы, ну, как бы, удобство веб-три приложения,

04:14.600 --> 04:17.820
что я вот ровно таким же образом хожу, там, в сотни проектов

04:17.820 --> 04:20.860
абсолютно разных, как бы, могу делать в них, как бы,

04:20.860 --> 04:23.520
все делать при помощи одного и того же, не знаю,

04:23.620 --> 04:26.800
даже одного и того же адреса, одного и того же, вот, этого расширения.

04:27.840 --> 04:31.680
Нигде, как видите, нет никаких ни логинов, ни регистрации,

04:31.740 --> 04:33.300
вообще ничего, как бы, этого добра нет.

04:33.420 --> 04:35.200
Все свалено на пользователя.

04:35.400 --> 04:39.520
То есть за безопасность своих адресов, своей крипты, я отвечаю сам.

04:39.620 --> 04:42.720
То есть никто мне здесь не поможет никаких, там, восстановить аккаунт,

04:42.820 --> 04:43.860
ничего этого нету.

04:45.160 --> 04:50.360
А так, на секунду, так, вообще, как бы, взломы аккаунтов, угоны,

04:50.360 --> 04:52.600
короче говоря, получение персональных данных,

04:52.720 --> 04:56.200
оно в Web2-сервисах, в разных, там, почтах, как бы, сервисах

04:56.200 --> 04:57.280
очень часто делается.

04:57.400 --> 05:00.560
Как раз через функции восстановления доступа к аккаунту.

05:01.060 --> 05:04.280
Всякие вот эти секретные вопросы, Wi-Fi и так далее.

05:04.400 --> 05:07.140
Вы все это, как бы, в security штуках, как бы, видели.

05:07.820 --> 05:10.200
Ну, вот я положил, там, сколько-то, там, 0.12 эфира,

05:10.280 --> 05:13.240
положил под 11% годовых, все, они там валяются,

05:13.320 --> 05:14.560
потом захочу, как бы, вытащу.

05:15.560 --> 05:17.720
Вот, то есть все, как бы, довольно просто.

05:18.680 --> 05:20.740
И с точки зрения разработки ваших проектов,

05:20.740 --> 05:23.600
это тоже достаточно, как бы, удобно, потому что вы пишете,

05:24.020 --> 05:26.740
ну, если так, в минимальном варианте, то вы пишете смарт-контракт,

05:27.400 --> 05:31.940
деплойте, выкладываете его в сеть, куда-нибудь, там, не знаю, в тест-нет-герле,

05:32.600 --> 05:36.440
и пишете просто на Node.js какой-то, там, простейший, как бы, интерфейс.

05:37.540 --> 05:41.740
Ну, как бы, за этим интерфейсом, там, коду, на самом деле,

05:41.820 --> 05:44.380
там, на три строчки буквально, которые с эфиром общаются,

05:44.520 --> 05:48.340
потому что вся бизнес-логика, по сути, находится там где-то, в тест-нете.

05:49.540 --> 05:56.400
Вот, а бэкэнд вам нужен для того, чтобы на вашем проекте показывать,

05:56.400 --> 05:57.380
ну, всякие, там, цифры.

05:57.400 --> 06:00.800
Цифры, агрегации, там, сколько, там, не знаю, какие там проценты,

06:01.220 --> 06:04.700
total balances, вы можете взять, брать что-то из контрактов,

06:05.380 --> 06:08.580
но что-то вам понадобится, там, агрегировать, собирать статистику,

06:08.680 --> 06:10.460
чтобы пользователю дать больше информации,

06:10.540 --> 06:12.560
и для этого как раз используются бэкэнды, вот,

06:12.640 --> 06:14.400
поэтому с этой точки зрения Web3-разработка,

06:15.620 --> 06:18.400
она включает в себя, в том числе и Web2-разработка,

06:19.100 --> 06:21.340
то есть вам надо, там, курсы какие-то там переводить,

06:21.420 --> 06:23.420
еще что-нибудь, в общем, все это делается на бэке.

06:24.700 --> 06:27.000
Вот, значит, поехали.

06:27.400 --> 06:29.900
Значит, что происходит с транзакцией?

06:30.380 --> 06:33.000
На самом деле, на начальном этапе, когда мы ее только кинули,

06:33.080 --> 06:36.040
когда она попала в ноду, у нее, конечно, нету ни хэша-блоков,

06:36.080 --> 06:39.980
в которые она была включена, ни номера блока, вот,

06:40.140 --> 06:44.580
неизвестно, сколько она потратила газа, эта транзакция,

06:45.000 --> 06:47.080
то есть после того, как она была, как бы, замайнена.

06:47.860 --> 06:52.360
У нее непонятно, на какой позиции в блоке она находится, вот,

06:52.400 --> 06:55.140
но, в принципе, все остальное, как бы, оно, в общем-то, одно и то же,

06:55.140 --> 06:56.240
то есть вот здесь подпись,

06:56.240 --> 07:01.240
сколько эфира она на себе тащит, ее, соответственно, нагрузка,

07:01.840 --> 07:02.980
вот этот hex bytes.

07:03.700 --> 07:07.680
Кстати, что интересно, как бы, хакеры бывают, ну, точнее, не бывают,

07:07.780 --> 07:10.100
когда довольно часто переписываются с проектами

07:10.100 --> 07:12.880
вот посредством вот этих hex bytes,

07:13.080 --> 07:15.540
то есть вы можете отправить там транзакцию кому-нибудь с эфиром

07:15.540 --> 07:20.040
и здесь написать в комментарии, типа, вот, как бы, не знаю, там,

07:20.220 --> 07:23.080
спасибо за хак, короче говоря, вот, заберите часть денег.

07:24.320 --> 07:25.960
То есть бывает такое.

07:26.240 --> 07:29.660
Что и с хакерами переписываются, собственно, через вот эти вот hex bytes тоже бывает.

07:31.120 --> 07:35.640
Значит, что происходило вот здесь, когда я работал с Metamask?

07:36.180 --> 07:38.620
Сделал транзакцию, подписал транзакцию,

07:39.340 --> 07:41.860
затем мой вот этот вот Metamask,

07:42.460 --> 07:45.380
я напоминаю, это не ваше приложение,

07:45.680 --> 07:48.700
то есть не ваш DAP сделал эту транзакцию,

07:48.860 --> 07:52.440
ну, точнее, он ее изготовил, эту транзакцию сформировал,

07:52.440 --> 07:55.520
а подписал и отправил ее именно как раз Metamask,

07:56.240 --> 07:58.480
никакой JS с вашей страницы этого не делает,

07:58.580 --> 08:02.800
это делает расширение в валюту, то есть саму транзакцию отправляет, вот.

08:03.960 --> 08:06.340
Ну, а здесь, как бы, в JS-ке вы можете сделать, там, не знаю,

08:06.440 --> 08:11.100
PubSub, там, подписаться, там, на обновление, там, от Metamask, там, от ноды, как бы,

08:11.160 --> 08:15.460
и в нужный момент, когда пришла информация, что все, транзакция включена,

08:15.560 --> 08:19.380
как бы, галочки переключилась, стейт изменился.

08:20.160 --> 08:24.160
Соответственно, там используется обычный, там, JSON-RPC интерфейс,

08:24.160 --> 08:29.480
обычно у нод есть, как бы, два интерфейса, HTTPS и WebSockets,

08:29.580 --> 08:33.660
WebSockets, которые позволяют, как бы, вам держать все время открытым соединение,

08:33.760 --> 08:36.260
то есть если вам надо, как бы, там, непрерывно получать апдейты,

08:36.360 --> 08:40.160
все время страничку обновлять, как бы, это более удобно, ну, вот.

08:40.260 --> 08:44.460
Здесь, как бы, все стандартно, и поэтому, как бы, ноды, они, по сути,

08:44.560 --> 08:48.960
представляют собой, ну, так, для внешнего наблюдателя, по сути, такой веб-сервер,

08:49.060 --> 08:53.780
который прям JSON-RPC API, то есть открытые порты, как бы, вы можете,

08:54.160 --> 08:58.320
туда кинуть какой-нибудь запрос, и он вам в ответ, как бы, ответит,

08:58.400 --> 09:03.380
как бы, можете кинуть, там, послать транзакцию, и нода, как бы, отправит транзакцию.

09:04.380 --> 09:08.940
Значит, что делает нода? Нода валидирует транзакцию, чтобы ее, там,

09:08.980 --> 09:13.480
мусором не закинули, всякие черновые проверки, кладет, как торрент,

09:13.560 --> 09:19.220
как бы, начинает раздавать, как бы, через торрент и, там, через P2P эту транзакцию, вот.

09:20.120 --> 09:23.220
Причем, там, есть, по сути, как бы, несколько,

09:24.160 --> 09:29.220
несколько протоколов, по которым они работают, там, родной эфирный P2P,

09:30.080 --> 09:34.140
есть стэк, как бы, который использует другие ноды, вот, то есть, несколько вариантов,

09:34.240 --> 09:37.260
как бы, но смысл один и тот же, то есть, нода рассказывает другим, типа,

09:37.360 --> 09:41.520
чуваки, у меня есть, вот, новые хэши транзакций, кому надо, как бы, если хотите,

09:41.620 --> 09:45.440
я вам, типа, перешлю тело этих транзакций, ну, чтобы дважды, как бы, не слать.

09:46.320 --> 09:51.560
Вот, наконец, она добирается, там, до майнера, вот, и, соответственно, майнер,

09:54.160 --> 10:00.500
ее применяет. Значит, затем, ну, и после этого, после того, как, как бы,

10:00.540 --> 10:05.420
нода объявила о транзакции полной ноды, она стоит и ждет, как бы, новых блоков,

10:05.520 --> 10:09.880
подписывается на все, как бы, новые блоки. Когда прилетает новый блок,

10:10.580 --> 10:14.540
она узнает, что, как бы, я жду результатов вот этой транзакции,

10:14.620 --> 10:17.900
то есть, когда она будет включена в блок, она, по сути, как бы, подписана, в общем,

10:17.940 --> 10:23.440
на эти события, вот, она получает новый блок, проверяет его, выбирает,

10:23.440 --> 10:28.120
в соответствии с консенсусом, годится ли этот блок или нет, как бы, попадает ли он

10:28.120 --> 10:33.380
в основную цепочку, в мастер-чейн. Если и надо, как бы, как я там показывал

10:33.380 --> 10:38.300
на схемах, как бы, откатывать, может быть, предыдущие блоки и накатывать вот эти вот

10:38.300 --> 10:43.920
новые, вот, с ревертом, как бы, всех транзакций. Затем накатывает все транзакции

10:43.920 --> 10:49.340
из вот этого нового блока на свою state database. Вот, возможно, среди этих

10:49.340 --> 10:53.420
транзакций есть и наша, вот. И как раз вот в этот момент,

10:53.440 --> 10:59.260
когда она применяет, как бы, этот, ну, применяет, по сути, блок, бежит по

10:59.260 --> 11:03.160
транзакциях и делает вот эту вот apply, вот ровно в этом месте работает код

11:03.160 --> 11:09.360
контракта. Прямо здесь как раз запускается виртуальная машина, вот, и вот здесь, как

11:09.360 --> 11:14.400
бы, она бежит-бежит, как бы, по транзакции, по сути, исполняет, как бы, код контракта.

11:14.400 --> 11:23.060
Вот. Далее она решает, как я говорил, любой smart-контракт, любой вызов к smart-контракту

11:23.060 --> 11:28.160
заканчивается всего двумя исходами, да, типа, все окей, как бы, и реверт, и в случае реверта,

11:28.160 --> 11:34.400
как бы, ну, ничего не происходит. То есть никаких изменений абсолютно, как бы, вот, кроме, как бы,

11:34.400 --> 11:40.040
списания денег с баланса отправителя за потраченный газ. А в самой state database,

11:40.040 --> 11:44.360
как бы, там, во всех, там, данных контракта никаких значений, никаких изменений не происходит.

11:44.360 --> 11:52.340
После чего она обновляет state root, вот это вот в дерево организованное значение, грубо говоря,

11:53.060 --> 11:59.780
state, ну, hash state database, такой общий, который, как бы, зависит от всех значений этой базы

11:59.780 --> 12:05.780
данных, и, соответственно, проставляет транзакции, как бы, сколько было потрачено газа, какой блок

12:05.780 --> 12:12.260
она была включена, там, какой индекс, и так далее, и так далее. В этот момент наш metamask, как бы,

12:12.260 --> 12:19.040
висит на этой ноде, там, по вебсокетам или опрашивает ее по HTTPS, вот, и ждет, когда

12:19.040 --> 12:23.000
появится информация о его транзакции. Значит, приходит новый блок,

12:23.060 --> 12:29.540
он ждет, как бы, будет ли доказательство того, что моя транзакция попала в мой блок. Здесь, как раз,

12:29.540 --> 12:35.960
используются вот эти вот merkle proof, то есть доказательство того, что транзакция, она, как бы,

12:35.960 --> 12:41.060
в блок попала, в то время как в блоке есть буквально одно только число. Ну, про меркл деревья мы с вами

12:41.060 --> 12:46.960
обязательно, там, поговорим подробно, это широко используемый паттерн в блокчейнах. То есть она ждет,

12:46.960 --> 12:52.500
как бы, еще и доказательство того, что транзакция в текущий блок попала, вот.

12:53.060 --> 13:00.060
Затем получает, соответственно, апдейты от ноды, как бы, ну, там, она запрашивает, там, любые, там,

13:00.060 --> 13:08.540
интересные значения, например, там, включен ли флажок он для эфира для вот этого адреса клиента,

13:08.540 --> 13:16.220
который, как бы, запросил. Если да, то он там что-то отрисовывает. Вот, она это все дело опрашивает,

13:16.220 --> 13:19.880
и, как бы, после того, как понятно, что транзакция включена, все изменилось, как бы,

13:19.880 --> 13:22.940
все данные из контрактов получены, она апдейтит мордочку.

13:23.060 --> 13:27.380
Вот, то есть выглядит весь вот этот цикл таким образом.

13:27.380 --> 13:35.020
Кто является клиентами? То есть кто может дергать, как бы, оперировать эфиром? Значит,

13:35.020 --> 13:40.460
самые популярные это браузеры вот с этими расширениями, там, помимо Metamask есть еще много,

13:40.460 --> 13:47.540
там, всего. Есть, там, просто десктопные программы-клиенты, но браузеры, они, почему они,

13:47.540 --> 13:53.060
как бы, наиболее популярны? Ну, потому что, как я сказал, как бы, я своим браузером бегаю, там, я

13:53.060 --> 13:57.860
не знаю, по десяткам, как бы, проектов, что хочу, там, закладываю, перекладываю, как бы, как угодно,

13:57.860 --> 14:06.140
там, не знаю, в финансы регистрируюсь, играю, там, в игры, там, NFT какие-нибудь создаю, и все это

14:06.140 --> 14:11.720
делается при помощи, по сути, одного расширения в этом браузере. Это крайне удобно. Вот, то есть,

14:11.720 --> 14:16.040
как бы, тот, у кого, как бы, есть на балансе эфир, по сути, имеет доступ, там, к сотням разных

14:16.040 --> 14:22.340
финансовых инструментов, совершенно, там, разных типов, как бы, и, там, возможностям, там, десяткам

14:23.060 --> 14:32.540
и вообще кучу всего. Все это при помощи буквально одной софтины. Но есть еще, мы тоже будем про них

14:32.540 --> 14:37.840
говорить, это, наверное, самый надежный способ защитить отдельный адрес, это железные ключи

14:37.840 --> 14:45.500
хардварные. Это такие типа флешки, как бы, штуки, вставляются в USB, и их основная суть, то, что у

14:45.500 --> 14:51.860
них внутри зашит приватный ключ, они никогда его в жизни наружу не показывают. Вот, ты в эту флешку,

14:51.860 --> 14:53.040
как бы, ну, ты в этот ключ, как бы, не можешь, ну, как бы, не можешь, ну, ты в этот ключ, как бы,

14:53.040 --> 14:59.660
передаешь транзакцию а он в ответе выдает ее подпись то есть типа да я подписал вот и там

14:59.660 --> 15:04.980
если там например кнопочка есть на этой флешке то хакера как бы даже полностью захватив компьютер

15:04.980 --> 15:12.000
он не может получить не может получить доступ к этой кнопочки то есть как минимум там нажать

15:12.000 --> 15:20.640
нажать confirm и подписать за вас ну и там это маска умеет коннект с этими с этими ключами вот

15:20.640 --> 15:29.400
в общем их рекомендуется использовать мобильные валятся значит то что вы набираете когда вы

15:29.400 --> 15:37.120
наберете там эфириум wallet мобайл по большей части на самом деле это обрезанные браузеры такие

15:37.120 --> 15:43.360
которые входят на ограниченное количество сайтов то есть без строки url ада как вас кучей там не

15:43.360 --> 15:49.380
знаю там линков там favorites и тоже встроенные как бы истории управления ключами пока и это

15:49.380 --> 15:50.580
имеется паблике и инфо

15:50.640 --> 15:56.320
structure то есть там приватные публичные ключи адреса там и так далее вот то есть такие как

15:56.320 --> 16:01.320
бы популярные браузеры мобильные кошельки это по сути как бы браузер для того чтобы ну им было

16:01.320 --> 16:07.500
удобно ходить сюда там городить особо ничего не надо потому что джессон рпс и все стандартно все

16:07.500 --> 16:12.660
как в вебе как бы особо что-то придумать как бы смысла нет если вы будете самописный валит там

16:12.660 --> 16:20.260
писать на java вот вам придется реализовать вообще там ну ты фига там всяких взаимодействий там так

16:20.260 --> 16:20.640
далее

16:20.640 --> 16:33.660
и в этом же еще причина почему мобильщики не любят особо крипту значит потому что смотрите вы сделали

16:33.660 --> 16:40.440
какую-нибудь вас там мобилка у вас здесь ваша опка не знаю какая там крутая игра как бы там

16:40.440 --> 16:45.360
здесь эфир значит можно чего-нибудь покупать продавать всякие там предметы игровые там какая

16:45.360 --> 16:50.160
экономика интересная но для того чтобы каждую транзакцию вам отправить вам нужные подписались

16:50.640 --> 16:55.780
Для этого вам нужен секретный ключик, личный ключик, адреса.

16:56.580 --> 17:03.260
И зачастую вот это реализовать сложнее, чем реализовать всю вашу апку целиком.

17:04.160 --> 17:07.840
Потому что ваша апка, там, не знаю, красивые картинки плюс несколько типов транзакций,

17:08.400 --> 17:14.420
а вот здесь вот надо прям сильно поскрепеть, потому что здесь требования к безопасности очень высокие.

17:14.520 --> 17:19.200
То есть вам придется, по сути, в свое приложение встроить валет.

17:19.200 --> 17:22.320
А требования к валету, они крайне серьезные.

17:22.420 --> 17:26.040
То есть здесь вы что-то там набажете, как бы это еще можно будет поправить,

17:26.560 --> 17:30.340
а здесь что-нибудь не так сделаете, там, не знаю, генерацию адресов, там еще что-то.

17:31.580 --> 17:34.340
И будет очень плохо, как бы валет поломают.

17:35.480 --> 17:38.640
Вот, ну, буквально недавно там вот тоже дичайшая история в Салане.

17:39.060 --> 17:42.860
То есть когда там было взломано, там, не знаю, сотни, как бы тысячи адресов,

17:42.940 --> 17:45.780
огромное количество крипты было украдено как раз просто потому,

17:45.780 --> 17:48.780
что один из валетов, он генерировал...

17:49.920 --> 17:52.020
адреса несекьюрным образом.

17:52.640 --> 17:57.480
Вот, там, секретный ключ из него, публичный из него, там, адрес, соответственно.

17:58.300 --> 18:03.100
Он делал, ну, несекьюрно, как бы, и, по сути, это было взломано.

18:04.260 --> 18:06.440
Так, нет. Нет, я нет, я набрал.

18:06.520 --> 18:09.520
Нет, на самом деле, он не несекьюрный, да, я извиняюсь,

18:09.580 --> 18:15.120
а он отправлял дебажную информацию, дебажную информацию в сервис-центре.

18:15.120 --> 18:19.120
И там среди дебажной информации валялись, как бы, приватные клиенты.

18:19.220 --> 18:26.180
То есть то, что полностью вз installing, ну, перiąдовACcurrency и там е-ч Biern el ...

18:26.500 --> 18:28.180
كignment и и так далее,

18:28.180 --> 18:29.760
поэтому, наверное, ещё иyn клиент,

18:29.780 --> 18:31.260
поэтому его нужно вставить вот сюда,

18:31.260 --> 18:32.480
так что weekends.

18:32.540 --> 18:37.280
Ну, в общем, хоть и нелегче, но с генерацией адресов это вот,

18:37.320 --> 18:40.040
буквально, совсем недавняя бага, вот.

18:40.120 --> 18:44.720
Есть софт, который позволяет генерировать красивые адреса там с ноликами и так далее,

18:44.760 --> 18:47.720
как бы, и, вот, в этой генерации была найдена уязвимость.

18:47.720 --> 18:51.080
Все, кто автоматически ходят в эфир и шлют туда транзакции.

18:52.440 --> 18:53.400
Что-то там запрашивают.

18:54.120 --> 18:57.140
У них обычно приватные ключи в конфиге.

18:57.720 --> 19:01.100
Пугаться тут вообще особо не нужно, потому что штука вообще простая.

19:01.200 --> 19:05.840
На любом языке программирования, Python, Rust, JS и так далее,

19:05.840 --> 19:11.000
есть там прям куча библиотек, которые вам позволят сгенерировать адрес эфириумный

19:11.000 --> 19:13.380
и спокойно там все подписи ставить и так далее.

19:13.500 --> 19:16.900
То есть все вообще делается на самом деле очень просто, там несколько строчек.

19:16.900 --> 19:21.400
Вот, поэтому если вы что-то пишете автоматизированное, что работает там,

19:21.460 --> 19:23.820
не знаю, с эфиром, как бы это очень просто.

19:24.700 --> 19:28.120
Вот, то есть создать транзакцию, создать адрес, как бы создать ключ,

19:28.320 --> 19:29.920
можно без особых проблем.

19:31.400 --> 19:35.840
Вот, и еще, наверное, еще одна история про клиентов,

19:36.300 --> 19:39.880
которые могут работать со смарт-контрактами, про которые часто забывают,

19:40.040 --> 19:41.480
это различные девайсы.

19:42.400 --> 19:46.880
Вот, на хакатонах довольно часто, как бы раньше там довольно популярно,

19:46.900 --> 19:50.520
популярная штука была сейчас, по-моему, не очень уже стала, как бы популярная,

19:50.600 --> 19:53.600
а так-то раньше, как бы много народа, как бы пытались соединить эти вещи.

19:54.880 --> 19:59.200
Действительно удобно, как бы интернет вещей, ему блокчейн достаточно интересен,

19:59.240 --> 20:05.460
просто потому что нет единой точки отказа, то есть плевать любая сеть, короче,

20:05.580 --> 20:10.140
любая нода, как бы ваше устройство, считай, как бы подключено к сети, вот,

20:10.260 --> 20:15.680
у вашего устройства есть приватный ключ, есть адрес, как бы, который никто, как бы,

20:15.680 --> 20:16.780
там не остановит, как бы.

20:16.900 --> 20:21.960
Никто им там особо, как бы, не управляет, вот, и оно там может всякие штуки делать.

20:23.920 --> 20:27.480
Ну, у нас там знакомый проект, например, Робономика очень много занимается

20:27.480 --> 20:31.400
соединением как раз всяких, там, не знаю, там роботов, датчиков, там, и так далее,

20:31.520 --> 20:33.960
всего, как бы, с блокчейнами.

20:34.380 --> 20:39.140
Если у вас есть какая-то девайсина, мы, например, делали там счетчик электричества,

20:39.140 --> 20:46.580
там, 100 киловатт насчитал, он, соответственно, формирует транзакцию,

20:46.900 --> 20:50.400
то есть, мое следующее показание – это 100 киловатт, значит, подписывает ее,

20:51.440 --> 20:54.920
отправляет в сеть, у нас там была другая сеть, как бы, ну, неважно, например,

20:55.000 --> 21:00.020
отправляет в эфир, а здесь смарт-контракт, как бы, принимает эти показания,

21:00.240 --> 21:05.080
100 киловатт, у него есть, там, 90 предыдущие показания, как бы, теперь у него стало 100,

21:06.000 --> 21:13.340
у него получается 10, и он за эти 10 списывает плату по текущей, там, цене,

21:13.340 --> 21:15.620
как бы, за киловатт, то есть, такая, достаточно.

21:16.900 --> 21:21.380
Понятная, как бы, история, и при этом, что, как бы, удобно, ни одного сервера нету,

21:21.740 --> 21:25.580
ну, то есть, у вас нет ни облака, никаких, там, бэкэндов, никаких хайпи, короче,

21:25.640 --> 21:29.660
у вас есть просто счетчик, и все, как бы, его просто как-нибудь подрубить, там, не знаю,

21:29.740 --> 21:35.040
к Wi-Fi или куда-нибудь в сеть, он уже там сам разберется, там, достучится до какой-нибудь,

21:35.040 --> 21:40.320
до какой-нибудь, там, из сотни нод публичных, и отправит, как бы, туда транзакцию,

21:40.320 --> 21:46.560
вот он, там, считает, соответственно, показания, но для этого есть некоторые ограничения.

21:46.560 --> 21:58.640
Технически, прошу прощения, в первую очередь, они связаны с тем, что такие девайсы должны быть

21:58.640 --> 22:03.580
достаточно производительными, потому что им нужно будет сделать электронную подпись

22:03.580 --> 22:10.400
с использованием вот такой электрической кривой, то есть, это арифметика с числами,

22:10.400 --> 22:16.480
как бы, 256-битными, и на каком-нибудь, там, мелком каком-нибудь орудии,

22:16.560 --> 22:20.460
там, которые еле-еле, там, как бы, что-то там пашет, как бы, вы, скорее всего,

22:20.460 --> 22:25.880
такую подпись произвести не сможете. Ну, вот, а Raspberry Pi, например, может достаточно спокойно,

22:25.880 --> 22:32.180
как бы, сформировать транзакцию и ее отправить. Вот, ну, и понятно, что там должна быть, там, сеть,

22:32.300 --> 22:37.460
короче, там, вебка и так далее, то есть, возможность обращаться к ноде и сделать, по сути,

22:37.460 --> 22:41.960
JSON-RPC вызов, вот, то есть, ну, это тоже хороший вариант, и вот.

22:43.560 --> 22:46.460
Теперь, следующий такой кусочек.

22:46.560 --> 22:55.620
Как бы, важный. Это ноды, то есть, сами, сами ноды, которые наши узлы, как бы, наши узлы вот этой

22:55.620 --> 23:02.220
эфириум-сети. Кто-то из них майнером является, кто-то из них является, там, не знаю, валидатором,

23:02.220 --> 23:08.880
все они умеют принимать, как бы, транзакции от пользователей, все они, как бы, друг другу,

23:08.880 --> 23:14.520
как бы, про эти транзакции рассказывают, каждый из них, как бы, от других нод получает блоки,

23:14.520 --> 23:16.520
тоже так.

23:16.560 --> 23:21.460
То есть, они, как бы, строят цепочку по одним и тем же правилам, с одним и тем же консенсусом, вот.

23:21.460 --> 23:30.660
Но, опять же, в централизованном мире, мы видим, как бы, такую историю, нам говорят, как бы, вот, у нас есть, типа, Монго,

23:31.860 --> 23:40.460
она у нас, там, на четырех репликах, как бы, там, одна реплика, там, не знаю, в Китае, другая, там, в USA, как бы, третья реплика, там, не знаю, в России,

23:41.960 --> 23:45.160
и вот между ними настроена репликация, вот они вот так общаются.

23:45.160 --> 23:46.360
Вот этот софт, он одинаковый.

23:46.560 --> 23:51.420
То есть, везде, как бы, здесь стоит Монго, здесь стоит Монго, здесь стоит Монго, здесь стоит Монго,

23:51.420 --> 23:56.440
то есть, весь один и тот же код, один и тот же программный продукт одних и тех же версий.

23:56.440 --> 24:04.440
Из-за того, чтобы я говорил, что эфир — это, как бы, в первую очередь, как бы, протокол, да, нежели имплементация,

24:04.440 --> 24:09.420
у эфировских нод, у неё, вот, это вот просто самые, только известные, как бы,

24:09.420 --> 24:10.540
имплементации ноды.

24:10.580 --> 24:12.580
То есть, у вас здесь стоит здесь, здесь стоит Nethermind, написанный, там, не знаю,

24:16.560 --> 24:18.260
на C-Sharp, здесь

24:18.260 --> 24:20.100
GES на горшке написан,

24:20.420 --> 24:21.660
здесь какой-нибудь

24:21.660 --> 24:24.340
OpenEthereum, который на Rust

24:24.340 --> 24:26.360
написан, как бы здесь стоит

24:26.360 --> 24:26.840
Eragon,

24:28.600 --> 24:29.380
такая чуть более

24:29.380 --> 24:32.320
быстрая версия GES,

24:32.600 --> 24:34.140
тоже на горшке написано.

24:34.700 --> 24:36.360
Вот, и они все друг с другом, как бы

24:36.360 --> 24:38.040
по одному и тому же протоколу,

24:38.040 --> 24:40.240
в общем-то, общаются. Там есть у них отличия

24:40.240 --> 24:42.080
в P2P, там, в стэках и так далее,

24:42.160 --> 24:44.260
но, как бы, по большей части они все, как бы, друг друга

24:44.260 --> 24:45.900
видят и друг друга понимают.

24:46.560 --> 24:48.180
И в этом, собственно, крутость

24:48.180 --> 24:48.820
как раз

24:48.820 --> 24:52.420
всей вот этой вот истории,

24:52.560 --> 24:54.400
потому что, когда были атаки на эфир,

24:55.260 --> 24:56.580
ну, такие прям вот эксплойты

24:56.580 --> 24:58.160
как бы на ноды, он

24:58.160 --> 25:00.400
достаточно достойно их выставил, потому что

25:00.400 --> 25:02.240
была там, по-моему, там атака на

25:02.240 --> 25:04.320
там Rust-имплементацию, как бы

25:04.320 --> 25:06.180
их там много сразу полегло,

25:07.580 --> 25:10.220
а там горшечная, она, как бы,

25:10.400 --> 25:12.340
осталась в строю,

25:12.380 --> 25:13.860
ну, или наоборот, как бы было, вот.

25:13.860 --> 25:15.720
Но смысл в том, что клиентов много,

25:15.720 --> 25:17.180
и всех атаковать, как бы, сразу

25:17.180 --> 25:19.380
не получится, найти дыры, как бы,

25:19.420 --> 25:21.780
одновременно во всех. А оставшиеся

25:21.780 --> 25:23.540
продолжат тащить сеть, как бы,

25:23.620 --> 25:25.540
да, там отвалится, может, часть майнеров, там,

25:25.600 --> 25:27.500
еще что-то, но сама сеть продолжит работать.

25:28.660 --> 25:29.300
Это, опять же,

25:29.580 --> 25:31.760
в пользу довода о том,

25:31.820 --> 25:33.500
что блокчейны круто подходят, как бы,

25:33.540 --> 25:36.200
в условиях тотального киберпротивостояния,

25:36.220 --> 25:37.900
как бы, крайне устойчивой

25:37.900 --> 25:38.420
сети.

25:40.780 --> 25:41.440
Отличаются они,

25:41.980 --> 25:43.980
ну, как бы, с точки зрения

25:43.980 --> 25:45.700
протокола, отличаются они,

25:45.720 --> 25:47.700
не сильно, вот, но

25:47.700 --> 25:49.620
отличия все-таки есть, как бы,

25:49.680 --> 25:50.680
ну, например, там у них

25:50.680 --> 25:53.960
различные API, то есть какие-то стандартные

25:53.960 --> 25:55.240
функции, как бы, есть везде,

25:56.440 --> 25:57.860
вот, а какие-то,

25:57.940 --> 25:59.720
какие-то вот эти, вот, как бы, функции

25:59.720 --> 26:01.720
через JSON RPC, как бы, вызываются,

26:01.880 --> 26:03.560
как бы, на некоторых нодах написано,

26:03.760 --> 26:05.260
типа, not supported.

26:06.260 --> 26:07.780
То есть кто-то там не отдает, как бы,

26:07.840 --> 26:09.460
сырые транзакции в байтах,

26:09.560 --> 26:11.540
кто-то там не позволяет, там, типа, не знаю,

26:11.620 --> 26:13.500
подписаться на какой-то особый вид,

26:13.500 --> 26:15.460
я не знаю, там, событий.

26:16.040 --> 26:17.520
Тут еще там что-то, как бы, то есть

26:17.520 --> 26:19.600
здесь уже, как бы, колдует

26:19.600 --> 26:20.780
команды разработки.

26:21.580 --> 26:23.420
И это, кстати говоря, разработка

26:23.420 --> 26:25.660
нод, вот, собственно, вот этого софта.

26:26.580 --> 26:27.640
Это тоже называется,

26:27.740 --> 26:29.480
как бы, блокчейн-разработка, не та,

26:29.600 --> 26:31.440
которую мы будем изучать,

26:31.460 --> 26:33.340
то есть это, собственно, люди, которые сами ноды

26:33.340 --> 26:35.760
разрабатывают. И эта работа,

26:35.840 --> 26:37.440
она больше похожа на системную

26:37.440 --> 26:38.560
разработку. То есть

26:38.560 --> 26:41.320
можете считать, как бы, что те, кто

26:41.320 --> 26:43.120
пишут эти ноды, ну, точнее, даже

26:43.120 --> 26:45.280
не можете считать, а на самом деле там, собственно,

26:45.720 --> 26:52.320
которая этим занимается это разработчики которые до этого разрабатывали движки субэдэ различные

26:52.320 --> 27:00.300
это и там из маиску или какого-нибудь там кто делал там поздно с манги редис и и так далее

27:00.300 --> 27:06.420
то есть те кто вот это писали прям вот по сути изнутри собственно сам сам как бы движок вот они

27:06.420 --> 27:14.580
же пишут и вот чей на победителями в языках здесь однозначно как бы являются го и раз

27:14.580 --> 27:20.940
потому что именно вот эти вот два языка как бы они могут обеспечить во первых как бы крайне

27:20.940 --> 27:28.260
высокую производительность да как бы хотя как бы но блокчейн и да может и не славятся у нас

27:28.260 --> 27:32.520
там миллионами tps и меня там каждый раз на конференции холод надо объяснять как вы

27:32.520 --> 27:39.120
через сделаю вообще зачем сюда пришел как бы со своими этим блокчейн ими тормознут ими вот

27:39.120 --> 27:44.260
но на самом деле внутри как бы здесь not как бы оптимизации производительности огромное внимание

27:44.260 --> 27:44.520
в деле

27:44.580 --> 27:51.300
поэтому пишется они в основном на низкоуровневых языках как бы гошка за счет того что у нее

27:51.300 --> 27:56.760
многопоточность как бы хорошо сделано здесь прям это там серьезно там надо много к на эту держать

27:56.760 --> 28:02.480
там подписываться на кучу событий все это трекать одновременно в нужном порядке устраивать ну а раз

28:02.480 --> 28:07.500
потому что он просто позволяет там контролировать буквально там каждый чих то есть там вообще любой

28:07.500 --> 28:13.860
как бы там любой алгоритм прямо как бы гвоздями прибит как он исполняется максимально оптимизирован

28:14.580 --> 28:20.400
вот поэтому там блокчейн и как бы на питоне блокчейн и там на растя не сильно приветствуется

28:20.400 --> 28:26.700
но вот есть еще пример как бы например nether майнт тоже там знакомый к команда как раз писал

28:26.700 --> 28:32.580
они написали его на си шарпе вот что в принципе наверно как бы тоже вполне себе варианта у них

28:32.580 --> 28:39.900
очень достойных сочи клиент получился как бы nether майнт его тоже используют во все вот так что и на

28:39.900 --> 28:44.420
java вот эта консорциум гипер ledger тоже как бы сделал свою имплементацию

28:44.580 --> 28:51.240
на java не знаю как она поддерживается мы с ней дела не имели далее тоже по терминологии

28:51.240 --> 28:59.280
как бы вот этих вот нод когда я буду говорить ну то есть по сути есть наверное два вида как

28:59.280 --> 29:07.800
бы нот ну точнее не 2 я первым может быть сюда даже добавил как бы архивные ноды если

29:07.800 --> 29:13.580
говорить как бы об эфире значит архивная нода я прям с нее наверно начну

29:14.580 --> 29:21.540
архивная нода если вам кстати такая нужна то вы можете получить там в сервисе типа алкими возможно

29:21.540 --> 29:27.360
вам и понадобится если вам нужна своя нода как бы вы идете как бы вот здесь вот регистрируйтесь и вам

29:27.360 --> 29:36.060
бесплатно дадут доступ но по сути прям дадут урл секретный ваш собственный как бы к по которому вы

29:36.060 --> 29:44.020
можете обращаться к ноде эфира там у меня есть там ноды майнета есть но до этого тестового герле а вот

29:44.580 --> 29:49.200
и вы можете как бы с ней работать как бы это будет бесплатно пока вы там совсем и не нагрузить там

29:49.200 --> 29:55.080
немеряным количеством запросов вот тогда с вас денег попросят вот для обучения прекрасно как бы

29:55.080 --> 30:03.240
хватает значит архивные ноды это самые честные ноды блокчейна то есть та которая собирает все

30:03.240 --> 30:12.000
блоки начиная там с первого и до текущего вот такого вот блока она полностью ведет короче говоря

30:14.580 --> 30:20.640
абсолютно все апдейты она сохраняет все транзакции на ней есть которые были за время существования

30:20.640 --> 30:30.720
эфира и что самое важное вы у архивной ноды всегда можете запросить состояние прям стоит то есть

30:30.720 --> 30:36.780
обратиться к этой базе данных на на какой-то определенный блок зафиксированы если вы говорите

30:36.780 --> 30:43.820
хочу короче что ты мне сказала как бы вот начиная с этого блока какое было вот это вот значение там

30:44.580 --> 30:50.800
тракте как чему была равна вот этот переменная там не знаю там три дня назад ровно в 5 утра вот на

30:50.800 --> 30:55.540
этот номер блока и архивные ноды вам ответить то есть она умеет перепроигрывать весь эфир как бы

30:55.540 --> 31:04.680
вперед-назад как вам нравится она довольно большая сейчас чтобы ее крутить как бы надо там там больше

31:04.680 --> 31:12.120
двух терабайт место занимает эфир по моему 16 или 17 терабайт вот это вся как бы полностью вся инфа

31:14.580 --> 31:19.380
и чтобы просто догнать эту ноду до последнего блока она же по-честному как бы бежит его

31:19.380 --> 31:24.000
фабула по блоковых накатывает как бы нужно несколько дней на очень хорошем и мощном

31:24.000 --> 31:35.720
сервере так что эта штука не дешевая крайне дайте мне секундочку потерял

31:40.500 --> 31:44.060
вот а

31:44.580 --> 31:51.820
архивные надо штука довольно такая прожорливая вот и в общем один из путей как бы развитие эфир

31:51.820 --> 32:02.280
это как раз но облегчение not вообще по сути даже как бы отказ от архива вот этого от архива

32:02.280 --> 32:07.640
транзакции от архива блоков от снапшотов вот этой вот базы как бы это один из путей по сути

32:07.640 --> 32:14.160
развития эфира вы не можете скелет эфир довести его там до десятков и сотен тысяч транзакций в

32:14.580 --> 32:19.620
и все это как бы хранить вот на архивной ноде у вас как бы никого компьютер как бы никогда это

32:19.620 --> 32:26.280
не потянет вот поэтому но при этом как бы должны соблюдаться все крипто графические доказательства

32:26.280 --> 32:30.720
того что какие-то конкретные транзакции были включены в блоке там и так далее поэтому задача

32:30.720 --> 32:37.460
такая немаленькая обычно мы все используем вот когда вот я смита маскам до отправлял

32:37.460 --> 32:44.420
транзакция все используют так называемые фолл-ноды это нода которая тащит актуально

32:44.580 --> 32:52.820
стоит database то есть последнего последнего формата она может не сохранять как бы транзакции

32:52.820 --> 32:58.080
вот она просто накатывает как бы новые блоки получают как бы новый блок накатывают и и

32:58.080 --> 33:04.440
растает database держит последний там не знаю там последний какой-то кусочек как бы блокчейна

33:04.440 --> 33:11.840
вот держит актуальную версию вот этой вот как бы стоит базы данных перепроверяет вот но при

33:14.580 --> 33:22.320
всеми по всей по сути истории вот но еще понятие light но да как бы но тут ее прям как-то

33:22.320 --> 33:27.600
формализовать довольно сложно потому что от структуры блокчейна сильно зависит как бы ну

33:27.600 --> 33:33.600
что вообще нужно от этой light но да то есть легкая нода который вообще как-то ну там минимальная там

33:33.600 --> 33:39.660
самое дешевое в поездка который просто висит где-то там на конце как бы блокчейна у нее

33:39.660 --> 33:44.340
есть там какая-то может маленькой стоит database который следит только за заданными адресами

33:44.580 --> 33:49.840
зафиксирован имя зафиксирован ими контрактами протоколами то есть здесь можно конечно

33:49.840 --> 33:56.840
народить как бы чего угодно очень много простора для творчества вот поэтому то есть это такое

33:56.840 --> 34:03.560
понятие как бывает но до легкий но вы там чуть ли не ноты в браузере которые понимаются вот в

34:03.560 --> 34:08.260
некотором видео но были идеи до бутыльных которые вообще как бы работает из браузер то есть вы

34:08.260 --> 34:12.420
включаете браузер власты к аппарату джаз на странице как бы начинает общаться с другими

34:12.420 --> 34:14.520
браузерами и учиться к тому-то нет поршивны的 района видов sacred board с той Halloween

34:14.580 --> 34:22.560
как бы в работе такого блокчейна такие идеи тоже это были ну и конечно же но до валидатор которые

34:22.560 --> 34:30.840
производят блоки вот но это по сути то же самое и ему сгодится как бы full но да да как бы валидатор

34:30.840 --> 34:36.000
штука нагруженная получает последнюю версию блока у него есть как бы текущий стейт даты

34:36.000 --> 34:42.020
бейсом формирует как бы новый блок формирует изменения в стейт даты бейс как бы все это

34:42.020 --> 34:50.140
записывает как были отдает как другим ну то есть майнеры майнеры валидаторы так далее вот это значит

34:50.140 --> 34:58.600
к софту мы про надо еще тоже как бы поговорим с вами вот это просто для того чтобы вы обозрели

34:58.600 --> 35:07.900
как бы горизонт софта как бы с которым придется работать а теперь значит про распределенные базы

35:07.900 --> 35:11.060
данных распределенные базы данных

35:12.020 --> 35:20.900
ну то есть блокчейн подают по сути как какой-то какое-то новое не знаю там направление какой-то

35:20.900 --> 35:28.580
отдельный какой-то там не знаю там область знания но на самом-то деле на самом деле сама вот это

35:28.580 --> 35:34.760
как бы идея вот этого блокчейна как бы сетевого консенсуса она уже изо всех сил прорабатывается

35:34.760 --> 35:41.840
в базах данных то что много у кого были бы были базы данных вот чтобы изоляция

35:42.020 --> 35:46.860
транзакции там какой-то хэдлок репликация было у кого-нибудь

35:46.860 --> 36:00.340
так понятно ну ладно ну вообще это довольно как бы важная такая концепция и кстати говоря

36:00.340 --> 36:06.500
над sky до что для блокчейна разработчика база данных это типа одна из областей как бы знаний

36:06.500 --> 36:12.020
в которой хорошо бы хорошо рубать у нас в общем то наверное если так

36:12.020 --> 36:17.780
сформулируйте по требования какие был член разработчики крутые то но так вот если на

36:17.780 --> 36:24.280
пальцах то это человек который имеет хорошие такие глубокие знания в трех из пяти как бы

36:24.280 --> 36:30.240
областей области такие лишь первый это алгоритм и структуры данных второе это там криптография

36:30.240 --> 36:37.100
но это понятно естественно это все как вы говорили третье это как ни странно базы данных 4 это

36:37.100 --> 36:42.020
операционная система потому что но именно прям вот как внутри как бы устроена операционная

36:42.020 --> 36:47.120
система переключения процессов всякие там страничные механизмы так далее то что там на

36:47.120 --> 36:54.200
самом деле очень много всего используется крайне эффективно как бы зубья из алгоритмов и 5 это там

36:54.200 --> 37:00.860
безопасность сетевые протоколы то есть умение построить именно сам протокол там я тебе рандом

37:00.860 --> 37:06.400
ты мне подпись этого рандома как бы я тебе в ответ как бы там еще что то то есть то есть понимание

37:06.400 --> 37:11.840
таких низкого уровня механизмах тоже круто для всего в трех из пяти этих областей как бы

37:12.020 --> 37:20.120
да то есть если вы действительно хорошо разбираетесь то с букчейнами будет не очень сложно значит

37:20.120 --> 37:29.720
про репликации я уже много раз говорил значит мы говорим о самом сложном виде репликации которые

37:29.720 --> 37:36.820
есть он называется master мастер значит таким мастер и если вы заходите на индекс там на какую

37:36.820 --> 37:41.720
бы там страницу там не знаю на страницу маркета и делайте выборку дай мне все товары как бы цена

37:42.020 --> 37:49.340
короче говоря и которые там чайники там например у вас происходит выборка из базы данных и вам api

37:49.340 --> 37:55.160
вам api соответственно выдает все вот эти чайники отрисовывать значит на самом деле вы обращаетесь

37:55.160 --> 38:03.820
к базе данных который называется слив и в этой базе данных лежат все чайники но она ридон ли

38:03.820 --> 38:10.940
то есть она заточена на число запросу что вот этих селектов их немерено их там сотни тысяч и

38:10.940 --> 38:16.460
поэтому как бы в яндексе огромное количество этих слоев серверов там не знаю там сотни как

38:16.460 --> 38:22.580
бы там я не знаю там сотни там не знаю может быть тысячи а на самом деле серверов в которой

38:22.580 --> 38:28.520
ведется запись куда добавляются чайники чайники добавляются гораздо реже чем они всплывают как

38:28.520 --> 38:35.420
бы запросах такие базы как бы которые именно у right они называются мастер вот вот мы как бы

38:35.420 --> 38:40.880
все это как бы архитектуры этих слоев как бы забыли у нас есть только мастера теперь

38:40.940 --> 38:51.540
вот по сути майнеры там валидаторы блок-блок продюсер это база данных она довольно часто

38:51.540 --> 38:57.020
эта штука как бы нужно если мы говорим о банке о каком-то дата у нас есть там не знаю там 100

38:57.020 --> 39:05.540
долларов на счету здесь как бы а банк международный и у него вот эта реплика там юсей как бы вот эта

39:10.940 --> 39:17.260
и нам нужно консистентность между ними соблюсти то есть если человек одновременно отправит запрос

39:17.260 --> 39:22.880
сюда и сюда и скажет как бы здесь минус 100 баксов я покупаю велосипед а здесь минус 100 баксов я

39:22.880 --> 39:28.140
покупаю там чайник то как бы надо будет что-то делать то есть либо у него станет баланс минус

39:28.140 --> 39:35.880
100 долларов вот ну то есть поставка не договорятся как бы и там придется там как-то это решать либо

39:35.880 --> 39:40.840
каждый из этих серверов должен поменяться как бы сказать у меня вот столько времени а чувак хочет

39:40.940 --> 39:46.700
снять 100 баксов ты типа согласен тут говорит но у меня время попозже так что я вот ему дам от лук

39:46.700 --> 39:53.420
как бы а тебе как бы разрешаю выполнить эту транзакцию и потом еще и вот и вот это спросит

39:53.420 --> 39:59.740
как бы это же получит вам ответ или там или динай посчитает эти голоса вот в общем мастер мастер

39:59.740 --> 40:05.500
репликация штука такая непростая вот и когда начинаешь читать эти алгоритмы вот этой мастер

40:05.500 --> 40:10.920
мастер репликации там raft access если вам там интересно то они почитают

40:10.940 --> 40:16.340
то после изучения как бы консенсуса в блокчейне вы увидите что это вообще как бы одно и то же

40:16.340 --> 40:23.060
просто как бы здесь будут вместо типа ответов битиков типа окей не окей будут просто электронные

40:23.060 --> 40:27.980
подписи участников ну и проверка что они в правильном реестр там находится и так далее

40:27.980 --> 40:35.900
то есть здесь те же самые как бы подтверждение между репликами это значит тут по сути репликация

40:35.900 --> 40:40.940
данных между между базами данных теперь что такое брайтах от лока

40:40.940 --> 40:49.340
мы теперь смотрим на одну базу данных в которой постоянно валится дофига всяких запросов там

40:49.340 --> 40:56.000
вставка удаления но у нас там в базе данных там соответственно строчки как бы кто-то как бы добавил

40:56.000 --> 41:01.160
новую строчку там с васей как бы его 100 долларов то таки за вычеркнул какую-то строчку там у него

41:01.160 --> 41:09.020
баланс до нуля кто-то про апдейтил строчку insert апдейт и доделит вот они валятся тут мастер реплика

41:10.940 --> 41:18.980
как она это дело процессе во-первых если она будет их просто накатывать как бы атомарно каждую

41:18.980 --> 41:25.820
транзакцию вот так вот как бы на таблицу возникает проблема различных блокировок то есть там я сейчас

41:25.820 --> 41:31.680
вот апдейт вот эту вот строчку а мой менеджер делает выборку там не знаю делает среднее там

41:31.680 --> 41:39.920
не знаю число как бы денег на балансе и вот пока как бы я вот эту свою апдейт не закончу не разберусь

41:40.940 --> 41:45.180
его менеджеру придется подождать потому что он там тоже там стучится со своими там не знаю там

41:45.180 --> 41:51.980
селекциями там и так далее то есть я вот эту штуку блокирую на это время или оставляя там тысячу новых

41:51.980 --> 41:59.180
как бы строк или еще что-то а еще как бы в базы данных вот эти вещи они объединяются в транзакции

41:59.180 --> 42:03.940
то есть там сначала две вставки потом одно удаление потом один апдейт то есть это в одну

42:03.940 --> 42:10.940
таблицу другую то встретит 4 и все это должно выполняться еще атомарно то есть

42:10.940 --> 42:16.820
либо все выполнилось либо все как бы откатилась целиком то есть баз данных нам так позволяют

42:16.820 --> 42:21.760
делать как бы не задумываться что там под капотом как бы а под капотом там как раз находится вот этот

42:21.760 --> 42:29.900
в райдах от лог то есть лог который пишет только вперед значит туда вот эти все транзакции складываются

42:29.900 --> 42:40.060
t1 t2 t3 прям в порядке в котором они приходят t4 там и у него есть понятие у этого в райдах лога так называемый чекпоинт

42:40.940 --> 42:50.780
ну потом опять сколько транзакции потом опять как бы потом опять чипом там опять в транзакции опять

42:50.780 --> 42:58.480
как бы чип он вот чип видом . в которой в нашей базе данных информация фиксируется то есть сделали

42:58.480 --> 43:04.540
т1 т23 т4 поставили чекпоинт то есть провели первую транзакцию вторую транзакцию третью

43:04.540 --> 43:10.740
транзакцию 4 транзакция за комит или по сути как бы сделали комик в базы данных

43:10.940 --> 43:15.540
есть прям собственно инструкция такая как бы комит провести вот эту мою транзакцию как бы

43:15.540 --> 43:24.140
и в конце как бы сделать камень если все хорошо прошло вот соответственно база запоминает свои

43:24.140 --> 43:30.980
так называемые снэпшоты снимки как бы на каждый чекпоинт и если вот здесь вот я вырублю свет

43:30.980 --> 43:36.260
внутри как бы чекпоинт ну то давайте вот здесь вот короче говоря выключу свет то есть я сделал

43:36.260 --> 43:42.260
там закатил первую транзакцию вторую а вот 3 4 не успел как бы у меня компьютер вырубили то

43:42.260 --> 43:45.960
в следующий раз когда база поднимется она поймет как бы что она находится вот на этом

43:45.960 --> 43:51.820
чекпоинте она поймет что вот эти накаченные мной изменения на диск запиши записаны они

43:51.820 --> 43:58.140
еще не за комыми чен и то есть они еще не в комите и она как бы откатит базу да вот это

43:58.140 --> 44:04.520
учит по это и начнет как с него работать а начнет наказывать как бы то есть такие как

44:04.520 --> 44:06.140
бы именно такието

44:06.260 --> 44:10.520
точки невозврата, по сути, вот этим, как бы, чекпоинтами,

44:10.680 --> 44:13.660
и базы данных умеют быстро между ними переключаться,

44:13.780 --> 44:14.920
то есть быстренько сбрасывать.

44:16.220 --> 44:20.000
То есть там есть версии строк, там, в общем, куча разных механизмов.

44:20.080 --> 44:22.420
Это, кстати, очень, ну, очень полезно почитать.

44:22.580 --> 44:26.840
Полезно почитать, как это сделано там в MySQL, в Postgres, наверное,

44:26.840 --> 44:30.520
наиболее такая, как бы, хорошо описанная, как бы, вот эта вот история

44:30.520 --> 44:33.700
с версионированием строк, как они вот с этим работают.

44:33.700 --> 44:38.480
То есть интересно, да, почитать, как это все сделано в KVL, в базах данных.

44:38.740 --> 44:42.260
Значит, в KVL, в базах данных, вот всякие наши Mongo и Redis,

44:42.760 --> 44:46.080
вот эти вот транзакции, то есть почему они такие быстрые,

44:46.140 --> 44:49.260
потому что они очень простые, то есть они просто, как бы, тупые,

44:49.320 --> 44:52.060
они не бегают, как бы, не захватывают там миллионы строк, как бы,

44:52.080 --> 44:56.560
в одной транзакции, вот, ну, либо они как-то очень так

44:56.560 --> 45:00.340
аранжируются там правильно, там быстрее работают чекпоинты,

45:00.340 --> 45:03.320
вот эти вот откаты, как бы, поэтому эти базы, они более,

45:03.440 --> 45:03.680
более...

45:03.700 --> 45:05.420
более быстрые, вот.

45:05.460 --> 45:08.380
Но они, конечно, такую логику, как SQL, не позволяют реализовать,

45:08.460 --> 45:12.360
там, типа, не знаю, там, там, очень сложных выборок.

45:13.200 --> 45:15.580
Вот, и вот эта вот конструкция называется Write a Headlock.

45:17.100 --> 45:21.180
Секрет KVL в баз данных, как раз, вот тоже, в Mongo и Redis,

45:21.220 --> 45:27.440
в том, что они бегут по вот этому логу крайне предсказуемо

45:27.440 --> 45:30.160
с точки зрения потребления ресурсов.

45:30.160 --> 45:32.560
То есть они вот эти вот расстояния между чекпоинтами,

45:32.560 --> 45:36.740
они, в отличие от SQL, очень здорово измеримы, то есть прям

45:36.740 --> 45:39.240
по количеству обновляемых ключей, то есть здесь прямо

45:39.240 --> 45:42.820
есть какое-то такое фиксированное N, как бы, и они очень здорово

45:42.820 --> 45:47.180
отмеряют вот эти вот кванты исполнения, и у вас компьютер,

45:47.180 --> 45:50.940
ну, задействован, задействован на полную, как бы, мощность,

45:51.020 --> 45:53.560
он прям жрет максимальное количество вот этих транзакций.

45:53.640 --> 45:56.420
А в SQL потенциально может прилететь вот эта вот прям

45:56.420 --> 45:59.640
огромная какая-нибудь штука, которая все это дело, как бы,

45:59.640 --> 46:01.120
затормозит сильно надолго.

46:01.120 --> 46:08.060
Ну, и в SQL базах там бывают, как бы, всякие там процедуры

46:08.060 --> 46:12.520
оптимизации вот этих таблиц, уплотнения, когда они приходят,

46:12.580 --> 46:15.600
здесь все начинает тормозить, все, все, как бы, останавливаются,

46:15.740 --> 46:18.900
процессинг вау останавливается, вот.

46:20.360 --> 46:25.100
И есть такой класс, как бы, k-value баз данных, levelDB,

46:25.600 --> 46:29.680
его наследница rocksDB, здесь такие две, короче говоря,

46:29.680 --> 46:30.900
k-value базы данных.

46:31.120 --> 46:36.900
Которые знамениты тем, что они наиболее предсказуемым образом

46:36.900 --> 46:39.900
вот этот вот вал, как бы, процесса, то есть очень-очень ровно,

46:40.180 --> 46:44.240
то есть никогда не бывает у вас там на компьютере, что CPU у вас вот такой,

46:44.320 --> 46:49.380
а потом вдруг вот такой вот, потому что пришел скрипт компактификации

46:49.380 --> 46:53.860
вот этой вот таблицы или там что-нибудь еще, то есть или там пришел там,

46:53.900 --> 46:57.180
я не знаю, там какой-то супер запрос, который все, как бы, повалил,

46:57.180 --> 47:00.860
то есть они работают прям ровно, то есть больше ключей вот так вот,

47:00.960 --> 47:01.100
вот так вот.

47:01.120 --> 47:06.120
И пока не упрутся в 100%, как бы, ну, там уже, как бы, да, ловить нечего,

47:06.200 --> 47:08.420
там все умерло, вот.

47:10.020 --> 47:15.120
И, ну, у них там специально от слова, как бы, level, там на самом деле идет,

47:15.900 --> 47:21.600
как бы, вот этот первый вал в write a headlock, данные из него собираются,

47:21.680 --> 47:27.140
как бы, там во второго уровня, там level 2, как бы, там упаковываются,

47:27.140 --> 47:31.080
там достаточно тоже предсказуемо, потом level 2, как бы, еще,

47:31.120 --> 47:35.400
упаковываются в следующий, как бы, лейер, вот.

47:35.440 --> 47:39.680
И вот таким вот образом здесь получается такой очень ровный, предсказуемый процессор.

47:39.800 --> 47:44.320
Поэтому вот блокчейн ноды выбирают вот такие вот базы данных,

47:44.480 --> 47:50.380
level db, rocks db, под капотом и у Геса, и там, по-моему, и у Эрегона,

47:50.760 --> 47:55.340
и в RAST-имплементациях, и в Тоне, и в Polkadot, короче говоря,

47:55.340 --> 48:00.880
ну, то есть и в разных блокчейнах, как бы, под капотом очень часто стоит вот это вот level db,

48:00.880 --> 48:04.820
или rocks db, как раз вот за счет вот этих вот ее фишек.

48:05.700 --> 48:11.140
Очень жестко структурированные транзакции, прибитые прям гвоздями, там, по размеру,

48:11.220 --> 48:15.400
по времени исполнения, предсказуемая вот эта компактификация, как бы,

48:15.620 --> 48:21.440
и отсутствие таких производительности просадок таких жестких, вот.

48:21.520 --> 48:23.660
Потому что для блокчейна это смерти подобно.

48:24.280 --> 48:30.360
Если вы можете какой-то транзакции вызвать, не знаю, залипание блокчейн ноды

48:30.880 --> 48:34.140
в очень серьезное время, как бы, вы, по сути, атаковали блокчейн.

48:34.340 --> 48:39.920
Вот, если найдете такую штуку, вот, можете приватно отрепортить, как бы, разработчикам,

48:40.020 --> 48:40.780
получите баунти.

48:42.660 --> 48:49.740
Теперь, опять же, с этой точки зрения, тоже, как бы, у кого не было, у кого не было баз данных,

48:50.280 --> 48:52.020
объясню, что такое хранимая процедура.

48:52.280 --> 48:58.480
Хранимая процедура – это как раз вот эта вот пачка вставок, делитов, еще какая-то логика,

48:58.480 --> 49:00.780
там, типа, если, как бы, там, не знаю, там, денег.

49:00.880 --> 49:05.820
Больше нуля, то еще сделать вставку в такую-то таблицу, и так далее, и так далее.

49:06.320 --> 49:07.440
Там, проапдейтить.

49:07.880 --> 49:13.420
И вся вот эта вот штука, она, по сути, лежит в базе данных, прям код, как бы, вот этой вот процедуры,

49:13.540 --> 49:18.640
он прям лежит прямо в SQL-базе данных, и вы вызываете его названием функции.

49:18.700 --> 49:24.860
Ну, например, в Тинькофф, как бы, приносите деньги, там, не знаю, там, оплата, как бы, за кредит.

49:25.280 --> 49:30.380
У него в базе вызывается вот эта вот хранимая процедура, что же это про сейджи,

49:30.880 --> 49:38.540
как бы, увеличит вам баланс, потом, там, типа, удалит, там, типа, задолженность за текущий месяц,

49:38.800 --> 49:41.780
за current month, там, не знаю, платеж, например, если за кредит.

49:42.460 --> 49:47.300
Типа, если, как бы, там, остались еще деньги, как бы, на кредите,

49:47.420 --> 49:52.380
то он вам еще добавит, короче говоря, еще план платежей на следующий месяц,

49:52.900 --> 49:55.260
проапдейтит ваш кредитный рейтинг.

49:55.860 --> 49:59.600
И исполняться вот эта функция, она будет тоже, как бы, атомарной.

50:00.400 --> 50:00.840
Да.

50:00.880 --> 50:04.680
То есть либо выполнится, либо целиком не выполнится, как бы,

50:04.740 --> 50:09.260
либо целиком выполнится, то есть для того, чтобы целостность в базе данных обеспечена.

50:09.400 --> 50:11.600
Такие штуки называются хранимые процедуры.

50:12.980 --> 50:16.100
Вот, там, по-разному, там, вот, там, вызывают в разных базах,

50:16.180 --> 50:20.980
там, где функции, где хранимые процедуры, вот, в общем, там, терминологии, как бы, очень много.

50:21.660 --> 50:25.260
Но, по сути, это, как бы, пачка атомарных действий с...

50:25.900 --> 50:28.400
Атомарная пачка действий из базы данных.

50:28.860 --> 50:30.640
И смарт-контракты очень похожи на вот эти...

50:30.880 --> 50:32.640
хранимые процедуры. То есть если просто

50:32.640 --> 50:34.540
рассматривать эфир как базу данных, то как бы

50:34.540 --> 50:36.420
смарт-контракт это, можно сказать, как бы в нем

50:36.420 --> 50:38.560
хранимые процедуры. Транзакции,

50:38.640 --> 50:40.120
это понятно, как бы пишущие,

50:40.480 --> 50:42.800
это транзакции, которые пишут

50:42.800 --> 50:44.720
в базу, то есть такая же

50:44.720 --> 50:46.700
аналогия. Консенсус

50:46.700 --> 50:49.140
алгоритма это репликация мастер-мастер,

50:50.260 --> 50:50.660
то есть точно

50:50.660 --> 50:52.700
так же как бы то, что здесь

50:52.700 --> 50:54.760
у нас ноды для того, чтобы

50:54.760 --> 50:56.820
договориться о том, как бы

50:56.820 --> 50:58.740
принять блок или не

50:58.740 --> 51:00.540
принять блок, использовать для этого как бы

51:00.540 --> 51:02.540
деньги какие-то там, я не знаю,

51:02.660 --> 51:04.460
там Proof of Work или там Kilowatt,

51:04.560 --> 51:06.600
или там в Proof of Stake договариваться

51:06.600 --> 51:08.820
как бы входишь ли ты в список валидаторов,

51:08.880 --> 51:10.480
за которые деньгами проголосовали.

51:10.880 --> 51:12.340
Это на самом деле второй вопрос.

51:13.580 --> 51:14.940
Здесь просто получается

51:14.940 --> 51:16.180
решать вот эту проблему

51:16.180 --> 51:18.720
распределенного консенсуса этой репликации

51:18.720 --> 51:20.780
при помощи экономических механизмов.

51:20.780 --> 51:22.780
Потому что многие действия как бы просто

51:22.780 --> 51:24.680
невыгодны большинству участников.

51:26.020 --> 51:26.840
Вот. А

51:26.840 --> 51:28.680
по сути это как бы и есть та самая

51:28.680 --> 51:30.080
репликация мастер-мастер,

51:30.080 --> 51:32.200
причем это на

51:32.200 --> 51:34.520
низком уровне это репликация

51:34.520 --> 51:36.040
LevelDB, ну там или

51:36.040 --> 51:38.360
ROXDB, там неважно, какие вы или базы данных

51:38.360 --> 51:40.360
как бы получаются, на самом деле как бы по сути

51:40.360 --> 51:42.580
это механизм репликации

51:42.580 --> 51:44.260
для вот этих вот баз данных, так если

51:44.260 --> 51:45.900
прям совсем как бы на пальцы.

51:47.440 --> 51:47.860
Вот.

51:48.120 --> 51:50.300
Тогда в этом случае наш write a headlock

51:50.300 --> 51:52.180
вот этот, в который мы как бы складируем

51:52.180 --> 51:54.000
транзакции одни за другой, потом их

51:54.000 --> 51:56.500
оформляем как бы в пачки и накатываем

51:56.500 --> 51:57.920
их, то есть на там

51:57.920 --> 51:58.520
чекпоинт,

52:00.080 --> 52:02.080
то как бы вот это вот наш пул транзакций

52:02.080 --> 52:04.140
в P2P, который висит

52:04.140 --> 52:05.940
полностью такой публичный,

52:06.620 --> 52:07.800
а чекпоинты

52:07.800 --> 52:08.980
и коммиты в этом

52:08.980 --> 52:12.440
в этом write a headlock

52:12.440 --> 52:14.080
это по сути как бы новые блоки.

52:14.920 --> 52:15.920
То есть произвели блок,

52:16.040 --> 52:18.140
взяли вот такое вот количество транзакций,

52:18.740 --> 52:19.840
а тамарных накатили

52:19.840 --> 52:22.080
как бы на state database, если потом блок

52:22.080 --> 52:23.780
нам не понравился, мы его откатили

52:23.780 --> 52:24.960
так же как бы а тамарных.

52:25.700 --> 52:28.000
Там вернулись вот сюда как бы к предыдущему

52:28.000 --> 52:28.920
как бы чекпоинту.

52:30.080 --> 52:33.100
Это к тому, что

52:33.100 --> 52:34.980
как бы блокчейн не какие-то там

52:34.980 --> 52:37.020
космолеты, а на самом деле в общем по сути

52:37.020 --> 52:38.740
используют штуки, которые

52:38.740 --> 52:41.020
большие, там крупные

52:41.020 --> 52:42.880
как бы сайты, высоконагруженные

52:42.880 --> 52:44.900
приложения, как бы используют уже годами.

52:45.080 --> 52:46.320
То есть там уже очень много

52:46.320 --> 52:49.120
всего сделано. Там под капотом на самом

52:49.120 --> 52:50.700
деле все те же самые механизмы

52:50.700 --> 52:52.020
находятся.

52:53.200 --> 52:54.500
Вот это про как бы

52:54.500 --> 52:56.640
аналогии с базой данных.

52:58.320 --> 52:59.240
Теперь про

52:59.240 --> 53:00.060
сам шаг.

53:00.080 --> 53:02.120
Смарт-контракт. Так, давайте по прошлому.

53:02.280 --> 53:03.860
Материалы есть? Какие-то вопросы?

53:09.960 --> 53:10.520
Тишина.

53:11.240 --> 53:11.720
Все понятно.

53:12.160 --> 53:14.380
Да, вопросов нет. Отлично.

53:15.420 --> 53:16.560
Так, я еще хотел узнать

53:16.560 --> 53:20.360
как идет ли у нас

53:20.360 --> 53:22.000
запись. Да, идет. Отлично.

53:22.480 --> 53:23.700
Так, поехали.

53:23.980 --> 53:24.860
Вращаю обратно.

53:28.180 --> 53:29.960
Теперь что же

53:30.080 --> 53:32.120
с собой представляется собственно сам

53:32.120 --> 53:34.400
смарт-контракт? Что на них можно

53:34.400 --> 53:36.080
делать? Тоже немножко сегодня

53:36.080 --> 53:36.840
поговорим.

53:38.600 --> 53:40.120
Вернемся обратно как бы

53:40.120 --> 53:42.180
к той нашей как бы прошлой табличке.

53:42.560 --> 53:44.100
Что значит у нас там был Вася,

53:44.580 --> 53:46.520
у него соответственно

53:46.520 --> 53:47.900
был баланс эфира,

53:48.840 --> 53:50.320
у него был анонс

53:50.320 --> 53:52.040
счетчик его транзакций,

53:52.680 --> 53:54.320
у него не было никакого кода,

53:55.400 --> 53:56.480
вот, у него не было

53:56.480 --> 53:57.960
никакого там сториджа.

54:00.080 --> 54:02.440
Вот. И потом он задеплоил

54:02.440 --> 54:03.740
смарт-контракт в сеть.

54:04.200 --> 54:06.060
У этого смарт-контракта появился

54:06.060 --> 54:08.620
адрес, что очень важно. То есть у смарт-контрактов

54:08.620 --> 54:09.300
есть адрес.

54:10.020 --> 54:12.260
У него есть баланс эфира. Когда он создал

54:12.260 --> 54:13.940
он, например, был ноль, как бы, но

54:13.940 --> 54:16.220
в принципе, если контракт позволяет

54:16.220 --> 54:18.060
его код принять себе

54:18.060 --> 54:19.760
как бы эфир, то он может как бы быть

54:19.760 --> 54:22.040
и не нулевым. У него тоже

54:22.040 --> 54:23.720
есть нонс у этого контракта.

54:24.160 --> 54:26.040
Он меняется, если контракт

54:26.040 --> 54:27.960
создает другие контракты, то есть

54:27.960 --> 54:30.040
деплоит как бы там следующие,

54:30.080 --> 54:31.840
как бы там контракты, то у него

54:31.840 --> 54:32.720
нонс меняется.

54:34.040 --> 54:34.480
Вот.

54:35.860 --> 54:37.320
У него есть байт-код.

54:38.980 --> 54:39.940
То есть прям вот

54:39.940 --> 54:41.500
как, не знаю, как содержимое

54:41.500 --> 54:43.120
экзешника, грубо говоря, по сути.

54:44.340 --> 54:45.940
Машинные инструкции, как бы, которые

54:45.940 --> 54:46.920
исполняются EOM.

54:47.800 --> 54:49.860
А, и этот код, как бы, может обращаться

54:49.860 --> 54:51.620
к своему собственному сториджу,

54:51.780 --> 54:53.760
который представляет собой k-value.

54:53.960 --> 54:54.780
Я вообще решил, наверное,

54:55.340 --> 54:58.120
ну, я раньше всегда рисовал вот так вот,

54:58.120 --> 55:00.060
типа кусочки в этом k-value, там, типа,

55:00.080 --> 55:02.020
что у адреса один, там, такие-то данные,

55:02.080 --> 55:04.340
у адреса два, как бы, вторые, другие данные.

55:04.840 --> 55:06.100
Но это вообще не очень правильно,

55:06.440 --> 55:08.020
когда я вам рисую, как бы,

55:08.080 --> 55:10.020
ну, я очень люблю вот эту картинку,

55:11.040 --> 55:12.040
когда здесь, типа, код,

55:12.300 --> 55:14.080
а здесь у нас записано, типа, что там

55:14.080 --> 55:16.040
у Васи, как бы, 100 токенов, значит,

55:16.140 --> 55:18.440
а у Пети 200 токенов.

55:18.500 --> 55:20.020
Вот просто может, как бы, показаться,

55:20.140 --> 55:22.120
что они один за другим идут,

55:22.220 --> 55:24.180
как бы, вот эти вот адреса, там, как-то в памяти

55:24.180 --> 55:25.840
они, там, располагаются рядом.

55:26.120 --> 55:28.040
На самом деле, ну, не так.

55:28.040 --> 55:30.020
То есть вся адресация, она именно k-value,

55:30.080 --> 55:32.240
то есть у этого есть ключ, как бы,

55:32.400 --> 55:33.500
у этого есть ключ,

55:34.240 --> 55:36.240
а value является,

55:36.320 --> 55:37.280
как бы, вот этой вот штукой.

55:37.680 --> 55:40.000
Вот, может, какой-то другой способ изобретать, рисовать

55:40.000 --> 55:41.640
эту вещь. Вот.

55:43.500 --> 55:43.980
Значит,

55:44.280 --> 55:48.000
очень важная, как бы, история о том,

55:48.160 --> 55:49.400
как устроен

55:49.400 --> 55:51.920
storage-контракт. Это штука

55:51.920 --> 55:53.820
такая, как бы, тоже

55:53.820 --> 55:55.160
относится к тому, что я сейчас

55:55.160 --> 55:56.340
рисовал.

55:58.120 --> 55:58.600
Смотрите,

55:59.280 --> 55:59.900
у меня,

56:00.080 --> 56:02.680
один и тот же код, у меня есть какая-нибудь переменная,

56:02.680 --> 56:04.680
variable a,

56:04.680 --> 56:08.280
значит, она где-то, как бы, в storage-е находится.

56:08.280 --> 56:10.280
Вот, вот здесь, вот у меня, вот здесь,

56:10.280 --> 56:12.280
ссылается, как бы, на переменную a.

56:12.280 --> 56:14.280
У меня там записано 100.

56:14.280 --> 56:16.280
Как бы, потом я говорю a равно 200,

56:16.280 --> 56:18.280
как бы, здесь становится 200.

56:18.280 --> 56:20.280
И

56:20.280 --> 56:22.280
вот этот вот код, представьте,

56:22.280 --> 56:24.280
что он...

56:24.280 --> 56:26.280
Ой, простите.

56:26.280 --> 56:28.280
Тихо, ну.

56:28.280 --> 56:29.280
Что этот код, он, как бы, не имеет никакого значения.

56:29.280 --> 56:31.280
Что этот код, он, на самом деле, находится

56:31.280 --> 56:33.280
на большом количестве разных компьютеров

56:33.280 --> 56:35.280
с разной архитектурой.

56:35.280 --> 56:37.280
Если бы мы этот код

56:37.280 --> 56:39.280
запускали, как бы, в разных, там,

56:39.280 --> 56:41.280
ну, не знаю, там, на JS

56:41.280 --> 56:43.280
и в разных браузерах, на

56:43.280 --> 56:45.280
C++, короче говоря, на разных

56:45.280 --> 56:47.280
машинах, то у нас у этой

56:47.280 --> 56:49.280
переменной каждый раз бы выделялся

56:49.280 --> 56:51.280
определенный адрес памяти, какой-нибудь, там,

56:51.280 --> 56:53.280
0x, там, не знаю, там,

56:53.280 --> 56:55.280
fa0000001,

56:55.280 --> 56:57.280
кто там на C, там, прогал.

56:57.280 --> 56:59.280
Вот.

56:59.280 --> 57:01.280
И эти адреса

57:01.280 --> 57:03.280
этой переменной, они, на самом деле,

57:03.280 --> 57:05.280
были бы разные. То есть в другом контракте,

57:05.280 --> 57:07.280
как бы, по D2A было бы

57:07.280 --> 57:09.280
выделено, было бы выделено другое

57:09.280 --> 57:11.280
место в памяти с другим

57:11.280 --> 57:13.280
адресом, там, и так далее, и так далее.

57:13.280 --> 57:15.280
Значит, для того, чтобы

57:15.280 --> 57:17.280
даже storage,

57:17.280 --> 57:19.280
как бы, имел полностью детерминированный

57:19.280 --> 57:21.280
вид на всех, как бы, компьютерах,

57:21.280 --> 57:23.280
переменные в смарт-контрактах,

57:23.280 --> 57:25.280
все внутренние, как бы, они адресуются

57:25.280 --> 57:27.280
исключительно по ключу. Вот.

57:27.280 --> 57:29.280
Причем довольно просто.

57:29.280 --> 57:31.280
Смотрите, у меня есть смарт-контракт,

57:31.280 --> 57:33.280
я объявил в нем первую переменную

57:33.280 --> 57:35.280
размером,

57:35.280 --> 57:37.280
ну, здесь у нас

57:37.280 --> 57:39.280
все будет размером 256 бит,

57:39.280 --> 57:41.280
практически все по дефолту, то есть любые

57:41.280 --> 57:43.280
данные размером 256 бит, любые

57:43.280 --> 57:45.280
ключи размером 256 бит.

57:45.280 --> 57:47.280
Сейчас объясню, почему.

57:47.280 --> 57:49.280
Я создал первую

57:49.280 --> 57:51.280
переменную, и

57:51.280 --> 57:53.280
грубо говоря, так называемый

57:53.280 --> 57:55.280
слот, есть такое, как бы,

57:55.280 --> 57:57.280
понятие в смарт-контрактах, вот этот вот слот,

57:57.280 --> 57:59.280
как бы, его адрес

57:59.280 --> 58:01.280
будет равен хэшу,

58:01.280 --> 58:03.280
вот тот самый, как бы, там,

58:03.280 --> 58:05.280
алгоритм хэширования, от

58:05.280 --> 58:07.280
адреса контракта и

58:07.280 --> 58:09.280
номера вот этого слота.

58:09.280 --> 58:11.280
Вот это, как бы, называется слот

58:11.280 --> 58:13.280
номер. Я

58:13.280 --> 58:15.280
переменную a объявил первой, как бы, она

58:15.280 --> 58:17.280
заняла слот 0.

58:17.280 --> 58:19.280
Она стала, как бы, вот сюда. То есть

58:19.280 --> 58:21.280
слот номер-то, конечно, 0,

58:21.280 --> 58:23.280
и когда я создам, как бы,

58:23.280 --> 58:25.280
переменную b, скажу, что там

58:25.280 --> 58:27.280
b равно a,

58:27.280 --> 58:29.280
и она у меня, переменная b, как бы,

58:29.280 --> 58:31.280
попадет в слот номер 1,

58:31.280 --> 58:33.280
хэш от контракта и от

58:33.280 --> 58:35.280
единицы. Вот здесь у меня будет

58:35.280 --> 58:37.280
переменная a, здесь будет переменная b,

58:37.280 --> 58:39.280
которая там будет равна,

58:39.280 --> 58:41.280
там, не знаю, там, 200.

58:41.280 --> 58:43.280
Тем не менее,

58:43.280 --> 58:45.280
то есть сам адрес

58:45.280 --> 58:47.280
вот этой вот ячейки в сторидже,

58:47.280 --> 58:49.280
он будет хэшом

58:49.280 --> 58:51.280
от адреса контракта и

58:51.280 --> 58:53.280
единицы.

58:53.280 --> 58:55.280
Для чего это сделано?

58:55.280 --> 58:57.280
Это сделано, чтобы на низком уровне

58:57.280 --> 58:59.280
в той же самой k-value базе данных,

58:59.280 --> 59:01.280
да, в нашей leveldb или roxdb

59:01.280 --> 59:03.280
один и тот же

59:03.280 --> 59:05.280
контракт работал всегда,

59:05.280 --> 59:07.280
ну, чтобы вот эту информацию

59:07.280 --> 59:09.280
о сторидже контракта хранить в

59:09.280 --> 59:11.280
k-value базе данных.

59:11.280 --> 59:13.280
То есть я на другом компьютере

59:13.280 --> 59:15.280
синканул блокчейн,

59:15.280 --> 59:17.280
накатил, как бы, свою state database,

59:17.280 --> 59:19.280
у меня там вот по вот этому адресу

59:19.280 --> 59:21.280
лежит переменная a

59:21.280 --> 59:23.280
от моего контракта,

59:23.280 --> 59:25.280
а по этому адресу

59:25.280 --> 59:27.280
лежит переменная b от адреса.

59:27.280 --> 59:29.280
Ну, от адреса контракта.

59:29.280 --> 59:31.280
Я могу всегда ее найти.

59:31.280 --> 59:33.280
И это будет абсолютно

59:33.280 --> 59:35.280
одинаково на всех компьютерах.

59:35.280 --> 59:37.280
То есть даже, как бы, значения переменных

59:37.280 --> 59:39.280
вот эти, они, по сути, будут в блокчейне

59:39.280 --> 59:41.280
реплицироваться через обновление

59:41.280 --> 59:43.280
вот этой вот state database.

59:43.280 --> 59:45.280
То есть кто-то выполнит транзакцию,

59:45.280 --> 59:47.280
запишет что-то в b,

59:47.280 --> 59:49.280
у b появится слот

59:49.280 --> 59:51.280
в сторидже, этот слот

59:51.280 --> 59:53.280
в сторидже, по сути, займет, как бы,

59:53.280 --> 59:55.280
определенную, ну, там,

59:55.280 --> 59:57.280
определенную данную

59:57.280 --> 59:59.280
и запишет, как бы, вот в этот вот leveldb,

59:59.280 --> 01:00:01.280
и

01:00:01.280 --> 01:00:03.280
вот этот ключ значения,

01:00:03.280 --> 01:00:05.280
они будут реплицированы.

01:00:05.280 --> 01:00:07.280
Ну, и, конечно, войдет в state root, будет включено

01:00:07.280 --> 01:00:09.280
в блок, там, и так далее. То есть каждые такие

01:00:09.280 --> 01:00:11.280
операции вот с этими переменами,

01:00:11.280 --> 01:00:13.280
которые находятся в сторидже,

01:00:13.280 --> 01:00:15.280
они все выполняются в консенсусе.

01:00:17.280 --> 01:00:19.280
То есть все изменения их

01:00:19.280 --> 01:00:21.280
реплицируются. Это довольно,

01:00:21.280 --> 01:00:23.280
как бы, важная штука, чтобы понимать, как бы,

01:00:23.280 --> 01:00:25.280
что там внутри контрактов происходит.

01:00:25.280 --> 01:00:27.280
То есть это, по сути,

01:00:27.280 --> 01:00:29.280
как бы, не оперативная

01:00:29.280 --> 01:00:31.280
память. Очень любят, как бы,

01:00:31.280 --> 01:00:33.280
там, контракт, как бы, выглядит

01:00:33.280 --> 01:00:35.280
так это по коду, как бы, что я

01:00:35.280 --> 01:00:37.280
объявил переменную, она у меня равна, там,

01:00:37.280 --> 01:00:39.280
тому-то, тому-то, но она там как-то сохраняется.

01:00:39.280 --> 01:00:41.280
На самом деле это именно

01:00:41.280 --> 01:00:43.280
сторидж.

01:00:43.280 --> 01:00:45.280
Сторидж это то, что аналог,

01:00:45.280 --> 01:00:47.280
я не знаю, записи на диск

01:00:47.280 --> 01:00:49.280
в реальной программе. Вот.

01:00:49.280 --> 01:00:51.280
А так у контракта, конечно же,

01:00:51.280 --> 01:00:53.280
есть у него, как бы, и оперативная

01:00:53.280 --> 01:00:55.280
память, memory,

01:00:55.280 --> 01:00:57.280
ему же там что-то надо делать, ему надо

01:00:57.280 --> 01:00:59.280
там, там, циклы какие-то делать, там,

01:00:59.280 --> 01:01:01.280
что-то там разворачивать в память, массивы

01:01:01.280 --> 01:01:03.280
в них там создавать, значит, бегать по ним,

01:01:03.280 --> 01:01:05.280
что-то там считать и так далее. То есть там

01:01:05.280 --> 01:01:07.280
тоже есть выделение памяти,

01:01:07.280 --> 01:01:09.280
локация этой памяти,

01:01:11.280 --> 01:01:13.280
ну, под определенные вещи. Ну, понятно,

01:01:13.280 --> 01:01:15.280
есть, конечно, там и del-локация,

01:01:15.280 --> 01:01:17.280
как бы, памяти, как бы, но она автоматом

01:01:17.280 --> 01:01:19.280
происходит, когда транзакция завершается,

01:01:19.280 --> 01:01:21.280
провод, все это выкидывается.

01:01:21.280 --> 01:01:23.280
А так, по-хорошему, есть, да, действительно,

01:01:23.280 --> 01:01:25.280
как бы, оперативная память. Поэтому не путайте, как бы,

01:01:25.280 --> 01:01:27.280
memory есть в смарт-контрактах,

01:01:27.280 --> 01:01:29.280
как бы, memory это

01:01:29.280 --> 01:01:31.280
отдельная история. Это то,

01:01:31.280 --> 01:01:33.280
что на момент исполнения одной функции,

01:01:33.280 --> 01:01:35.280
как бы, есть у контракта,

01:01:35.280 --> 01:01:37.280
то есть оперативная память,

01:01:37.280 --> 01:01:39.280
а есть storage.

01:01:39.280 --> 01:01:41.280
Вот, и

01:01:41.280 --> 01:01:43.280
поэтому там часть переменных, как бы, относится

01:01:43.280 --> 01:01:45.280
к storage, как бы, а часть переменных вы можете

01:01:45.280 --> 01:01:47.280
объявить, как бы, в памяти.

01:01:47.280 --> 01:01:49.280
Вот, это такая довольно важная штука.

01:01:49.280 --> 01:01:51.280
То, что storage в случае успешного

01:01:51.280 --> 01:01:53.280
завершения функции, если не будет

01:01:53.280 --> 01:01:55.280
реверта, как бы, оно сохраняется,

01:01:55.280 --> 01:01:57.280
так и вы, любая из данных, то есть вы присвоили

01:01:57.280 --> 01:01:59.280
а, там, 200, как бы, и оно будет

01:01:59.280 --> 01:02:01.280
все время 200, как бы, всегда,

01:02:01.280 --> 01:02:03.280
как бы, во всех следующих функциях вы

01:02:03.280 --> 01:02:05.280
обращаетесь к а, как бы, получите 200,

01:02:05.280 --> 01:02:07.280
там, через 100 блоков, там, если

01:02:07.280 --> 01:02:09.280
где-то обменений не было.

01:02:09.280 --> 01:02:11.280
Вот. Это такое, как бы,

01:02:11.280 --> 01:02:13.280
персистентное хранилище.

01:02:13.280 --> 01:02:15.280
Значит,

01:02:15.280 --> 01:02:17.280
сам код смарт-контрактов

01:02:17.280 --> 01:02:19.280
мы сейчас тоже будем смотреть.

01:02:19.280 --> 01:02:21.280
Давайте, может, прям сразу

01:02:21.280 --> 01:02:23.280
сходим, какой-нибудь там глянем.

01:02:23.280 --> 01:02:25.280
Простенький.

01:02:25.280 --> 01:02:27.280
RapidEther. Вот здесь можно

01:02:27.280 --> 01:02:29.280
посмотреть контракт его.

01:02:29.280 --> 01:02:31.280
Там есть, правда, там

01:02:31.280 --> 01:02:33.280
по-дурацки довольно. Sorry, там.

01:02:33.280 --> 01:02:35.280
Не знаю, как побольше сделать.

01:02:35.280 --> 01:02:37.280
То есть, вот так.

01:02:37.280 --> 01:02:39.280
Значит,

01:02:39.280 --> 01:02:41.280
так, тоже кратко, как бы, если по этой

01:02:41.280 --> 01:02:43.280
штуке, как бы, пробежаться, то

01:02:43.280 --> 01:02:45.280
на самом деле, в уме, как бы,

01:02:45.280 --> 01:02:47.280
слово контракт можно заменить на слово

01:02:47.280 --> 01:02:49.280
класс. Прям, вот, как

01:02:49.280 --> 01:02:51.280
C++ класс. Здесь, действительно,

01:02:51.280 --> 01:02:53.280
работает изо всех сил

01:02:53.280 --> 01:02:55.280
объект-ориентированное программирование.

01:02:55.280 --> 01:02:57.280
Солидить — это объект-ориентированный язык.

01:02:57.280 --> 01:02:59.280
Что мы еще,

01:02:59.280 --> 01:03:01.280
как бы, знаем, что у нас есть

01:03:01.280 --> 01:03:03.280
в объект-ориентированных языках?

01:03:03.280 --> 01:03:05.280
У нас есть конструкторы.

01:03:05.280 --> 01:03:07.280
Здесь они тоже есть. То есть,

01:03:07.280 --> 01:03:09.280
в тот момент, когда вы будете

01:03:09.280 --> 01:03:11.280
деплоить, размещать вот этот ваш код,

01:03:11.280 --> 01:03:13.280
как бы, у вас выполнится код конструктора,

01:03:13.280 --> 01:03:15.280
который инициализирует какие-то базовые вещи

01:03:15.280 --> 01:03:17.280
в сторидже.

01:03:17.280 --> 01:03:19.280
У нас есть публичные

01:03:19.280 --> 01:03:21.280
и приватные переменные.

01:03:21.280 --> 01:03:23.280
Вот здесь тоже, как бы, есть там public.

01:03:23.280 --> 01:03:25.280
Здесь, там, три вида, как бы, переменных.

01:03:25.280 --> 01:03:27.280
Вот.

01:03:27.280 --> 01:03:29.280
Имеются области видимости.

01:03:29.280 --> 01:03:31.280
Если это public, вы можете снаружи к ней обратиться,

01:03:31.280 --> 01:03:33.280
получить ее значение, использовать там

01:03:33.280 --> 01:03:35.280
каких-то там внешних функций.

01:03:35.280 --> 01:03:37.280
Если она private, то вы ее можете только

01:03:37.280 --> 01:03:39.280
внутри контракта использовать.

01:03:39.280 --> 01:03:41.280
Вот, снаружи не можете запросить.

01:03:41.280 --> 01:03:43.280
Здесь есть,

01:03:43.280 --> 01:03:45.280
ну, типы данных,

01:03:45.280 --> 01:03:47.280
там, все это мы с вами как раз

01:03:47.280 --> 01:03:49.280
на следующей лекции будем смотреть.

01:03:49.280 --> 01:03:51.280
То есть, самые, как бы,

01:03:51.280 --> 01:03:53.280
типовые солидите паттерны.

01:03:53.280 --> 01:03:55.280
Здесь есть ассоциативные массивы,

01:03:55.280 --> 01:03:57.280
там, массивы, как бы,

01:03:57.280 --> 01:03:59.280
с динамическим размером,

01:03:59.280 --> 01:04:01.280
фиксированной длины.

01:04:01.280 --> 01:04:03.280
Вот.

01:04:03.280 --> 01:04:05.280
Есть, соответственно, функция,

01:04:05.280 --> 01:04:07.280
вот, собственно, их название.

01:04:07.280 --> 01:04:09.280
У них тоже есть

01:04:09.280 --> 01:04:11.280
области видимости.

01:04:11.280 --> 01:04:13.280
Вот, есть всякие там ключевые словечки.

01:04:13.280 --> 01:04:15.280
Например, payable означает, что можно вызвать эту функцию

01:04:15.280 --> 01:04:17.280
и прислать в нее эфир.

01:04:17.280 --> 01:04:19.280
То есть, я могу

01:04:19.280 --> 01:04:21.280
создать транзакцию, сказать, вызываю функцию

01:04:21.280 --> 01:04:23.280
deposit и прикладываю к этому вызову

01:04:23.280 --> 01:04:25.280
10 эфира.

01:04:25.280 --> 01:04:27.280
Вот. Соответственно,

01:04:27.280 --> 01:04:29.280
контракт, если эту функцию правильно обработает,

01:04:29.280 --> 01:04:31.280
он съест мои 10 эфира,

01:04:31.280 --> 01:04:33.280
увеличит свой баланс на 10,

01:04:33.280 --> 01:04:35.280
как бы, запишет там,

01:04:35.280 --> 01:04:37.280
что-то себе, как бы, в storage про то, что

01:04:37.280 --> 01:04:39.280
я принес 10 эфира.

01:04:39.280 --> 01:04:41.280
Вот. Ну и, соответственно, функция там

01:04:41.280 --> 01:04:43.280
закончится. Вот.

01:04:43.280 --> 01:04:45.280
И есть функции

01:04:45.280 --> 01:04:47.280
getter'ы, а есть функции

01:04:47.280 --> 01:04:49.280
setter'ы. Так, чтобы я точно,

01:04:49.280 --> 01:04:51.280
как бы, ничего не забыл.

01:04:51.280 --> 01:04:53.280
Кстати, уберу вот это

01:04:53.280 --> 01:04:55.280
окно, мне клип мешает.

01:04:55.280 --> 01:04:59.280
Есть функции getter'ы, есть setter'ы.

01:04:59.280 --> 01:05:01.280
Значит, getter'ы, вот это ключевое

01:05:01.280 --> 01:05:03.280
слово view, это, по сути,

01:05:03.280 --> 01:05:05.280
функции, которые ничего

01:05:05.280 --> 01:05:07.280
не записывают.

01:05:07.280 --> 01:05:09.280
И у людей сразу, соответственно, вопрос, блин,

01:05:09.280 --> 01:05:11.280
ты же говорил, типа, что в блокчейне за все

01:05:11.280 --> 01:05:13.280
платят, как бы, а что, за вызов

01:05:13.280 --> 01:05:15.280
этой функции не платят?

01:05:15.280 --> 01:05:17.280
Ну вот, да, здесь есть

01:05:17.280 --> 01:05:19.280
проблема, за вызов этой функции не платят.

01:05:19.280 --> 01:05:21.280
То есть, если я хочу вызвать total supply

01:05:21.280 --> 01:05:23.280
у какого-нибудь контракта,

01:05:23.280 --> 01:05:25.280
вот, смотрите, в rapid-эфир,

01:05:25.280 --> 01:05:27.280
давайте у него вызовем функцию total supply.

01:05:27.280 --> 01:05:29.280
ReadContract

01:05:29.280 --> 01:05:31.280
здесь функция. Вот я хочу, короче, вызвать

01:05:31.280 --> 01:05:33.280
у него функцию total supply, вот он ее возвращает.

01:05:33.280 --> 01:05:35.280
Вот столько-то в rapid-эфире

01:05:35.280 --> 01:05:37.280
было, соответственно, там, выдано,

01:05:37.280 --> 01:05:39.280
там, напечатано пользователям

01:05:39.280 --> 01:05:41.280
и так далее.

01:05:41.280 --> 01:05:43.280
Как называется этот токен,

01:05:43.280 --> 01:05:45.280
сколько у него десятичных знаков после запятой

01:05:45.280 --> 01:05:47.280
и так далее.

01:05:47.280 --> 01:05:49.280
Какой баланс этого эфира у какого-то адреса.

01:05:49.280 --> 01:05:51.280
На эти вопросы,

01:05:51.280 --> 01:05:53.280
на вот эти вот view'ы

01:05:53.280 --> 01:05:55.280
мне нода отвечает,

01:05:55.280 --> 01:05:57.280
в общем-то, бесплатно.

01:05:57.280 --> 01:05:59.280
То есть, у меня

01:05:59.280 --> 01:06:01.280
вот мой вот этот metamask,

01:06:01.280 --> 01:06:03.280
мой клиент, как бы,

01:06:03.280 --> 01:06:05.280
он идет на ноду,

01:06:05.280 --> 01:06:07.280
он делает jsonrpc,

01:06:07.280 --> 01:06:09.280
как бы, запрос, говорит

01:06:09.280 --> 01:06:11.280
дай-ка мне функцию total supply

01:06:11.280 --> 01:06:13.280
total supply

01:06:13.280 --> 01:06:15.280
вот у этого контракта

01:06:15.280 --> 01:06:17.280
и нода просто, как бы, лезет, соответственно,

01:06:17.280 --> 01:06:19.280
сюда, там, в storage этого контракта

01:06:19.280 --> 01:06:21.280
вызывает вот эту view'шную функцию,

01:06:21.280 --> 01:06:23.280
которая view читает это значение,

01:06:23.280 --> 01:06:25.280
как бы, отдает его мне бесплатно,

01:06:25.280 --> 01:06:27.280
потому что никаких записей в блокчейн

01:06:27.280 --> 01:06:29.280
произведено не было,

01:06:29.280 --> 01:06:31.280
ни за что платить не надо,

01:06:31.280 --> 01:06:33.280
никакие блоки сформированы не были,

01:06:33.280 --> 01:06:35.280
но и, как бы,

01:06:35.280 --> 01:06:37.280
view функции, они, по сути,

01:06:37.280 --> 01:06:39.280
бесплатны.

01:06:39.280 --> 01:06:41.280
Тут есть некоторая такая,

01:06:41.280 --> 01:06:43.280
некоторый обман, потому что

01:06:43.280 --> 01:06:45.280
по поводу того, что они бесплатны,

01:06:45.280 --> 01:06:47.280
потому что, ну, они могут быть

01:06:47.280 --> 01:06:49.280
не совсем бесплатны,

01:06:49.280 --> 01:06:51.280
если у вас внутри вот здесь вот есть, как бы,

01:06:51.280 --> 01:06:53.280
функция, которая пишет в write,

01:06:53.280 --> 01:06:55.280
и она, как бы, внутри себя

01:06:55.280 --> 01:06:57.280
вызывает

01:06:57.280 --> 01:06:59.280
вот эту вот view функцию,

01:06:59.280 --> 01:07:01.280
ну, которая считает, например, вот это вот

01:07:01.280 --> 01:07:03.280
total supply.

01:07:03.280 --> 01:07:05.280
То есть она ее вызывает

01:07:05.280 --> 01:07:07.280
и потом использует ее результат.

01:07:07.280 --> 01:07:09.280
Тогда, как бы, когда

01:07:09.280 --> 01:07:11.280
майнер будет исполнять, как бы, вот эту штуку,

01:07:11.280 --> 01:07:13.280
он, конечно, зайдет вот в эту функцию

01:07:13.280 --> 01:07:15.280
и с удовольствием

01:07:15.280 --> 01:07:17.280
вычитает с вас денежки

01:07:17.280 --> 01:07:19.280
за то, что ему пришлось, там, лезть

01:07:19.280 --> 01:07:21.280
в storage, что-то там обращаться,

01:07:21.280 --> 01:07:23.280
число получать, там, load делать,

01:07:23.280 --> 01:07:25.280
как бы, и так далее.

01:07:25.280 --> 01:07:27.280
То есть вот эта вот стоимость, как бы, этой функции,

01:07:27.280 --> 01:07:29.280
она все-таки будет приплюсована к газу.

01:07:29.280 --> 01:07:31.280
Так что, как бы, view не то, чтобы

01:07:31.280 --> 01:07:33.280
прям вот прям совсем бесплатный.

01:07:33.280 --> 01:07:35.280
Если их использовать внутри, как бы,

01:07:35.280 --> 01:07:37.280
других пишущих функций, они платные.

01:07:37.280 --> 01:07:39.280
А если вы снаружи, как бы, дергаетесь,

01:07:39.280 --> 01:07:41.280
то, пожалуйста, как бы, запрашивайте.

01:07:41.280 --> 01:07:43.280
На здоровье, как бы, они, ну,

01:07:43.280 --> 01:07:45.280
они открыты.

01:07:45.280 --> 01:07:47.280
Вот.

01:07:47.280 --> 01:07:49.280
Еще довольно важный, как бы,

01:07:49.280 --> 01:07:51.280
кусок контракта

01:07:51.280 --> 01:07:53.280
это так называемые ивенты.

01:07:53.280 --> 01:07:55.280
Это такие, как бы,

01:07:55.280 --> 01:07:57.280
события,

01:07:57.280 --> 01:07:59.280
такой, можно сказать, как бы, особый вид

01:07:59.280 --> 01:08:01.280
сториджа. Это, как бы, у нас будет

01:08:01.280 --> 01:08:03.280
называться сторидж.

01:08:03.280 --> 01:08:05.280
Грубо говоря,

01:08:05.280 --> 01:08:07.280
ивенты это лог,

01:08:07.280 --> 01:08:09.280
давайте я вот здесь, там, напишу, как бы,

01:08:09.280 --> 01:08:11.280
это лог событий

01:08:11.280 --> 01:08:13.280
контракта. То есть просто,

01:08:13.280 --> 01:08:15.280
как бы, он тоже фиксируется

01:08:15.280 --> 01:08:17.280
в блокчейне. То есть то, что у вас, как бы,

01:08:17.280 --> 01:08:19.280
произошло вот здесь, вот,

01:08:19.280 --> 01:08:21.280
emit, где у нас там.

01:08:21.280 --> 01:08:23.280
Вот здесь, по сути,

01:08:23.280 --> 01:08:25.280
вызывается ивент.

01:08:25.280 --> 01:08:27.280
Ну, там, в новых версиях Solidity, на самом деле,

01:08:27.280 --> 01:08:29.280
тут надо явно ключевое слово

01:08:29.280 --> 01:08:31.280
emit писать.

01:08:31.280 --> 01:08:33.280
Типа, произвести событие

01:08:33.280 --> 01:08:35.280
withdraw.

01:08:35.280 --> 01:08:37.280
То есть, вот этот чувак, msg sender,

01:08:37.280 --> 01:08:39.280
адрес отправителя,

01:08:39.280 --> 01:08:41.280
вывел столько-то

01:08:41.280 --> 01:08:43.280
вот этих вот вадов. Ну, там, вывел

01:08:43.280 --> 01:08:45.280
такое-то количество эфира, если все

01:08:45.280 --> 01:08:47.280
хорошо, если здесь нигде ничего не упало.

01:08:47.280 --> 01:08:49.280
Вот.

01:08:49.280 --> 01:08:51.280
То тогда в этом логе появится

01:08:51.280 --> 01:08:53.280
сообщение withdraw.

01:08:53.280 --> 01:08:55.280
Withdraw, там, адрес,

01:08:55.280 --> 01:08:57.280
там, не знаю, 100 токенов. Потом пришел другой

01:08:57.280 --> 01:08:59.280
чувак, сделал, там, депозит,

01:08:59.280 --> 01:09:01.280
там, A2, там, не знаю, там, 10.

01:09:01.280 --> 01:09:03.280
И так далее, и так далее.

01:09:03.280 --> 01:09:05.280
То есть это лог, который

01:09:05.280 --> 01:09:07.280
привязан к контракту.

01:09:07.280 --> 01:09:09.280
Вот здесь вот.

01:09:09.280 --> 01:09:11.280
И, ну, в чем, как бы, его

01:09:11.280 --> 01:09:13.280
важность? Во-первых, он

01:09:13.280 --> 01:09:15.280
дешевый. Вот.

01:09:15.280 --> 01:09:17.280
То есть он стоит дешевле, чем записать сюда

01:09:17.280 --> 01:09:19.280
то, что вот, короче, вот этот чувак,

01:09:19.280 --> 01:09:21.280
значит, положил 100 токенов, и это

01:09:21.280 --> 01:09:23.280
его, там, депозит. Понятно, что здесь

01:09:23.280 --> 01:09:25.280
значение, как бы, есть. Но

01:09:25.280 --> 01:09:27.280
писать в лог, во-первых, дешевле. По газу,

01:09:27.280 --> 01:09:29.280
там, 3000 плюс, там, количество

01:09:29.280 --> 01:09:31.280
за каждый байт данных придется

01:09:31.280 --> 01:09:33.280
заплатить. Во-вторых, из

01:09:33.280 --> 01:09:35.280
контракта сходить в лог нельзя.

01:09:35.280 --> 01:09:37.280
То есть контракт не может, как бы,

01:09:37.280 --> 01:09:39.280
сходить и посмотреть, какие события произошли

01:09:39.280 --> 01:09:41.280
вот в том контракте. Как бы, дай мне список,

01:09:41.280 --> 01:09:43.280
там, ивентов, что-то отфильтровать. То есть

01:09:43.280 --> 01:09:45.280
это такая, как бы, более, более тупое, как бы,

01:09:45.280 --> 01:09:47.280
хранилище, которое просто сохраняет,

01:09:47.280 --> 01:09:49.280
как бы, эти ивенты. Но они крайне удобные,

01:09:49.280 --> 01:09:51.280
для клиентов.

01:09:51.280 --> 01:09:53.280
То есть, когда я ходил вот сюда, там,

01:09:53.280 --> 01:09:55.280
на компаунд,

01:09:55.280 --> 01:09:57.280
на самом деле, когда я вам сказал, типа,

01:09:57.280 --> 01:09:59.280
я подписался, типа, на

01:09:59.280 --> 01:10:01.280
транзакцию, на самом деле,

01:10:01.280 --> 01:10:03.280
чуть-чуть я схитрил, потому что

01:10:03.280 --> 01:10:05.280
интерфейс подписался на

01:10:05.280 --> 01:10:07.280
события, коллатер был

01:10:07.280 --> 01:10:09.280
включен, или, там,

01:10:09.280 --> 01:10:11.280
типа, деньги были положены. Как бы, он

01:10:11.280 --> 01:10:13.280
подписался на вот это событие с

01:10:13.280 --> 01:10:15.280
моим адресом. То есть, он подписался,

01:10:15.280 --> 01:10:17.280
типа, и на попсабе висит

01:10:17.280 --> 01:10:19.280
и ждет, когда произойдет

01:10:19.280 --> 01:10:21.280
ивент, как бы, что

01:10:21.280 --> 01:10:23.280
вот этот вот чувак, как бы, сделал

01:10:23.280 --> 01:10:25.280
какой-то, там, не знаю, депозит.

01:10:25.280 --> 01:10:27.280
И, соответственно, он висит, как бы,

01:10:27.280 --> 01:10:29.280
с нодой общается, как бы, ждет, пока нода,

01:10:29.280 --> 01:10:31.280
как бы, ему пришлет апдейт. Да, такое событие

01:10:31.280 --> 01:10:33.280
произошло, вот этот ивент, как бы,

01:10:33.280 --> 01:10:35.280
и, соответственно, можно, там, не знаю, извести

01:10:35.280 --> 01:10:37.280
вот этот флажок. Поэтому

01:10:37.280 --> 01:10:39.280
ивенты — это крайне важная штука

01:10:39.280 --> 01:10:41.280
именно для, именно, взаимодействия

01:10:41.280 --> 01:10:43.280
с блокчейном. Чем

01:10:43.280 --> 01:10:45.280
еще они вам будут интересны,

01:10:45.280 --> 01:10:47.280
как бы, эти ивенты? Это, если вы собираетесь

01:10:47.280 --> 01:10:49.280
что-то там анализировать в блокчейне,

01:10:49.280 --> 01:10:51.280
собирать, там, типа, не знаю,

01:10:51.280 --> 01:10:53.280
инфу, короче, кто, какие,

01:10:53.280 --> 01:10:55.280
там, какие были, там, не знаю, там,

01:10:55.280 --> 01:10:57.280
сделки с этим токеном,

01:10:57.280 --> 01:10:59.280
кто ходил, как бы, в этот контракт, кто, там,

01:10:59.280 --> 01:11:01.280
не знаю, NFT-шки минтил и так далее.

01:11:01.280 --> 01:11:03.280
То есть вы, когда, как бы, парсите,

01:11:03.280 --> 01:11:05.280
парсите блокчейн, как бы,

01:11:05.280 --> 01:11:07.280
вы бежите по блокам, из этого

01:11:07.280 --> 01:11:09.280
блока получаете, по сути, пачку ивентов

01:11:09.280 --> 01:11:11.280
и фильтруете

01:11:11.280 --> 01:11:13.280
их.

01:11:17.280 --> 01:11:19.280
И фильтруете их, соответственно, по адресу контракта,

01:11:19.280 --> 01:11:21.280
по, там, по

01:11:21.280 --> 01:11:23.280
топикам и так далее. Тоже чуть-чуть посмотрим

01:11:23.280 --> 01:11:25.280
на этот код с вами, потому что

01:11:25.280 --> 01:11:27.280
с этим, если вы займетесь блокчейном, вам тоже

01:11:27.280 --> 01:11:29.280
придется работать.

01:11:29.280 --> 01:11:31.280
Вот, ивенты — такой источник информации.

01:11:31.280 --> 01:11:33.280
Так, поехали

01:11:33.280 --> 01:11:35.280
дальше.

01:11:35.280 --> 01:11:37.280
Тоже, что

01:11:37.280 --> 01:11:39.280
очень важно, как бы, что один

01:11:39.280 --> 01:11:41.280
контракт может вызывать другой

01:11:41.280 --> 01:11:43.280
контракт. То есть у нас есть, как бы,

01:11:43.280 --> 01:11:45.280
два контракта, AC-штрих

01:11:45.280 --> 01:11:47.280
какой-нибудь, там, 0, там,

01:11:47.280 --> 01:11:49.280
0 — неважно, у него тоже есть код.

01:11:49.280 --> 01:11:51.280
Здесь есть специальный

01:11:51.280 --> 01:11:53.280
апкод, специальная инструкция

01:11:53.280 --> 01:11:55.280
call, которая,

01:11:55.280 --> 01:11:57.280
как бы, может пойти

01:11:57.280 --> 01:11:59.280
в другой контракт, исполнить там

01:11:59.280 --> 01:12:01.280
функцию и, соответственно, вернуться обратно.

01:12:01.280 --> 01:12:03.280
То есть,

01:12:03.280 --> 01:12:05.280
опять же, когда вы

01:12:05.280 --> 01:12:07.280
строите что-то серьезное,

01:12:07.280 --> 01:12:09.280
то по большей части, как бы,

01:12:09.280 --> 01:12:11.280
ваша система представляет не один

01:12:11.280 --> 01:12:13.280
смарт-контракт, а много.

01:12:13.280 --> 01:12:15.280
И они отвечают, как бы, за разные вещи.

01:12:15.280 --> 01:12:17.280
То есть у вас есть какой-нибудь, там, базовый

01:12:17.280 --> 01:12:19.280
контроллер,

01:12:19.280 --> 01:12:21.280
здесь есть какой-нибудь, там,

01:12:21.280 --> 01:12:23.280
пришел пользователь, делает какой-нибудь, там,

01:12:23.280 --> 01:12:25.280
депозит, вносит вам 10

01:12:25.280 --> 01:12:27.280
эфира.

01:12:27.280 --> 01:12:29.280
На самом деле ваш контроллер, как бы, функцию

01:12:29.280 --> 01:12:31.280
депозит, там,

01:12:31.280 --> 01:12:33.280
исполняет, а 10 эфира

01:12:33.280 --> 01:12:35.280
кладет на адрес

01:12:35.280 --> 01:12:37.280
волта какого-нибудь, ну, то есть

01:12:37.280 --> 01:12:39.280
такой, как бы, крепости, как бы, на которой,

01:12:39.280 --> 01:12:41.280
как бы, хранится, там, не знаю, там, столько,

01:12:41.280 --> 01:12:43.280
как бы, эфира от пользователей.

01:12:43.280 --> 01:12:45.280
Контракт этот сильно простой, как бы, чтобы

01:12:45.280 --> 01:12:47.280
его не ломанули, чтобы не утащили, как бы,

01:12:47.280 --> 01:12:49.280
вот, весь эфир.

01:12:49.280 --> 01:12:51.280
Затем, там, не знаю, там, следующий, там,

01:12:51.280 --> 01:12:53.280
какой-нибудь контракт, в котором, там,

01:12:53.280 --> 01:12:55.280
например, там, access,

01:12:55.280 --> 01:12:57.280
access list,

01:12:57.280 --> 01:12:59.280
там, кто, там, админы,

01:12:59.280 --> 01:13:01.280
кто, там, команда,

01:13:01.280 --> 01:13:03.280
кто привилегированный пользователь, там,

01:13:03.280 --> 01:13:05.280
прописано, как бы, именно в этом контракте

01:13:05.280 --> 01:13:07.280
его сториджи, и контроллер, как бы,

01:13:07.280 --> 01:13:09.280
ходит сюда, типа, спрашивает, а вот этому

01:13:09.280 --> 01:13:11.280
можно сделать, там, какое-то административное

01:13:11.280 --> 01:13:13.280
действие, ну, в ответ, там,

01:13:13.280 --> 01:13:15.280
тоже при помощи вот этого

01:13:15.280 --> 01:13:17.280
кода и так далее.

01:13:17.280 --> 01:13:19.280
То есть, все современные проекты

01:13:19.280 --> 01:13:21.280
на, ну,

01:13:21.280 --> 01:13:23.280
на эфире, как бы, представляют собой

01:13:23.280 --> 01:13:25.280
целые пачки смарт-контрактов,

01:13:25.280 --> 01:13:27.280
которые между собой

01:13:27.280 --> 01:13:29.280
взаимодействуют. Давайте, там,

01:13:29.280 --> 01:13:31.280
что-нибудь

01:13:31.280 --> 01:13:33.280
посмотрим, там, мы будем

01:13:33.280 --> 01:13:35.280
подробно смотреть,

01:13:35.280 --> 01:13:37.280
ну, просто какую-нибудь репу.

01:13:39.280 --> 01:13:41.280
Вот, собственно, как раз такая

01:13:41.280 --> 01:13:43.280
достаточно простая, да, как бы,

01:13:43.280 --> 01:13:45.280
репа, через которую, не знаю,

01:13:45.280 --> 01:13:47.280
там, сотни миллиардов долларов прокачивается

01:13:47.280 --> 01:13:49.280
вот, как бы, ее все контракты,

01:13:49.280 --> 01:13:51.280
на самом деле, там, буквально, там,

01:13:51.280 --> 01:13:53.280
раз-два, как бы, и плюну.

01:13:53.280 --> 01:13:55.280
Один контракт, Factory,

01:13:55.280 --> 01:13:57.280
который, кстати говоря, это Pattern Factory,

01:13:57.280 --> 01:13:59.280
который в объектно-ориентированном программировании,

01:13:59.280 --> 01:14:01.280
когда один объект, как бы, печатает

01:14:01.280 --> 01:14:03.280
другие объекты однотипные,

01:14:03.280 --> 01:14:05.280
вот этот вот Factory, как бы,

01:14:05.280 --> 01:14:07.280
выкладывает в сеть, как бы,

01:14:07.280 --> 01:14:09.280
по желанию пользователя контракты

01:14:09.280 --> 01:14:11.280
V2Payer,

01:14:11.280 --> 01:14:13.280
вот, ну, и там, соответственно,

01:14:13.280 --> 01:14:15.280
там, при этом используется токен,

01:14:15.280 --> 01:14:17.280
вот, то есть, смарт-контрактов у нас

01:14:17.280 --> 01:14:19.280
на самом деле, всего-то, как бы,

01:14:19.280 --> 01:14:21.280
в общем-то, ничего. И вот, если вы

01:14:21.280 --> 01:14:23.280
посмотрите, да, кода здесь очень мало.

01:14:23.280 --> 01:14:25.280
То есть, это вам

01:14:25.280 --> 01:14:27.280
не backend, как бы,

01:14:27.280 --> 01:14:29.280
здесь кода достаточно мало,

01:14:29.280 --> 01:14:31.280
как бы, просто над каждой строчечкой

01:14:31.280 --> 01:14:33.280
придется подумать чуть-чуть больше.

01:14:33.280 --> 01:14:35.280
Вот.

01:14:35.280 --> 01:14:37.280
Так.

01:14:37.280 --> 01:14:39.280
Значит, это, что касается

01:14:39.280 --> 01:14:41.280
смарт-контрактов. Ну, и

01:14:41.280 --> 01:14:43.280
про Strictly Restricted by Execution Cost,

01:14:43.280 --> 01:14:45.280
про это мы уже с вами

01:14:45.280 --> 01:14:47.280
очень подробно в тот раз, как бы, поговорили.

01:14:47.280 --> 01:14:49.280
Ни одна функция вот этого контракта,

01:14:49.280 --> 01:14:51.280
этих контрактов, если мы вот здесь вот будем

01:14:51.280 --> 01:14:53.280
смотреть,

01:14:53.280 --> 01:14:55.280
вы здесь не найдете нигде,

01:14:55.280 --> 01:14:57.280
например, циклов,

01:14:57.280 --> 01:14:59.280
если эти циклы

01:14:59.280 --> 01:15:01.280
не прям жестко, там, прибиты сверху,

01:15:01.280 --> 01:15:03.280
там, чуть ли не константами.

01:15:03.280 --> 01:15:05.280
То есть, там, не знаю, там,

01:15:05.280 --> 01:15:07.280
for1, to, короче, не знаю, там,

01:15:07.280 --> 01:15:09.280
максимум, там, десяток, как бы,

01:15:09.280 --> 01:15:11.280
какой-нибудь, там, сущностей. То есть,

01:15:11.280 --> 01:15:13.280
если вы посмотрите, они все прям линейные, линейные,

01:15:13.280 --> 01:15:15.280
линейные эти функции,

01:15:15.280 --> 01:15:17.280
максимально экономящие

01:15:17.280 --> 01:15:19.280
место. Ну, то есть, например, там, в Uniswap'е

01:15:19.280 --> 01:15:21.280
время

01:15:21.280 --> 01:15:23.280
приводится к 32

01:15:23.280 --> 01:15:25.280
битам просто для того, чтобы сэкономить,

01:15:25.280 --> 01:15:27.280
как бы, 32 бита.

01:15:27.280 --> 01:15:29.280
Таймстемп 64 бита,

01:15:29.280 --> 01:15:31.280
как бы, а здесь, как бы, 32,

01:15:31.280 --> 01:15:33.280
потому что надо пожать,

01:15:33.280 --> 01:15:35.280
чтобы данные более эффективно

01:15:35.280 --> 01:15:37.280
упаковались, там, в слоты. То есть, экономия

01:15:37.280 --> 01:15:39.280
идет на таких, на спичках,

01:15:39.280 --> 01:15:41.280
и ее здесь очень много.

01:15:41.280 --> 01:15:43.280
Потому что

01:15:43.280 --> 01:15:45.280
каждый раз, когда вы вот здесь вот, как бы,

01:15:45.280 --> 01:15:47.280
пробуете что-то неоптимально,

01:15:47.280 --> 01:15:49.280
то есть, вы запрограммировали, не знаю,

01:15:49.280 --> 01:15:51.280
там, цикл, который жрет зря,

01:15:51.280 --> 01:15:53.280
как бы, газ, вы какую-то функцию выполняете

01:15:53.280 --> 01:15:55.280
больше, чем нужно,

01:15:55.280 --> 01:15:57.280
больше, чем, там, один раз

01:15:57.280 --> 01:15:59.280
за блок, платят за это ваши

01:15:59.280 --> 01:16:01.280
пользователи. То есть, приходит

01:16:01.280 --> 01:16:03.280
пользователь, отправляет транзакцию в

01:16:03.280 --> 01:16:05.280
контракт, исполняет ваш код, как бы,

01:16:05.280 --> 01:16:07.280
ваш код неоптимальный, как бы, и жрет,

01:16:07.280 --> 01:16:09.280
там, 100 тысяч газа вместо, там,

01:16:09.280 --> 01:16:11.280
60 тысяч газа, и пользователь платит

01:16:11.280 --> 01:16:13.280
100 долларов вместо 60 долларов.

01:16:13.280 --> 01:16:15.280
Именно поэтому,

01:16:15.280 --> 01:16:17.280
собственно, и спрос, как бы, такой, с блок

01:16:17.280 --> 01:16:19.280
чейн разработчиков очень серьезный

01:16:19.280 --> 01:16:21.280
в плане, как бы, алгоритмов и структур данных.

01:16:21.280 --> 01:16:23.280
То есть, если, как бы,

01:16:23.280 --> 01:16:25.280
да, ну, как бы,

01:16:25.280 --> 01:16:27.280
если ты, там, не знаю, там,

01:16:27.280 --> 01:16:29.280
не понимаешь, как бы, там, сложности алгоритмов

01:16:29.280 --> 01:16:31.280
или просто, как бы, там, не знаю, прям

01:16:31.280 --> 01:16:33.280
в лобешник, как бы, решаешь, типа, задачу,

01:16:33.280 --> 01:16:35.280
а, да, все, прям, запихали

01:16:35.280 --> 01:16:37.280
в массив, пробежали, сортирнули,

01:16:37.280 --> 01:16:39.280
как бы, и потом, и взяли, там,

01:16:39.280 --> 01:16:41.280
верхнее число, то, в общем,

01:16:41.280 --> 01:16:43.280
на солидите лучше, как бы, не идти программировать,

01:16:43.280 --> 01:16:45.280
вот, потому что здесь, прям,

01:16:45.280 --> 01:16:47.280
об этом надо думать на каждой строчке.

01:16:47.280 --> 01:16:49.280
Это очень серьезно.

01:16:49.280 --> 01:16:51.280
Вот. Активные

01:16:51.280 --> 01:16:53.280
используются всякие, там, не знаю, там,

01:16:53.280 --> 01:16:55.280
может быть, кэширование,

01:16:55.280 --> 01:16:57.280
надо при этом, как бы, понимать,

01:16:57.280 --> 01:16:59.280
какая транзакция,

01:16:59.280 --> 01:17:01.280
куда, ну, какая пишет

01:17:01.280 --> 01:17:03.280
сторч, какая пишет память,

01:17:03.280 --> 01:17:05.280
какая потребляет, как бы, соответственно, сколько,

01:17:05.280 --> 01:17:07.280
сколько газа, это, вот, довольно

01:17:07.280 --> 01:17:09.280
серьезная история в солидите

01:17:09.280 --> 01:17:11.280
разработке.

01:17:13.280 --> 01:17:15.280
Дальше, что еще интересно,

01:17:15.280 --> 01:17:17.280
как бы, такое рассказать про смарт-контрол,

01:17:17.280 --> 01:17:19.280
про контракты, ну, в частности,

01:17:19.280 --> 01:17:21.280
например,

01:17:21.280 --> 01:17:23.280
здесь

01:17:23.280 --> 01:17:25.280
различных хитрых математических

01:17:25.280 --> 01:17:27.280
функций, их довольно-таки

01:17:27.280 --> 01:17:29.280
мало, потому

01:17:29.280 --> 01:17:31.280
что, как я сказал, как бы, все

01:17:31.280 --> 01:17:33.280
операции, они

01:17:33.280 --> 01:17:35.280
целочисленные, вот, и поэтому

01:17:35.280 --> 01:17:37.280
практически с любой экзотикой,

01:17:37.280 --> 01:17:39.280
которая у вас появится, например,

01:17:39.280 --> 01:17:41.280
даже квадратный корень, как бы,

01:17:41.280 --> 01:17:43.280
является экзотикой, как бы, вам придется

01:17:43.280 --> 01:17:45.280
разбираться самостоятельно.

01:17:45.280 --> 01:17:47.280
А из-за жестких требований,

01:17:47.280 --> 01:17:49.280
там, к битности, к экономии,

01:17:49.280 --> 01:17:51.280
зачастую

01:17:51.280 --> 01:17:53.280
многие виды, как бы,

01:17:53.280 --> 01:17:55.280
математики приходится

01:17:55.280 --> 01:17:57.280
реализовывать самостоятельно.

01:17:57.280 --> 01:17:59.280
Вот, например, здесь, как видите, как бы,

01:17:59.280 --> 01:18:01.280
квадратный корень, квадратный корень,

01:18:01.280 --> 01:18:03.280
как бы, сделан вручную.

01:18:03.280 --> 01:18:05.280
Нету в солидите, нету, как бы,

01:18:05.280 --> 01:18:07.280
апкода квадратный корень.

01:18:07.280 --> 01:18:09.280
Вот, вам придется его, как бы, реализовать

01:18:09.280 --> 01:18:11.280
самостоятельно, здесь этот вавилонский

01:18:11.280 --> 01:18:13.280
метод используется. И то же самое

01:18:13.280 --> 01:18:15.280
касается большинства математических

01:18:15.280 --> 01:18:17.280
функций.

01:18:17.280 --> 01:18:19.280
Собственно,

01:18:19.280 --> 01:18:21.280
даже для, там, операций,

01:18:21.280 --> 01:18:23.280
там, перемножения, как бы, балансов

01:18:23.280 --> 01:18:25.280
здесь используется своя собственная

01:18:25.280 --> 01:18:27.280
математика,

01:18:27.280 --> 01:18:29.280
вот, для того, чтобы

01:18:29.280 --> 01:18:31.280
это влазило. Почему здесь 100-112

01:18:31.280 --> 01:18:33.280
бит, например, у них используется?

01:18:33.280 --> 01:18:35.280
Чтобы 112 бит

01:18:35.280 --> 01:18:37.280
умножить на 112 бит дало

01:18:37.280 --> 01:18:39.280
224 бита,

01:18:39.280 --> 01:18:41.280
и плюс к этим

01:18:41.280 --> 01:18:43.280
224 битам добавить

01:18:43.280 --> 01:18:45.280
еще 32 бита

01:18:45.280 --> 01:18:47.280
вот того таймстемпа, вот этого времени,

01:18:47.280 --> 01:18:49.280
которое было в пэре. И получится, как раз,

01:18:49.280 --> 01:18:51.280
256 бит, который можно затолкать

01:18:51.280 --> 01:18:53.280
в...

01:18:53.280 --> 01:18:55.280
который можно затолкать ровно

01:18:55.280 --> 01:18:57.280
в один слот

01:18:57.280 --> 01:18:59.280
сториджа. Он, у него размер, как бы,

01:18:59.280 --> 01:19:01.280
256 бит, и у него здесь будет, как бы,

01:19:01.280 --> 01:19:03.280
один баланс, здесь будет второй баланс, а здесь

01:19:03.280 --> 01:19:05.280
будет время. И получится, вот, ровно

01:19:05.280 --> 01:19:07.280
256 бит. Это, вот, с точки зрения

01:19:07.280 --> 01:19:09.280
потребления газа, крайне,

01:19:09.280 --> 01:19:11.280
ну,

01:19:11.280 --> 01:19:13.280
оптимально. Потому что пользователь платит

01:19:13.280 --> 01:19:15.280
за каждый выделенный, вот,

01:19:15.280 --> 01:19:17.280
этот вот слот, как бы, 256 бит.

01:19:17.280 --> 01:19:19.280
То есть, с чего

01:19:19.280 --> 01:19:21.280
я, как бы, вдруг приплевывал

01:19:21.280 --> 01:19:23.280
операционные системы, как бы, к блокчейнам, да?

01:19:23.280 --> 01:19:25.280
А потому что, вообще, как бы,

01:19:25.280 --> 01:19:27.280
всякая, там, страничная

01:19:27.280 --> 01:19:29.280
организация памяти, да, когда вам нужно

01:19:29.280 --> 01:19:31.280
на одну переменную выделить 4 байта,

01:19:31.280 --> 01:19:33.280
а операционка вам, на

01:19:33.280 --> 01:19:35.280
самом деле, как бы, выделяет сразу целиком

01:19:35.280 --> 01:19:37.280
страницу размером 4 килобайта,

01:19:37.280 --> 01:19:39.280
да еще и делает это

01:19:39.280 --> 01:19:41.280
лениво, то есть она отображает это на физическую

01:19:41.280 --> 01:19:43.280
память, там, и там, и так

01:19:43.280 --> 01:19:45.280
далее, соответственно, и

01:19:45.280 --> 01:19:47.280
инициализирует ее только, когда вы

01:19:47.280 --> 01:19:49.280
делаете запись в эту штуку. Вот понимание

01:19:49.280 --> 01:19:51.280
этих механизмов, на самом деле, делает

01:19:51.280 --> 01:19:53.280
понимание того, что здесь происходит

01:19:53.280 --> 01:19:55.280
за смарт-контрактами, прям, очень простым.

01:19:55.280 --> 01:19:57.280
То есть, потому что это все, в общем-то,

01:19:57.280 --> 01:19:59.280
как бы, одно и то же, как бы, единственно

01:19:59.280 --> 01:20:01.280
только, ну, сдобренное

01:20:01.280 --> 01:20:03.280
key-value вот этими,

01:20:03.280 --> 01:20:05.280
как бы, хэшами.

01:20:05.280 --> 01:20:07.280
Вот. Так.

01:20:07.280 --> 01:20:09.280
Теперь, значит,

01:20:09.280 --> 01:20:11.280
про

01:20:11.280 --> 01:20:13.280
ограничения, getter и setter,

01:20:13.280 --> 01:20:15.280
значит,

01:20:15.280 --> 01:20:17.280
вызовы контрактов, контракты

01:20:17.280 --> 01:20:19.280
мы прям будем тоже очень подробно смотреть.

01:20:19.280 --> 01:20:21.280
Здесь очень много всяких, как бы, нюансов

01:20:21.280 --> 01:20:23.280
есть. Вот.

01:20:23.280 --> 01:20:25.280
Теперь чуть-чуть

01:20:25.280 --> 01:20:27.280
продолжим, как бы, про газ.

01:20:27.280 --> 01:20:29.280
Я уже вам в тот раз, как бы, рассказал

01:20:29.280 --> 01:20:31.280
про то, что каждая инструкция стоит, там,

01:20:31.280 --> 01:20:33.280
сколько-то денег. Вот.

01:20:33.280 --> 01:20:35.280
Соответственно,

01:20:35.280 --> 01:20:37.280
вот мы поговорили про газ.

01:20:37.280 --> 01:20:39.280
И

01:20:39.280 --> 01:20:41.280
теперь чуть-чуть поглубже, соответственно,

01:20:41.280 --> 01:20:43.280
что внутри, под капотом у этих

01:20:43.280 --> 01:20:45.280
смарт-контрактов происходит и как работает

01:20:45.280 --> 01:20:47.280
EVM. То есть это вот сейчас, наверное,

01:20:47.280 --> 01:20:49.280
там,

01:20:49.280 --> 01:20:51.280
основная история.

01:20:51.280 --> 01:20:53.280
Значит, как я говорил,

01:20:53.280 --> 01:20:55.280
EVM — это, по сути,

01:20:55.280 --> 01:20:57.280
микроконтроллер, можно сказать.

01:20:57.280 --> 01:20:59.280
Те, кто у вас, как бы, такой, как бы, виртуальный

01:20:59.280 --> 01:21:01.280
процессор, просто сделан, как бы, в софте.

01:21:01.280 --> 01:21:03.280
Вот. Там в софте есть объект,

01:21:03.280 --> 01:21:05.280
как бы, у которого есть, как бы, свой

01:21:05.280 --> 01:21:07.280
собственный, там, storage, у которого есть собственный,

01:21:07.280 --> 01:21:09.280
там, не знаю, там, код.

01:21:09.280 --> 01:21:11.280
Кстати,

01:21:11.280 --> 01:21:13.280
на микроконтроллерах или ассемблере

01:21:13.280 --> 01:21:15.280
многие писали, тоже, кстати,

01:21:15.280 --> 01:21:17.280
интересный вопрос.

01:21:17.280 --> 01:21:19.280
Ну, на ассемблере писали,

01:21:19.280 --> 01:21:21.280
на курсе C++.

01:21:21.280 --> 01:21:23.280
Ага.

01:21:23.280 --> 01:21:25.280
Ну, это, кстати,

01:21:25.280 --> 01:21:27.280
кстати, вот тот случай, да,

01:21:27.280 --> 01:21:29.280
когда, вот, кажется, да, в институте, что

01:21:29.280 --> 01:21:31.280
и когда мне это, блин,

01:21:31.280 --> 01:21:33.280
пригодится, я

01:21:33.280 --> 01:21:35.280
тут эти самые сайты на Django делаю,

01:21:35.280 --> 01:21:37.280
как бы, а вы какой-то микроконтроллер,

01:21:37.280 --> 01:21:39.280
какие-то ассемблеры, хрен его знает, куда это мне надо.

01:21:39.280 --> 01:21:41.280
Здесь это довольно

01:21:41.280 --> 01:21:43.280
важная история в блокчейнах,

01:21:43.280 --> 01:21:45.280
как бы, причем, кстати,

01:21:45.280 --> 01:21:47.280
реально во всех. То есть это достаточно

01:21:47.280 --> 01:21:49.280
полезные знания, вот,

01:21:49.280 --> 01:21:51.280
того, как работает, как работает, собственно,

01:21:51.280 --> 01:21:53.280
сам микропроцессор, потому что именно так

01:21:53.280 --> 01:21:55.280
работает виртуальная машина.

01:21:55.280 --> 01:21:57.280
Даже при изучении C++

01:21:57.280 --> 01:21:59.280
полезно, чтобы понимать, когда

01:21:59.280 --> 01:22:01.280
компилируется, как.

01:22:01.280 --> 01:22:03.280
Да, да, да, да, именно, как выделяется память,

01:22:03.280 --> 01:22:05.280
там, и так далее. Ну, я могу сказать,

01:22:05.280 --> 01:22:07.280
по моему, как бы, рабочему опыту,

01:22:07.280 --> 01:22:09.280
даже если вот эти теоретические знания

01:22:09.280 --> 01:22:11.280
из института о низком уровне, там,

01:22:11.280 --> 01:22:13.280
всякие, там, параллельные программирования,

01:22:13.280 --> 01:22:15.280
архитектуры, там, систем, там, и так далее.

01:22:15.280 --> 01:22:17.280
То есть, если они, как бы, по жизни

01:22:17.280 --> 01:22:19.280
и не пригождались, да, там, суперкомпьютеры,

01:22:19.280 --> 01:22:21.280
там, я не программировал, да, как бы,

01:22:21.280 --> 01:22:23.280
и, там, микроконтроллеры для роботов,

01:22:23.280 --> 01:22:25.280
то, когда ты начинаешь решать

01:22:25.280 --> 01:22:27.280
проблемы, например, в какой-то сложной

01:22:27.280 --> 01:22:29.280
системе, там, высоко нагруженной,

01:22:29.280 --> 01:22:31.280
там, не знаю, предположим,

01:22:31.280 --> 01:22:33.280
предполагаешь, почему, как бы, вот, на этой

01:22:33.280 --> 01:22:35.280
системе вдруг процессор, как бы, начал

01:22:35.280 --> 01:22:37.280
прям, как ни в коня, жрать.

01:22:37.280 --> 01:22:39.280
Или, там, почему память утекла, и так далее.

01:22:39.280 --> 01:22:41.280
То тут, как раз, эти знания здорово

01:22:41.280 --> 01:22:43.280
помогают. Потому что ты вспоминаешь,

01:22:43.280 --> 01:22:45.280
а, блин, мы же здесь вот добавили, как бы,

01:22:45.280 --> 01:22:47.280
вот, вычисления, такое, как бы,

01:22:47.280 --> 01:22:49.280
блин, и, может быть, не оптимально, как бы,

01:22:49.280 --> 01:22:51.280
оно жрет процессор, как бы, по ходу дела в нем.

01:22:51.280 --> 01:22:53.280
Вот. То есть, оно помогает, на самом деле,

01:22:53.280 --> 01:22:55.280
копать и находить проблемы.

01:22:55.280 --> 01:22:57.280
Вот.

01:22:57.280 --> 01:22:59.280
Ну, и тоже, как,

01:22:59.280 --> 01:23:01.280
так, в качестве философского, как бы,

01:23:01.280 --> 01:23:03.280
напутствия, да, как бы,

01:23:03.280 --> 01:23:05.280
написать систему, которая работает, несложно.

01:23:05.280 --> 01:23:07.280
Вот. Но,

01:23:07.280 --> 01:23:09.280
как бы, в тот момент, когда начнутся

01:23:09.280 --> 01:23:11.280
проблемы, когда эта система, как бы, подойдет,

01:23:11.280 --> 01:23:13.280
как бы, к пику своих

01:23:13.280 --> 01:23:15.280
возможностей на текущих машинах,

01:23:15.280 --> 01:23:17.280
то есть, когда перестанет хватать сервировка, да,

01:23:17.280 --> 01:23:19.280
они станут, как бы, уходить, там,

01:23:19.280 --> 01:23:21.280
в 100%, когда начнутся проблемы,

01:23:21.280 --> 01:23:23.280
вот, с производительностью, вот, в этот момент,

01:23:23.280 --> 01:23:25.280
как бы, прям, вот это

01:23:25.280 --> 01:23:27.280
непонимание низкоуровневых

01:23:27.280 --> 01:23:29.280
механизмов, оно прям вернется

01:23:29.280 --> 01:23:31.280
сразу же, как бы, сторицей, потому что

01:23:31.280 --> 01:23:33.280
придется очень долго, как бы, колупаться,

01:23:33.280 --> 01:23:35.280
что там упало, почему, как бы,

01:23:35.280 --> 01:23:37.280
что мы там такого сделали, как бы,

01:23:37.280 --> 01:23:39.280
и так далее. То есть, вот это вот

01:23:39.280 --> 01:23:41.280
эффективная утилизация, как бы, железа

01:23:41.280 --> 01:23:43.280
штука важная. И если вы собираетесь

01:23:43.280 --> 01:23:45.280
в крупную компанию, как бы, идти,

01:23:45.280 --> 01:23:47.280
то там, возможно, как бы,

01:23:47.280 --> 01:23:49.280
оптимизация пары строчек

01:23:49.280 --> 01:23:51.280
кода может спасти компании, там, не знаю,

01:23:51.280 --> 01:23:53.280
миллион долларов в месяц, спокойно,

01:23:53.280 --> 01:23:55.280
на серверах, просто потому что они перестанут,

01:23:55.280 --> 01:23:57.280
их не нужно будет такого количества.

01:23:57.280 --> 01:23:59.280
Так что это важно.

01:23:59.280 --> 01:24:01.280
Вот. Значит,

01:24:01.280 --> 01:24:03.280
итак, EVM у нас представляет

01:24:03.280 --> 01:24:05.280
собой такой, как бы, процессор,

01:24:05.280 --> 01:24:07.280
мы бежим, как бы, по инструкциям,

01:24:07.280 --> 01:24:09.280
у него есть

01:24:09.280 --> 01:24:11.280
instruction pointer,

01:24:11.280 --> 01:24:13.280
который говорит, на какой я сейчас

01:24:13.280 --> 01:24:15.280
инструкции нахожусь,

01:24:15.280 --> 01:24:17.280
у него есть, соответственно, память,

01:24:17.280 --> 01:24:19.280
если эта инструкция делает какой-нибудь

01:24:19.280 --> 01:24:21.280
M-load, там, не знаю, там,

01:24:21.280 --> 01:24:23.280
загружать какие-то данные с памяти,

01:24:23.280 --> 01:24:25.280
то процессор, как бы, сходит по вот этому адресу

01:24:25.280 --> 01:24:27.280
в оперативную память, возьмет данные,

01:24:27.280 --> 01:24:29.280
загрузит их куда-то там

01:24:29.280 --> 01:24:31.280
в регистр, у него есть

01:24:31.280 --> 01:24:33.280
stack,

01:24:33.280 --> 01:24:35.280
ну, вот это, соответственно, memory называется,

01:24:35.280 --> 01:24:37.280
у него есть обязательно stack,

01:24:37.280 --> 01:24:39.280
значит,

01:24:39.280 --> 01:24:41.280
как stack работает, тоже, как бы, надо знать,

01:24:41.280 --> 01:24:43.280
да, всякие, надеюсь, как бы, все знают,

01:24:43.280 --> 01:24:45.280
это push-pop,

01:24:45.280 --> 01:24:47.280
да, то есть положили на stack что-то,

01:24:47.280 --> 01:24:49.280
оно, как бы, попало вот сюда,

01:24:49.280 --> 01:24:51.280
мы сделали push,

01:24:51.280 --> 01:24:53.280
и stack pointer,

01:24:53.280 --> 01:24:55.280
то есть указательно переместился

01:24:55.280 --> 01:24:57.280
вверх, как бы, еще сделали

01:24:57.280 --> 01:24:59.280
push, как бы, он еще вверх поместился,

01:24:59.280 --> 01:25:01.280
сделали pop, как бы, мы

01:25:01.280 --> 01:25:03.280
вернулись вниз, как бы, про вот эти вот забыли

01:25:03.280 --> 01:25:05.280
данные.

01:25:05.280 --> 01:25:07.280
Чем stack, как бы, удобен, да, тем, что

01:25:07.280 --> 01:25:09.280
для того, чтобы, как бы, следить за stack-ом, нам

01:25:09.280 --> 01:25:11.280
достаточно хранить одно число, вот это вот,

01:25:11.280 --> 01:25:13.280
stack pointer, и все, как бы,

01:25:13.280 --> 01:25:15.280
то есть и тогда у нас вот эти все push и pop

01:25:15.280 --> 01:25:17.280
как бы прекрасно работают.

01:25:17.280 --> 01:25:19.280
Соответственно, она

01:25:19.280 --> 01:25:21.280
бежит по инструкциям последовательно,

01:25:21.280 --> 01:25:23.280
исполняет, как бы, каждую инструкцию,

01:25:23.280 --> 01:25:25.280
вот, и, как бы,

01:25:25.280 --> 01:25:27.280
до тех пор, пока, как бы, не наткнется,

01:25:27.280 --> 01:25:29.280
типа, на все там, типа, окей, я

01:25:29.280 --> 01:25:31.280
закончила.

01:25:31.280 --> 01:25:33.280
При этом, как мы с вами в тот раз, как бы,

01:25:33.280 --> 01:25:35.280
выяснили, она каждый раз добавляет

01:25:35.280 --> 01:25:37.280
сколько было

01:25:37.280 --> 01:25:39.280
потрачено на данную инструкцию

01:25:39.280 --> 01:25:41.280
газа, то есть у нас

01:25:41.280 --> 01:25:43.280
есть специальные, как бы, цены, как бы,

01:25:43.280 --> 01:25:45.280
на вот этот вот газ,

01:25:45.280 --> 01:25:47.280
вот, и если

01:25:47.280 --> 01:25:49.280
этот газ, газ,

01:25:49.280 --> 01:25:51.280
газ,

01:25:51.280 --> 01:25:53.280
становится больше определенного лимита,

01:25:53.280 --> 01:25:55.280
какого-то там серьезного, не знаю, там,

01:25:55.280 --> 01:25:57.280
10 миллионов газа, например, там,

01:25:57.280 --> 01:25:59.280
то делается реверт,

01:26:01.280 --> 01:26:03.280
то есть все откатывается,

01:26:03.280 --> 01:26:05.280
и, как бы,

01:26:05.280 --> 01:26:07.280
транзакция падает с

01:26:07.280 --> 01:26:09.280
сообщением out of gas, но при этом

01:26:09.280 --> 01:26:11.280
включается в блок, как бы, и вам придется,

01:26:11.280 --> 01:26:13.280
как бы, заплатить за это. Лимит

01:26:13.280 --> 01:26:15.280
этот указывает пользователь, то есть вы

01:26:15.280 --> 01:26:17.280
в своей транзакции говорите, я готов

01:26:17.280 --> 01:26:19.280
потратить не больше, чем там

01:26:19.280 --> 01:26:21.280
100, чем 100 тысяч газа,

01:26:21.280 --> 01:26:23.280
как бы, то есть это, в принципе, на совести

01:26:23.280 --> 01:26:25.280
пользователя.

01:26:25.280 --> 01:26:27.280
Вот. Чисто технически, если я укажу

01:26:27.280 --> 01:26:29.280
бесконечный лимит, ну, у меня программа, как бы,

01:26:29.280 --> 01:26:31.280
будет крутиться, пока не доберется

01:26:31.280 --> 01:26:33.280
до, так называемого, hard, hard

01:26:33.280 --> 01:26:35.280
лимита. Значит,

01:26:35.280 --> 01:26:37.280
как это все дело выглядит?

01:26:37.280 --> 01:26:39.280
Вообще, если мы будем строить

01:26:39.280 --> 01:26:41.280
блокчейны, да, и нам нужна

01:26:41.280 --> 01:26:43.280
будет вот именно вот эта вот механика,

01:26:43.280 --> 01:26:45.280
она во всех блокчейнах на самом деле

01:26:45.280 --> 01:26:47.280
присутствует, то есть где-то там по-другому

01:26:47.280 --> 01:26:49.280
чуть-чуть считается, как бы, вот эти вот

01:26:49.280 --> 01:26:51.280
попугаи, то есть сколько вы потратили

01:26:51.280 --> 01:26:53.280
вычислительных ресурсов, но там, где они считаются,

01:26:53.280 --> 01:26:55.280
как бы, это не блокчейны.

01:26:55.280 --> 01:26:57.280
Вот. Блокчейны, как раз, только там,

01:26:57.280 --> 01:26:59.280
где это считается, как бы,

01:26:59.280 --> 01:27:01.280
и смарт-контракты.

01:27:01.280 --> 01:27:03.280
Мы бежим. В принципе, можно построить

01:27:03.280 --> 01:27:05.280
несколькими способами. Значит,

01:27:05.280 --> 01:27:07.280
первое — это написать свою собственную

01:27:07.280 --> 01:27:09.280
виртуальную машину, что и сделал Эфир.

01:27:09.280 --> 01:27:11.280
Они написали, как бы, EVM, вот здесь

01:27:11.280 --> 01:27:13.280
всякие, можно даже посмотреть примеры

01:27:13.280 --> 01:27:15.280
инструкций,

01:27:15.280 --> 01:27:17.280
там, не знаю, там, проверка является

01:27:17.280 --> 01:27:19.280
то, что она лежит на стейке нулем.

01:27:19.280 --> 01:27:21.280
Затем, если является,

01:27:21.280 --> 01:27:23.280
то условный переход, там, туда-то,

01:27:23.280 --> 01:27:25.280
туда-то, вот на вот это вот AE,

01:27:25.280 --> 01:27:27.280
значит, куда-то.

01:27:27.280 --> 01:27:29.280
— Какой уровень выполняет стэк?

01:27:29.280 --> 01:27:31.280
Это стэковые машины?

01:27:31.280 --> 01:27:33.280
— Да.

01:27:33.280 --> 01:27:35.280
Вот. Я

01:27:35.280 --> 01:27:37.280
прям про стэк сейчас,

01:27:37.280 --> 01:27:39.280
ну, я сейчас прям подробно расскажу.

01:27:39.280 --> 01:27:41.280
Потому что здесь есть

01:27:41.280 --> 01:27:43.280
серьезные отличия.

01:27:43.280 --> 01:27:45.280
Это значит написать свою

01:27:45.280 --> 01:27:47.280
виртуальную машину. Второй

01:27:47.280 --> 01:27:49.280
подход, как бы, который, на самом деле,

01:27:49.280 --> 01:27:51.280
к которому идет прям очень широкая работа,

01:27:51.280 --> 01:27:53.280
как бы, — это использовать WebAssembly.

01:27:53.280 --> 01:27:55.280
WebAssembly — это

01:27:55.280 --> 01:27:57.280
наш новый с вами, короче,

01:27:57.280 --> 01:27:59.280
JavaScript,

01:27:59.280 --> 01:28:01.280
такой, когда у вас есть браузер,

01:28:01.280 --> 01:28:03.280
и вам здесь надо, там, 3D-модель нарисовать,

01:28:03.280 --> 01:28:05.280
как бы, и крутить ее, и сделать это на

01:28:05.280 --> 01:28:07.280
JS, как бы. Вы когда попробуете

01:28:07.280 --> 01:28:09.280
сделать на JS, как бы, вы офигеете,

01:28:09.280 --> 01:28:11.280
как бы, какая у вас будет производительность,

01:28:11.280 --> 01:28:13.280
вряд ли у вас это получится.

01:28:13.280 --> 01:28:15.280
И для этого появился стандарт

01:28:15.280 --> 01:28:17.280
WebAssembly, который позволяет вам

01:28:17.280 --> 01:28:19.280
написать программу, как бы, на

01:28:19.280 --> 01:28:21.280
таком ассемблере. Вот он

01:28:21.280 --> 01:28:23.280
вот так вот приблизительно выглядит.

01:28:23.280 --> 01:28:25.280
И просто

01:28:25.280 --> 01:28:27.280
прямо на JS-кой странице, типа,

01:28:27.280 --> 01:28:29.280
сказать, там, JS, там, не знаю, там,

01:28:29.280 --> 01:28:31.280
compile, там, что-нибудь там,

01:28:31.280 --> 01:28:33.280
JS, там, .exec, вот этот вот

01:28:33.280 --> 01:28:35.280
ассемблерный код. И в браузер

01:28:35.280 --> 01:28:37.280
встроена виртуальная машина,

01:28:37.280 --> 01:28:39.280
которая исполняет вот этот WASM,

01:28:39.280 --> 01:28:41.280
и она делает это, там, в тысячу раз быстрее,

01:28:41.280 --> 01:28:43.280
чем это делать на QNAME или каким-нибудь

01:28:43.280 --> 01:28:45.280
при помощи JS-а.

01:28:45.280 --> 01:28:47.280
Пробрасывает прямо в процессор инструкции,

01:28:47.280 --> 01:28:49.280
там, и так далее. То есть

01:28:49.280 --> 01:28:51.280
эта штука в тысячу раз быстрее, чем

01:28:51.280 --> 01:28:53.280
такой, как бы,

01:28:53.280 --> 01:28:55.280
JavaScript на стероидах, как бы,

01:28:55.280 --> 01:28:57.280
ассемблерный. Тоже очень

01:28:57.280 --> 01:28:59.280
популярная, как бы, штука.

01:28:59.280 --> 01:29:01.280
И, конечно, хотелось бы, да,

01:29:01.280 --> 01:29:03.280
писать смарт-контракты именно

01:29:03.280 --> 01:29:05.280
на WebAssembly. Тем более, как бы,

01:29:05.280 --> 01:29:07.280
WebAssembly

01:29:07.280 --> 01:29:09.280
у него есть компиляторы,

01:29:09.280 --> 01:29:11.280
компиляторы, которые

01:29:11.280 --> 01:29:13.280
компилируют вот этот вот WASM

01:29:13.280 --> 01:29:15.280
в WebAssembly

01:29:15.280 --> 01:29:17.280
прямо там, ну, что хотите, хотите, там,

01:29:17.280 --> 01:29:19.280
Python, JS, короче говоря,

01:29:19.280 --> 01:29:21.280
там, Rust,

01:29:21.280 --> 01:29:23.280
и так далее, там, не знаю, там, C,

01:29:23.280 --> 01:29:25.280
C++. Все это, как бы, можно просто

01:29:25.280 --> 01:29:27.280
компилировать именно как раз

01:29:27.280 --> 01:29:29.280
в WebAssembly, и он будет исполняться в браузере

01:29:29.280 --> 01:29:31.280
со всеми

01:29:31.280 --> 01:29:33.280
штуками. Но у нас, конечно,

01:29:33.280 --> 01:29:35.280
на WebAssembly в блокчейнах,

01:29:37.280 --> 01:29:39.280
как я говорил, как бы, накладываются

01:29:39.280 --> 01:29:41.280
требования по детерминизму,

01:29:41.280 --> 01:29:43.280
поэтому у вас вот этот WebAssembly

01:29:43.280 --> 01:29:45.280
в чистом виде, вот как в WebStore

01:29:45.280 --> 01:29:47.280
стандарт, как бы, он не используется

01:29:47.280 --> 01:29:49.280
в блокчейнах, потому что у него внутри

01:29:49.280 --> 01:29:51.280
здесь может быть, как бы, какой-то рандом,

01:29:51.280 --> 01:29:53.280
у него там есть

01:29:53.280 --> 01:29:55.280
получение текущего времени

01:29:55.280 --> 01:29:57.280
внутри этого WebAssembly, там, у него есть,

01:29:57.280 --> 01:29:59.280
короче говоря, FPU

01:29:59.280 --> 01:30:01.280
инструкции, и они все, как бы, ломают

01:30:01.280 --> 01:30:03.280
детерминизм, вот. Поэтому

01:30:03.280 --> 01:30:05.280
там, где WebAssembly используется,

01:30:05.280 --> 01:30:07.280
в частности, там, в Polkadot

01:30:07.280 --> 01:30:09.280
используются вот эти

01:30:09.280 --> 01:30:11.280
смарт-контракты на WebAssembly в EOS,

01:30:11.280 --> 01:30:13.280
еще там, на самом деле,

01:30:13.280 --> 01:30:15.280
в кучу языков, да и эфир, в общем-то,

01:30:15.280 --> 01:30:17.280
тоже, как бы, у него есть там

01:30:17.280 --> 01:30:19.280
EIP и там стандарты

01:30:19.280 --> 01:30:21.280
и подход к снаряду, они тоже,

01:30:21.280 --> 01:30:23.280
как бы, хотели переезжать на WebAssembly,

01:30:23.280 --> 01:30:25.280
вот, пока, как бы,

01:30:25.280 --> 01:30:27.280
не переехали там, просто WebAssembly

01:30:27.280 --> 01:30:29.280
в этой виртуальной машине, вот это

01:30:29.280 --> 01:30:31.280
выпиливается и остается,

01:30:31.280 --> 01:30:33.280
как бы, голый WebAssembly,

01:30:33.280 --> 01:30:35.280
ну, такой, как бы,

01:30:35.280 --> 01:30:37.280
детерминированный, вот. С ним

01:30:37.280 --> 01:30:39.280
уже, там, соответственно, можно работать.

01:30:39.280 --> 01:30:41.280
Ну, еще, в принципе,

01:30:41.280 --> 01:30:43.280
один из кандидатов, как бы, это

01:30:43.280 --> 01:30:45.280
и Яловский, и, там,

01:30:45.280 --> 01:30:47.280
C-Sharp, короче, Bytecode,

01:30:47.280 --> 01:30:49.280
вот такой, ну, как бы, чем не виртуальная машина

01:30:49.280 --> 01:30:51.280
софтовая, как бы, в теории, как бы, тоже

01:30:51.280 --> 01:30:53.280
можно использовать, но

01:30:53.280 --> 01:30:55.280
тоже придется, как бы, поколдовать детерминизм,

01:30:55.280 --> 01:30:57.280
чтобы ничего вот этого, как бы, не было.

01:30:57.280 --> 01:30:59.280
Вот.

01:30:59.280 --> 01:31:01.280
Ну, вот, часто бывает, что, как бы,

01:31:01.280 --> 01:31:03.280
пишут блокчейны,

01:31:03.280 --> 01:31:05.280
типа, у нас есть смарт-контракты, но они заботятся

01:31:05.280 --> 01:31:07.280
о вот этом детерминизме, поэтому,

01:31:07.280 --> 01:31:09.280
как бы, да, имейте в виду, в эту ловушку

01:31:09.280 --> 01:31:11.280
не попадаете, там, просто не понимают,

01:31:11.280 --> 01:31:13.280
как бы, люди.

01:31:13.280 --> 01:31:15.280
Вот. Значит,

01:31:15.280 --> 01:31:17.280
по поводу stack-based

01:31:17.280 --> 01:31:19.280
машины. Значит, что, значит, вообще

01:31:19.280 --> 01:31:21.280
stack-based,

01:31:21.280 --> 01:31:23.280
stack-based

01:31:23.280 --> 01:31:25.280
и register-based?

01:31:25.280 --> 01:31:27.280
Мне кажется,

01:31:27.280 --> 01:31:29.280
все знают, что это такая машина.

01:31:29.280 --> 01:31:31.280
Ну,

01:31:31.280 --> 01:31:33.280
не знаю, вот, не уверен,

01:31:33.280 --> 01:31:35.280
если кто-то, как бы, на ASME, как бы, не писал.

01:31:35.280 --> 01:31:37.280
Посмотрите, у меня есть какая-то

01:31:37.280 --> 01:31:39.280
функция, которая принимает, как бы, два

01:31:39.280 --> 01:31:41.280
аргумента, значит, она что-нибудь, там, делает

01:31:41.280 --> 01:31:43.280
A плюс B, короче, возвращает,

01:31:43.280 --> 01:31:45.280
там, типа, делает return,

01:31:45.280 --> 01:31:47.280
return

01:31:47.280 --> 01:31:49.280
A плюс B.

01:31:49.280 --> 01:31:51.280
Вот. Такая. Я ее,

01:31:51.280 --> 01:31:53.280
соответственно, в ASME пишу.

01:31:53.280 --> 01:31:55.280
Вот.

01:31:55.280 --> 01:31:57.280
И, значит, как

01:31:57.280 --> 01:31:59.280
выглядит стековая машина? У меня есть

01:31:59.280 --> 01:32:01.280
stack.

01:32:01.280 --> 01:32:03.280
И,

01:32:03.280 --> 01:32:05.280
как бы, вот эти слова stack и register,

01:32:05.280 --> 01:32:07.280
на самом деле, ну, прям можно

01:32:07.280 --> 01:32:09.280
воспринимать, как парадигма

01:32:09.280 --> 01:32:11.280
передачи параметров функций. То есть,

01:32:11.280 --> 01:32:13.280
каким образом функция получает свои

01:32:13.280 --> 01:32:15.280
параметры. В стековой машине,

01:32:15.280 --> 01:32:17.280
как бы, вот этот код вызову этой функции,

01:32:17.280 --> 01:32:19.280
когда я сделаю, там,

01:32:19.280 --> 01:32:21.280
F от 3 и 5,

01:32:21.280 --> 01:32:23.280
вызову, как бы, ее,

01:32:23.280 --> 01:32:25.280
то мне

01:32:25.280 --> 01:32:27.280
компилятор создал следующий

01:32:27.280 --> 01:32:29.280
код. Он сделает push

01:32:29.280 --> 01:32:31.280
5, там, push

01:32:31.280 --> 01:32:33.280
3 или push 3

01:32:33.280 --> 01:32:35.280
push 5, как бы, там, по-разному.

01:32:35.280 --> 01:32:37.280
Затем вызывает функцию

01:32:37.280 --> 01:32:39.280
сложить

01:32:39.280 --> 01:32:41.280
and,

01:32:41.280 --> 01:32:43.280
ну, и потом, соответственно,

01:32:43.280 --> 01:32:45.280
ну, не знаю, там, это

01:32:45.280 --> 01:32:47.280
return, короче говоря, или, там,

01:32:47.280 --> 01:32:49.280
не знаю, там, загрузить

01:32:49.280 --> 01:32:51.280
со стека, как бы, результат,

01:32:51.280 --> 01:32:53.280
там, не знаю, там, load, короче говоря,

01:32:53.280 --> 01:32:55.280
там, в какой-нибудь, там,

01:32:55.280 --> 01:32:57.280
память. Значит,

01:32:57.280 --> 01:32:59.280
как это будет выглядеть? Сначала я положу

01:32:59.280 --> 01:33:01.280
на stack 5, потом

01:33:01.280 --> 01:33:03.280
я положу на stack 3, потом

01:33:03.280 --> 01:33:05.280
я вызываю функцию add, которая, что делает?

01:33:05.280 --> 01:33:07.280
Она делает pop

01:33:07.280 --> 01:33:09.280
3, то есть она снимает, как бы, 3

01:33:09.280 --> 01:33:11.280
со стека сначала, потом снимает

01:33:11.280 --> 01:33:13.280
5 со стека, а потом кладет на stack

01:33:13.280 --> 01:33:15.280
8. То есть делает push, как бы, вот,

01:33:15.280 --> 01:33:17.280
8.

01:33:17.280 --> 01:33:19.280
Ну, и, соответственно, я знаю,

01:33:19.280 --> 01:33:21.280
что после выполнения этой инструкции, как бы,

01:33:21.280 --> 01:33:23.280
на стеке будет результат вот этих вот

01:33:23.280 --> 01:33:25.280
вот этих вот операций.

01:33:25.280 --> 01:33:27.280
То есть это, как бы, простой достаточно способ.

01:33:27.280 --> 01:33:29.280
А

01:33:29.280 --> 01:33:31.280
register-based

01:33:31.280 --> 01:33:33.280
виртуальные машины, они, как бы,

01:33:33.280 --> 01:33:35.280
работают как? Они, на самом деле,

01:33:35.280 --> 01:33:37.280
делают не push, а они делают

01:33:37.280 --> 01:33:39.280
давайте в

01:33:39.280 --> 01:33:41.280
первый регистр запишем 5,

01:33:41.280 --> 01:33:43.280
затем, там, в EBX

01:33:43.280 --> 01:33:45.280
запишем 3,

01:33:45.280 --> 01:33:47.280
а потом, как бы, вызовем add,

01:33:47.280 --> 01:33:49.280
там, там, EACS, там, EBX,

01:33:49.280 --> 01:33:51.280
там, и так далее. То есть они, как бы, будут

01:33:51.280 --> 01:33:53.280
использовать регистры,

01:33:53.280 --> 01:33:55.280
как, собственно, используют наши,

01:33:55.280 --> 01:33:57.280
как используют наши процессоры, там,

01:33:57.280 --> 01:33:59.280
всякие intelовые, там, рисковые, и так далее.

01:33:59.280 --> 01:34:01.280
Вот. И тогда в регистре

01:34:01.280 --> 01:34:03.280
EACS, как бы, уже появятся, там,

01:34:03.280 --> 01:34:05.280
результаты от 8, и мы его запишем

01:34:05.280 --> 01:34:07.280
в память. То есть в теории

01:34:07.280 --> 01:34:09.280
можно было бы сделать EVM, как бы,

01:34:09.280 --> 01:34:11.280
и регистровать, то есть сделать, там,

01:34:11.280 --> 01:34:13.280
нам пачку регистров договориться

01:34:13.280 --> 01:34:15.280
о том, как между ними продают

01:34:15.280 --> 01:34:17.280
передаются параметры и делать

01:34:17.280 --> 01:34:19.280
вот эту вот стековую машину.

01:34:19.280 --> 01:34:21.280
Значит,

01:34:21.280 --> 01:34:23.280
у регистровой машины,

01:34:23.280 --> 01:34:25.280
которая, там, напрямую работает

01:34:25.280 --> 01:34:27.280
с процессором, у нее, наверное,

01:34:27.280 --> 01:34:29.280
у нее, в общем-то, есть, как бы, преимущество,

01:34:29.280 --> 01:34:31.280
потому что операции с регистрами, они быстрее, чем

01:34:31.280 --> 01:34:33.280
операции со стеком. То есть

01:34:33.280 --> 01:34:35.280
процессор гораздо быстрее, как бы, работает,

01:34:35.280 --> 01:34:37.280
там, все перекидывает, как бы, в

01:34:37.280 --> 01:34:39.280
регистрах. Если, там, дальше вот это

01:34:39.280 --> 01:34:41.280
используется для дальнейших вычислений, все будет

01:34:41.280 --> 01:34:43.280
прям сильно-сильно быстрее, не надо

01:34:43.280 --> 01:34:45.280
в память ходить, там, и так далее.

01:34:45.280 --> 01:34:47.280
То есть, это преимущество у регистровых

01:34:47.280 --> 01:34:49.280
машин есть. Ну, еще можно, там, разные

01:34:49.280 --> 01:34:51.280
окна регистров использовать, если вот

01:34:51.280 --> 01:34:53.280
эти заняты, можно потом пойти, там,

01:34:53.280 --> 01:34:55.280
ЕЦХ, ЕДХ, как бы, их, там,

01:34:55.280 --> 01:34:57.280
современных процессоров, этих процессоров,

01:34:57.280 --> 01:34:59.280
этих регистров немерено.

01:34:59.280 --> 01:35:01.280
Вот, можно кучу всяких разных, там,

01:35:01.280 --> 01:35:03.280
оптимизаций делать, но

01:35:03.280 --> 01:35:05.280
это бьет, правда, по детерминизму

01:35:05.280 --> 01:35:07.280
исполнения. То есть,

01:35:07.280 --> 01:35:09.280
потому что здесь

01:35:09.280 --> 01:35:11.280
внутри есть всякие предсказания, там,

01:35:11.280 --> 01:35:13.280
переходов, и вот эти вот окна

01:35:13.280 --> 01:35:15.280
регистров в процессоре, то есть, когда

01:35:15.280 --> 01:35:17.280
у процессора, как бы, один и тот же набор

01:35:17.280 --> 01:35:19.280
регистров, он мгновенно переключается

01:35:19.280 --> 01:35:21.280
между, там, десятками, сотнями,

01:35:21.280 --> 01:35:23.280
как бы, версий. Наш

01:35:23.280 --> 01:35:25.280
процессор, когда мы в операционной системе

01:35:25.280 --> 01:35:27.280
работаем, он постоянно между процессорами

01:35:27.280 --> 01:35:29.280
переключается, и он, по сути, сейчас

01:35:29.280 --> 01:35:31.280
он выполнял, там, Notepad,

01:35:31.280 --> 01:35:33.280
а сейчас ему надо, как бы, в часы

01:35:33.280 --> 01:35:35.280
как-то переключиться, Clock. Он раз, короче,

01:35:35.280 --> 01:35:37.280
перескочил, сразу следующий контекст,

01:35:37.280 --> 01:35:39.280
там уже другой набор регистров.

01:35:39.280 --> 01:35:41.280
Потом, там, еще какой-нибудь, там, Scheduler,

01:35:41.280 --> 01:35:43.280
как бы, там другой набор регистров, он, там,

01:35:43.280 --> 01:35:45.280
работает постоянно, как бы, с разными

01:35:45.280 --> 01:35:47.280
контекстами. И

01:35:47.280 --> 01:35:49.280
поэтому, прям, какого-то такого четкого

01:35:49.280 --> 01:35:51.280
софтового детерминизма от

01:35:51.280 --> 01:35:53.280
регистровой машины

01:35:53.280 --> 01:35:55.280
сложнее его реализовать.

01:35:57.280 --> 01:35:59.280
Ну, и код сильно сложнее, как бы,

01:35:59.280 --> 01:36:01.280
чем у стековой машины. А еще,

01:36:01.280 --> 01:36:03.280
что важно, если у вас

01:36:03.280 --> 01:36:05.280
вместо стековой машины находится такой

01:36:05.280 --> 01:36:07.280
софтовый процессор, как бы, с регистрами,

01:36:07.280 --> 01:36:09.280
то вам, чтобы сохранить его состояние,

01:36:09.280 --> 01:36:11.280
если вам нужно

01:36:11.280 --> 01:36:13.280
save сделать,

01:36:13.280 --> 01:36:15.280
то вам нужно сохранить состояние

01:36:15.280 --> 01:36:17.280
регистров. То есть, вот этот, вот этот,

01:36:17.280 --> 01:36:19.280
вот этот, вот этот, чему они равны, короче

01:36:19.280 --> 01:36:21.280
говоря, там, и так далее.

01:36:21.280 --> 01:36:23.280
А у стековой машины, чтобы сохранить

01:36:23.280 --> 01:36:25.280
его состояние, надо просто, как бы,

01:36:25.280 --> 01:36:27.280
сохранить stack pointer,

01:36:27.280 --> 01:36:29.280
вот я нахожусь, вот, на этой инструкции,

01:36:29.280 --> 01:36:31.280
у меня instruction pointer,

01:36:31.280 --> 01:36:33.280
то есть, ну, на какой

01:36:33.280 --> 01:36:35.280
инструкции я стою, и

01:36:35.280 --> 01:36:37.280
на каком месте стека я нахожусь в оперативной

01:36:37.280 --> 01:36:39.280
памяти. Все, как бы, вот этих двух чисел,

01:36:39.280 --> 01:36:41.280
как бы, достаточно, чтобы, там, пойти сделать

01:36:41.280 --> 01:36:43.280
свои дела какие-то, потом вернуться,

01:36:43.280 --> 01:36:45.280
как бы, и просто продолжить исполнять.

01:36:45.280 --> 01:36:47.280
То есть мне, чтобы контекст установить, достаточно

01:36:47.280 --> 01:36:49.280
всего двух чисел. Вот.

01:36:49.280 --> 01:36:51.280
Ну, и стековая машина гораздо

01:36:51.280 --> 01:36:53.280
более предсказуемая

01:36:53.280 --> 01:36:55.280
в плане, как бы, поведения.

01:36:55.280 --> 01:36:57.280
То есть, как бы, все

01:36:57.280 --> 01:36:59.280
операции очень-очень сильно

01:36:59.280 --> 01:37:01.280
однотипные, то есть

01:37:01.280 --> 01:37:03.280
нет никаких, там, возможностей,

01:37:03.280 --> 01:37:05.280
там, сделать, если мы A и B

01:37:05.280 --> 01:37:07.280
писали в эти, например, регистры,

01:37:07.280 --> 01:37:09.280
а на другом компьютере решили вот через вот эти

01:37:09.280 --> 01:37:11.280
регистры сделать сложение, как бы, пожалуйста.

01:37:11.280 --> 01:37:13.280
Ну, то есть, все вот это вот должно,

01:37:13.280 --> 01:37:15.280
как бы, хендлиться. Вот.

01:37:15.280 --> 01:37:17.280
Но, тем не менее, как бы, можно делать и так,

01:37:17.280 --> 01:37:19.280
и так, и была выбрана, как бы, стековая

01:37:19.280 --> 01:37:21.280
машина. Ну, я могу сказать, что

01:37:21.280 --> 01:37:23.280
например, в блокчейне TON,

01:37:23.280 --> 01:37:25.280
который,

01:37:25.280 --> 01:37:27.280
Telegram, который строился там,

01:37:27.280 --> 01:37:29.280
есть TVM, короче, и они тоже

01:37:29.280 --> 01:37:31.280
выбрали стековую машину.

01:37:31.280 --> 01:37:33.280
Вот. Что, как бы, для блокчейнов,

01:37:33.280 --> 01:37:35.280
как бы, более правильно.

01:37:35.280 --> 01:37:37.280
Но она, знаете, она такая, она более ровная,

01:37:37.280 --> 01:37:39.280
она более предсказуемая, она более простая,

01:37:39.280 --> 01:37:41.280
как бы, в ней меньше

01:37:41.280 --> 01:37:43.280
может быть уязвимостей, связанной

01:37:43.280 --> 01:37:45.280
с тратой ресурсов.

01:37:45.280 --> 01:37:47.280
Различно. А вообще,

01:37:47.280 --> 01:37:49.280
если взять какой-нибудь просто код,

01:37:49.280 --> 01:37:51.280
как бы, того же, как бы, там,

01:37:51.280 --> 01:37:53.280
современного смарт-контракта и скомпилировать

01:37:53.280 --> 01:37:55.280
его в WebAssembly, в Wasm,

01:37:55.280 --> 01:37:57.280
то у Wasm есть еще одна

01:37:57.280 --> 01:37:59.280
проблема.

01:37:59.280 --> 01:38:01.280
WebAssembly разрабатывался для того, чтобы вы

01:38:01.280 --> 01:38:03.280
в своем браузере, да, могли

01:38:03.280 --> 01:38:05.280
крутить 3D-объекты.

01:38:05.280 --> 01:38:07.280
То есть, там есть, там предусмотрен

01:38:07.280 --> 01:38:09.280
код, как бы, который может вам взять,

01:38:09.280 --> 01:38:11.280
как бы, и заалоцировать, там, не знаю, там,

01:38:11.280 --> 01:38:13.280
10 мегабайт оперативной памяти.

01:38:13.280 --> 01:38:15.280
Там, не знаю, какого-нибудь объекта

01:38:15.280 --> 01:38:17.280
и пойти, там, с ним, как бы, работать

01:38:17.280 --> 01:38:19.280
и так далее. То есть, там очень много

01:38:19.280 --> 01:38:21.280
аллокаций памяти. То есть,

01:38:21.280 --> 01:38:23.280
выделить память под объект,

01:38:23.280 --> 01:38:25.280
а когда вы работаете с объектами

01:38:25.280 --> 01:38:27.280
вот такого размера,

01:38:27.280 --> 01:38:29.280
у вас ваш аллокатор памяти,

01:38:29.280 --> 01:38:31.280
он может, там, заранее, как бы, что-нибудь резервировать.

01:38:31.280 --> 01:38:33.280
Там, выделю я, пожалуй, сейчас 10

01:38:33.280 --> 01:38:35.280
килобайт вот этому чуваку, но еще вот здесь

01:38:35.280 --> 01:38:37.280
вот, как бы, такой кусочек выделю, как бы,

01:38:37.280 --> 01:38:39.280
вдруг он захочет потом расширить этот массив,

01:38:39.280 --> 01:38:41.280
чем-нибудь дописать.

01:38:41.280 --> 01:38:43.280
Дай-ка его, и вот здесь я тоже

01:38:43.280 --> 01:38:45.280
с запасом сделаю, там, еще

01:38:45.280 --> 01:38:47.280
что-то. И получается

01:38:47.280 --> 01:38:49.280
так, что очень простой

01:38:49.280 --> 01:38:51.280
код на, грубо говоря,

01:38:51.280 --> 01:38:53.280
самая простая логика

01:38:53.280 --> 01:38:55.280
в АСМе, она может порождать большое

01:38:55.280 --> 01:38:57.280
количество аллокаций

01:38:57.280 --> 01:38:59.280
аллок и фри.

01:38:59.280 --> 01:39:01.280
Ну, и освобождение, как бы,

01:39:01.280 --> 01:39:03.280
памяти. Просто потому, что у вас думают,

01:39:03.280 --> 01:39:05.280
ну, а вдруг сейчас, как бы, в этой переменной

01:39:05.280 --> 01:39:07.280
вдруг появится, там, не знаю, там, 10

01:39:07.280 --> 01:39:09.280
мегабайт, как бы, а вдруг этот цикл

01:39:09.280 --> 01:39:11.280
сейчас будет, там, какой-то, там, безумный, там,

01:39:11.280 --> 01:39:13.280
и так далее. То есть, там есть, там, всякие, как бы,

01:39:13.280 --> 01:39:15.280
оптимизации. То есть, для блокчейнов он не

01:39:15.280 --> 01:39:17.280
очень-то подходит. Поэтому

01:39:17.280 --> 01:39:19.280
в блокчейнах под WebAssembler

01:39:19.280 --> 01:39:21.280
пишут, как бы, свои собственные

01:39:21.280 --> 01:39:23.280
компиляторы. У Polkadot есть свои

01:39:23.280 --> 01:39:25.280
собственные, там, однопроходные компиляторы

01:39:25.280 --> 01:39:27.280
для WebAssembler. То есть, его все время нужно

01:39:27.280 --> 01:39:29.280
докручивать. Вот.

01:39:29.280 --> 01:39:31.280
Поэтому пока что

01:39:31.280 --> 01:39:33.280
в смарт-контрактах победили специализированные

01:39:33.280 --> 01:39:35.280
виртуальные машины.

01:39:35.280 --> 01:39:37.280
Вот. Они являются наиболее такими

01:39:37.280 --> 01:39:39.280
востребованными.

01:39:39.280 --> 01:39:41.280
Так.

01:39:41.280 --> 01:39:43.280
Время 13.40.

01:39:43.280 --> 01:39:45.280
Мы уже час 40 с вами проговорили.

01:39:45.280 --> 01:39:47.280
Поэтому я предлагаю сейчас перерыв.

01:39:47.280 --> 01:39:49.280
Давайте

01:39:49.280 --> 01:39:51.280
на 15 минут. То есть,

01:39:51.280 --> 01:39:53.280
до 13.55.

01:39:53.280 --> 01:39:55.280
В 13.55 я вернусь.

01:39:55.280 --> 01:39:57.280
Раз чайку попьете.

01:39:59.280 --> 01:40:01.280
Так. Все.

01:40:01.280 --> 01:40:03.280
Тогда перерыв.

01:40:15.280 --> 01:40:17.280
Продолжение следует.

01:40:45.280 --> 01:40:47.280
Продолжение следует.

01:41:15.280 --> 01:41:17.280
Продолжение следует.

01:41:45.280 --> 01:41:47.280
Продолжение следует.

01:42:15.280 --> 01:42:17.280
Продолжение следует.

01:42:45.280 --> 01:42:49.280
Продолжение следует.

01:43:15.280 --> 01:43:21.280
Продолжение следует.

01:43:45.280 --> 01:43:53.280
Продолжение следует.

01:44:15.280 --> 01:44:25.280
Продолжение следует.

01:44:45.280 --> 01:44:55.280
Продолжение следует.

01:45:15.280 --> 01:45:27.280
Продолжение следует.

01:45:45.280 --> 01:45:47.280
Продолжение следует.

01:46:15.280 --> 01:46:17.280
Продолжение следует.

01:46:45.280 --> 01:46:47.280
Продолжение следует.

01:47:15.280 --> 01:47:17.280
Продолжение следует.

01:47:45.280 --> 01:47:47.280
Продолжение следует.

01:48:15.280 --> 01:48:17.280
Продолжение следует.

01:48:45.280 --> 01:48:47.280
Продолжение следует.

01:49:15.280 --> 01:49:17.280
Продолжение следует.

01:49:45.280 --> 01:49:47.280
Продолжение следует.

01:50:15.280 --> 01:50:17.280
Продолжение следует.

01:50:45.280 --> 01:50:47.280
Продолжение следует.

01:51:15.280 --> 01:51:17.280
Продолжение следует.

01:51:45.280 --> 01:51:47.280
Продолжение следует.

01:52:15.280 --> 01:52:17.280
Продолжение следует.

01:52:45.280 --> 01:52:47.280
Продолжение следует.

01:53:15.280 --> 01:53:17.280
Продолжение следует.

01:53:45.280 --> 01:53:47.280
Продолжение следует.

01:54:15.280 --> 01:54:17.280
Продолжение следует.

01:54:17.700 --> 01:54:21.280
55 мм.

01:54:21.280 --> 01:54:23.280
55 мм.

01:54:23.280 --> 01:54:25.280
55 мм.

01:54:25.280 --> 01:54:27.280
55 мм.

01:54:27.280 --> 01:54:29.280
55 мм.

01:54:29.280 --> 01:54:31.280
55 мм.

01:54:31.280 --> 01:54:33.280
55 мм.

01:54:33.280 --> 01:54:35.280
55 мм.

01:54:35.280 --> 01:54:37.280
55 мм.

01:54:37.280 --> 01:54:39.280
55 мм.

01:54:39.280 --> 01:54:41.280
55 мм.

01:54:41.280 --> 01:54:43.280
55 мм.

01:54:43.280 --> 01:54:45.280
55 мм.

01:54:45.280 --> 01:55:05.240
То есть видно, что это как бы там запушили одно значение, другое значение, сохранили в память куда-то там, выделили, соответственно, в памяти кусочек, запушили, вызвали там какую-нибудь там функцию, которая вернула там размер входных аргументов, сравнили больше-меньше, условный переход.

01:55:05.240 --> 01:55:34.020
То есть, в принципе, похоже как бы на работу с ассемблером, вот, и как бы все смарт-контракты, они представляют собой вот этот вот, собственно, набор как раз обходов, вот они как бы их байты, там, когда мы, скажем, выкладываем контракт в сеть, то, по сути, его машинные, ну, вот прям, как бы, собственно, байт-код его функции, вот он находится вот здесь вот где-нибудь там в инпуте, то есть достаточно как бы большой, вот можно, например, посмотреть.

01:55:35.240 --> 01:55:39.040
Вот, у нас вот так вот все, наши контракты, этот вратит эфира.

01:55:41.440 --> 01:55:55.880
Так, ну, будет, будет очень долго, не, на самом деле, можно посмотреть самую первую, как бы, его транзакцию, когда он только был создан первый раз, там, last, как бы, контракт creation, то есть в тот момент, когда он был создан.

01:55:57.500 --> 01:56:00.760
Так, ладно, что-то он тут уже прям не доматывает.

01:56:01.640 --> 01:56:04.880
Вот, и там можно увидеть, соответственно, байт-код контракта.

01:56:05.240 --> 01:56:09.600
Байт-код контракта, который там размещался, он это сейчас, в общем, не так критично.

01:56:10.380 --> 01:56:11.360
А можно вопрос?

01:56:11.620 --> 01:56:11.740
Да.

01:56:12.000 --> 01:56:18.660
У нас же показаны были разные байт-коды, да, естественно, как они вообще не разные байт-коды запускаются?

01:56:22.000 --> 01:56:35.220
Ну, грубо говоря, сначала, сначала я создаю транзакцию create-контракт, create-контракт, у меня вот здесь внутри находится как раз байт-код моего контракта, вот эти вот там 6060,

01:56:35.460 --> 01:56:41.900
6040, 52, вот это вот прям, он по сути, как бы, весь, как бы, байт-код контракта с определенными штуками.

01:56:42.580 --> 01:56:54.160
И когда майнер применяет, когда майнер применяет, как бы, вот эту вот транзакцию, create-database, он создает, как бы, запись, что теперь, как бы, есть контракт по новому адресу, вот.

01:56:54.860 --> 01:57:05.220
Датадес, кстати, вычисляется из моего, вот, из этого, из АВАСи, вот, там, с балансами фиры, там, с пустым нонсом, как бы, сюда прям копируется, вот,

01:57:05.240 --> 01:57:07.460
байт-код, на самом деле

01:57:07.460 --> 01:57:09.540
не целиком, там, за исключением

01:57:09.540 --> 01:57:10.380
конструктора,

01:57:11.160 --> 01:57:13.100
и теперь, как бы, он может вызываться.

01:57:13.220 --> 01:57:15.400
То есть, на самом деле, может быть, как бы, много контрактов

01:57:15.400 --> 01:57:17.220
с одним и тем же байт-кодом.

01:57:17.600 --> 01:57:18.320
Пожалуйста, как бы.

01:57:18.840 --> 01:57:20.620
Но это байт-код EVM, да?

01:57:21.180 --> 01:57:22.980
Байт-код, да, именно EVM.

01:57:23.440 --> 01:57:24.860
А если в AppAssembly

01:57:24.860 --> 01:57:26.180
он транслируется в EVM?

01:57:28.140 --> 01:57:28.580
Нет.

01:57:28.840 --> 01:57:30.940
Но имеется в виду, что вы сюда

01:57:30.940 --> 01:57:33.060
разместите, как бы, можете любой мусор

01:57:33.060 --> 01:57:35.220
здесь разместить, но EVM его не обработает.

01:57:35.280 --> 01:57:37.220
Конечно, в процессе он, как бы, при помощи EVM.

01:57:38.780 --> 01:57:38.960
Вот.

01:57:39.020 --> 01:57:40.840
Я так понимаю, в эфире

01:57:40.840 --> 01:57:42.380
используется только EVM?

01:57:42.700 --> 01:57:44.840
Да, в эфире только

01:57:44.840 --> 01:57:46.800
EVM. Ну, в смысле, как?

01:57:46.920 --> 01:57:49.040
Есть история,

01:57:49.040 --> 01:57:50.440
есть, как бы, предложение

01:57:50.440 --> 01:57:53.080
компилировать, солить, ну, чтобы

01:57:53.080 --> 01:57:54.780
EVM умел еще, как бы, и

01:57:54.780 --> 01:57:56.360
в WebAssembly байт-код.

01:57:57.340 --> 01:57:58.940
Ну, значит, будут контракты, как бы,

01:57:58.980 --> 01:58:00.760
здесь, которые

01:58:00.760 --> 01:58:03.160
на WebAssembly, как бы, написаны. Здесь будут инструкции

01:58:03.160 --> 01:58:04.100
в WebAssembly идти.

01:58:05.060 --> 01:58:05.220
Вот.

01:58:05.240 --> 01:58:06.360
А, то есть это просто

01:58:06.360 --> 01:58:09.240
для общего развития. Да, да, да.

01:58:09.280 --> 01:58:10.980
А так-то, на самом деле, да, как бы,

01:58:11.020 --> 01:58:13.180
в эфире это в основном EVM. Но, и

01:58:13.180 --> 01:58:15.440
как я уже говорил, она, в общем, по сути

01:58:15.440 --> 01:58:16.880
является победителем

01:58:16.880 --> 01:58:19.160
в гонке, как бы, смарт-контрактов,

01:58:19.220 --> 01:58:21.060
потому что даже тот же самый

01:58:21.060 --> 01:58:23.160
WebAssembly, который, казалось бы, ну, блин, ну,

01:58:23.180 --> 01:58:25.260
как, это же стандарт, там, у Mozilla, там,

01:58:25.340 --> 01:58:27.180
Google использует этот WebAssembly,

01:58:27.340 --> 01:58:29.180
там, значит, все, там, поддержка, там,

01:58:29.240 --> 01:58:30.240
машины виртуальные.

01:58:30.900 --> 01:58:33.140
Но все равно его приходится допиливать

01:58:33.140 --> 01:58:35.080
для блокчейнов. Как бы, лучше оказалось,

01:58:35.240 --> 01:58:37.180
как бы, проверенное уже, там,

01:58:37.220 --> 01:58:39.500
сколько, 7 лет, как бы, этой EVM,

01:58:40.280 --> 01:58:41.020
которая кучей

01:58:41.020 --> 01:58:43.220
детских болезней переболела.

01:58:43.340 --> 01:58:44.920
То есть огромное количество изменений

01:58:44.920 --> 01:58:47.500
в security, там, во всем, там, были сделаны.

01:58:49.080 --> 01:58:51.200
Я обещал поговорить, как бы, про

01:58:51.200 --> 01:58:53.440
стоимость газа.

01:58:53.540 --> 01:58:55.080
Вот. И вот, собственно, как раз

01:58:55.080 --> 01:58:56.500
и поговорим

01:58:56.500 --> 01:58:59.440
сейчас, да, просто для, как бы,

01:58:59.480 --> 01:59:01.440
примера. Ну, вот, например, там,

01:59:01.440 --> 01:59:03.760
Push, да, это... Можно вопрос, пока я не забыл?

01:59:04.020 --> 01:59:04.860
Да, да, да.

01:59:04.860 --> 01:59:06.920
Вот. Вы скинете потом презентацию

01:59:06.920 --> 01:59:08.820
в чат? Да, да, да.

01:59:08.920 --> 01:59:10.660
Будет вместе с записями, как бы, да.

01:59:10.800 --> 01:59:12.160
Будет все рядом лежать.

01:59:12.360 --> 01:59:13.500
Не волнуйтесь.

01:59:14.760 --> 01:59:15.120
Значит,

01:59:15.440 --> 01:59:18.620
ну, просто так, по стоимости, да, как бы,

01:59:18.740 --> 01:59:20.580
то есть мы просто взяли из головы

01:59:20.580 --> 01:59:22.300
какие-то, там, не знаю, очки, как бы,

01:59:22.360 --> 01:59:24.360
какие-то, там, не знаю, execution costs

01:59:24.360 --> 01:59:26.480
и так далее. Придумали свою

01:59:26.480 --> 01:59:28.420
собственную виртуальную машину. У нас вот такая

01:59:28.420 --> 01:59:29.620
вот, как бы, куча инструкций.

01:59:30.240 --> 01:59:32.000
И давай им, значит, цену назначать.

01:59:32.520 --> 01:59:34.740
Но операции со стеком у нас должны быть дешевые.

01:59:34.860 --> 01:59:36.520
Да, там, три, как бы, там,

01:59:36.720 --> 01:59:38.480
запушить, как бы, значение на стек.

01:59:38.580 --> 01:59:40.420
Ну, сложение, понятно, как бы, что там,

01:59:40.660 --> 01:59:42.920
прочитали пару значений, процессор

01:59:42.920 --> 01:59:43.400
сложил.

01:59:45.460 --> 01:59:46.320
Значит, там,

01:59:46.580 --> 01:59:48.480
здесь я что-то прям,

01:59:48.640 --> 01:59:50.880
ну, наверное, не очень,

01:59:51.040 --> 01:59:52.580
как бы, точно указал, как бы, обратились

01:59:52.580 --> 01:59:54.480
к оперативной памяти, и эта штука уже, как бы,

01:59:54.540 --> 01:59:56.500
сильно потяжелее. Потому что неизвестно,

01:59:56.620 --> 01:59:58.680
сколько я хочу сохранить. Если я хочу сохранить

01:59:58.680 --> 02:00:00.780
килобайт, как бы, и, там, мегабайт,

02:00:01.480 --> 02:00:02.860
то у меня должна быть разница

02:00:02.860 --> 02:00:04.680
в тысячу, как бы, по цене.

02:00:04.860 --> 02:00:06.600
То есть, поэтому написано, там, перслот.

02:00:07.100 --> 02:00:09.000
То есть, оценивается по количеству

02:00:09.000 --> 02:00:10.820
выделяемых слотов эта история, там,

02:00:11.040 --> 02:00:12.840
наверное, трешка, я, наверное, прям написал.

02:00:14.500 --> 02:00:14.860
Там,

02:00:14.940 --> 02:00:16.360
jump, условный переход.

02:00:16.720 --> 02:00:18.820
Ну, это, собственно, как у нас везде,

02:00:18.940 --> 02:00:20.840
как бы, ну, везде есть,

02:00:20.840 --> 02:00:22.880
как бы, условный переход. Без него компьютер

02:00:22.880 --> 02:00:24.720
невозможен, как бы, и тюринг полный,

02:00:24.800 --> 02:00:26.900
как бы, вообще, хоть какие-то языки.

02:00:27.380 --> 02:00:28.940
Поэтому, вот, если у нас условный переход,

02:00:29.080 --> 02:00:30.460
проверка условий стоит 10.

02:00:31.520 --> 02:00:32.980
И вот, мега-дорогие

02:00:32.980 --> 02:00:33.620
операции.

02:00:34.860 --> 02:00:36.760
Очень сильные, короче. Это загрузка

02:00:36.760 --> 02:00:38.860
из сториджа и сохранение

02:00:38.860 --> 02:00:40.840
в сторидж. Почему самая

02:00:40.840 --> 02:00:42.840
дорогая, ну, сохранение в сторидж,

02:00:42.900 --> 02:00:45.020
ну, потому что вы сохраняете свою переменную

02:00:45.020 --> 02:00:47.000
в сторидж, вот в эту k-value баз данных,

02:00:47.020 --> 02:00:48.660
и она будет скопирована на тысячи

02:00:48.660 --> 02:00:50.660
компьютеров в эфире, как бы. Поэтому, да,

02:00:50.660 --> 02:00:52.200
за это, как бы, придется заплатить.

02:00:53.040 --> 02:00:54.680
Заметьте, сохранить одно значение

02:00:54.680 --> 02:00:56.780
стоит, ну, прямо с нуля, как бы, у вас

02:00:56.780 --> 02:00:58.720
пустой контракт, вы просто какое-то значение

02:00:58.720 --> 02:01:00.660
сохраните в сторидж, стоит 20 тысяч газа.

02:01:01.800 --> 02:01:02.760
При этом перевод

02:01:02.760 --> 02:01:04.780
эфира стоит 21 тысячу

02:01:04.780 --> 02:01:06.700
газа. То есть, вот, просто, как бы, послать

02:01:06.700 --> 02:01:08.440
кому-то эфир будет стоить, как бы, там,

02:01:08.520 --> 02:01:10.760
есть у нее, там, base cost, как бы, основная

02:01:10.760 --> 02:01:12.300
цена 21 тысяча эфира.

02:01:13.300 --> 02:01:13.700
Вот.

02:01:14.720 --> 02:01:16.160
Сохранение одного значения, там,

02:01:16.360 --> 02:01:18.680
20 тысяч. Вызов

02:01:20.020 --> 02:01:20.860
другого контракта.

02:01:21.260 --> 02:01:22.720
Понятно, что штука, как бы, сложная,

02:01:22.840 --> 02:01:24.820
как бы, ну, на сам кол, как бы, надо, за него

02:01:24.820 --> 02:01:26.580
надо заплатить, потому что нам надо

02:01:26.580 --> 02:01:28.420
для этого, там, глобальные перемены

02:01:28.420 --> 02:01:30.780
подтянуть, там, контекст вызовов подготовить,

02:01:31.380 --> 02:01:32.500
и так далее, как бы.

02:01:33.060 --> 02:01:34.480
Но, по-хорошему, когда я

02:01:34.780 --> 02:01:36.680
иду из одного контракта в другой, да, то

02:01:36.680 --> 02:01:39.100
у меня, как бы, газ с этим вызовом передается.

02:01:39.580 --> 02:01:40.960
То есть, я сейчас, там, не знаю,

02:01:41.060 --> 02:01:42.720
там, бегу по первому

02:01:42.720 --> 02:01:44.720
контракту, потратил 50

02:01:44.720 --> 02:01:46.640
тысяч газа, потом у меня происходит

02:01:46.640 --> 02:01:48.980
вызов, я иду в другой, в другой контракт,

02:01:49.460 --> 02:01:50.860
там продолжается исполнение,

02:01:50.980 --> 02:01:52.720
здесь тоже, как бы, газ суммируется,

02:01:52.820 --> 02:01:54.860
я потратил, там, еще, еще плюс 22

02:01:54.860 --> 02:01:56.820
тысячи газа, как бы, вернулся

02:01:56.820 --> 02:01:58.560
обратно, и у меня уже здесь 72,

02:01:58.740 --> 02:02:00.600
ну, и продолжу дальше.

02:02:00.780 --> 02:02:02.920
То есть, там, там тоже, как бы, механизмы

02:02:02.920 --> 02:02:04.620
довольно, там,

02:02:04.780 --> 02:02:06.420
разные есть, можно с вызовом послать, там,

02:02:06.500 --> 02:02:08.280
любое количество газа, какое вам нравится,

02:02:08.400 --> 02:02:09.260
то есть, все это делается.

02:02:10.600 --> 02:02:12.660
Ну, и то, что я говорил про лог, это про

02:02:12.660 --> 02:02:14.160
вот эти, вот, ивенты,

02:02:14.560 --> 02:02:16.920
которые в контракте

02:02:16.920 --> 02:02:17.840
происходят.

02:02:19.400 --> 02:02:20.440
То есть, вот эти, вот, которые

02:02:20.440 --> 02:02:21.940
депозит выбрал,

02:02:22.200 --> 02:02:23.140
господи ты боже,

02:02:24.280 --> 02:02:25.900
сори, намотал.

02:02:26.940 --> 02:02:28.800
Вот он. Вот эти, вот,

02:02:28.840 --> 02:02:30.820
то, что в момент трансфера происходит

02:02:30.820 --> 02:02:32.560
ивент трансфер, в момент депозита

02:02:32.560 --> 02:02:34.480
происходит ивент депозит, вот,

02:02:34.780 --> 02:02:44.020
они стоят соответственно довольно дешево вот 375 плюс ну плюс цена короче говоря ну за размер

02:02:44.020 --> 02:02:51.220
данных то есть ни одного байта еще раз напоминаю как бы ни одни 1 байт бесплатно как бы не процессе

02:02:51.220 --> 02:02:58.120
если говорить о наборе инструкции здесь есть соответственно обходы мы видим по сути в общем

02:02:58.120 --> 02:03:03.300
то то же самое описание там виртуальной машины как ассемблера да вот там сложение на стеки

02:03:03.300 --> 02:03:10.440
должно быть два числа на выходе на стыке будет как бы в сумму умножение деление все как бы

02:03:10.440 --> 02:03:19.820
понятные истории сравнения сравнение двух чисел да там на стыке будет результатом труды фолз тоже

02:03:19.820 --> 02:03:27.660
все как бы известно там сравнению с нулем там и так далее так далее сдвиги первое наверное

02:03:27.660 --> 02:03:32.400
интересная инструкция на котором мы натыкаемся от инструкции сша 3 который нету как был в

02:03:32.400 --> 02:03:33.000
современных процессах

02:03:33.300 --> 02:03:40.880
микроконтроллеров крайне важный который считает хэш от данных в оперативной памяти то есть вы

02:03:40.880 --> 02:03:46.320
говорите как бы там где оперативной памяти лежат данные сколько байт прочитать и от них надо

02:03:46.320 --> 02:03:53.340
посчитать хэш вот он стоит соответственно но он считает как раз хэш вот этот алгоритм хэширование

02:03:53.340 --> 02:03:59.760
кетчуп 256 который еще называют не называют официальное название сша 3 то что это третий

02:03:59.760 --> 02:04:03.280
международный стандарт хэширования который всем миром принято

02:04:03.300 --> 02:04:09.960
алгоритм хэширования 256 бит и вот он как бы ключевой в эфире весь эфир построен вот на этом

02:04:09.960 --> 02:04:18.240
как бы кичаки мы его дизайн будем рассматривать на симметричных микрографии обход который получает

02:04:18.240 --> 02:04:25.500
адрес текущего контракта на стыке обход который получает баланс эфира данного адреса пожалуйста

02:04:25.500 --> 02:04:33.280
как бы там ну там всякие там типа кто вызвал кто вызвал этот контракт сколько он эфира послал вместе с эфиром

02:04:33.300 --> 02:04:39.360
то есть мы сейчас выполняем как бы транзакцию и у нас есть по сути глобальные перемены когда мы

02:04:39.360 --> 02:04:46.200
процессе наш контракт этот код как бы бежим к нему а нам еще вдобавок как бы сюда передаются глобальные

02:04:46.200 --> 02:04:52.680
перемены это то есть кто отправил транзакцию сколько предложил ему денег вот инструкция

02:04:52.680 --> 02:05:01.260
которая позволяет параметры загрузить связанные с этим вызовом колдата это как бы называется вот еще

02:05:03.300 --> 02:05:09.200
такая как бы интересно инструкция код сайдс размер кода то есть она довольно тупая как бы

02:05:09.200 --> 02:05:15.960
из того что я вам рисовал у васи как бы но у него там баланс как бы у него кода никакого

02:05:15.960 --> 02:05:22.080
нету а вот у нашего контракта как бы код есть вот эта инструкция она просто выдает размер

02:05:22.080 --> 02:05:27.960
как бы кода то есть можно при помощи ее узнать как бы на этот адрес является контрактом или

02:05:27.960 --> 02:05:33.120
просто адресом с эфиром вот с этим тоже там много связано безопасности тоже как бы поговорим

02:05:33.300 --> 02:05:37.360
Вот там всякие, и так далее.

02:05:38.000 --> 02:05:41.060
Значит, Coinbase — это довольно интересная штука.

02:05:42.120 --> 02:05:49.360
Когда майнер будет исполнять смарт-контракт, вот в этой переменной, блок Coinbase,

02:05:49.880 --> 02:05:54.780
то есть можно в смарт-контракте обратиться, получить адрес майнера, который этот блок произвел.

02:05:56.040 --> 02:06:01.280
То есть вы можете в текущем блоке получить адрес того, кто этот блок произвел.

02:06:01.280 --> 02:06:03.440
Когда отправлять транзакцию, вы этого не знаете.

02:06:03.620 --> 02:06:10.200
Но когда транзакция будет исполняться, понятно, что майнер подставляет сам адрес того,

02:06:10.740 --> 02:06:17.540
адрес того, кто произвел блок, и вы получите, соответственно, его можете в контракте использовать.

02:06:18.500 --> 02:06:22.740
Мега важная штука — блок timestamp, по сути, получение текущего времени.

02:06:23.160 --> 02:06:27.780
Как я говорил, у всех транзакций в одном блоке одно и то же время текущее.

02:06:27.780 --> 02:06:29.360
Это время вот этого блока.

02:06:29.720 --> 02:06:30.780
И без всяких там...

02:06:31.280 --> 02:06:33.020
Без всяких расхождений.

02:06:34.280 --> 02:06:36.700
Ну, там номера блока, difficulty.

02:06:38.280 --> 02:06:40.160
Важная довольно штука — газ-лимит.

02:06:40.600 --> 02:06:46.780
То есть сколько в этом блоке максимально может быть потрачено газа, причем как бы на все транзакции.

02:06:48.040 --> 02:06:54.220
Ну, то есть сколько как бы в данном блоке всего, как бы вот этих попугаев на все транзакции будет.

02:06:54.220 --> 02:06:59.080
То ли всего, а может быть и на данную транзакцию какой-то там hard-limit, честно говоря.

02:07:01.280 --> 02:07:05.160
Уж как бы наизусть о спецификации, конечно, не знаю.

02:07:05.960 --> 02:07:07.500
Важный параметр — chain ID.

02:07:08.380 --> 02:07:10.700
То есть это как бы идентификатор сети.

02:07:11.500 --> 02:07:15.020
Видите, здесь там MyNet, Robsten, Girly и так далее.

02:07:15.140 --> 02:07:21.800
То есть каждый форк эфира, ну, такая как бы копия эфира, которая хочет как бы у себя реализовать EVM,

02:07:22.680 --> 02:07:27.620
и чтобы все контракты были совместимы, как бы чтобы они правильно возвращали как бы идентификатор цепочки,

02:07:27.620 --> 02:07:31.260
то в разных блокчейнах chain ID разный.

02:07:31.280 --> 02:07:37.740
Например, если я вот здесь вот там выбираю как бы между там Girly, Ethereum, MyNet,

02:07:37.740 --> 02:07:44.380
по сути у меня будет в транзакциях меняться вот этот вот chain ID, а контракты могут это дело проверять.

02:07:44.380 --> 02:07:49.880
То есть там твоя транзакция как бы для этого chain ID как бы предназначена, вот.

02:07:49.880 --> 02:07:56.500
Затем как бы баланс самого контракта, там, короче, там базовые фичи, сейчас чуть-чуть тоже о них поговорим.

02:07:56.500 --> 02:08:00.660
Загрузка память — mLoad, mStore.

02:08:00.660 --> 02:08:01.160
mStore.

02:08:01.160 --> 02:08:05.540
mStore там одного байта, как бы это операция с оперативной памятью.

02:08:05.540 --> 02:08:09.920
То же самое с mLoad и mStore, такие же операции, но со стороджем.

02:08:09.920 --> 02:08:15.160
Здесь уже видите, как k-value, здесь уже никакие не обсеты, вот.

02:08:15.160 --> 02:08:23.440
Jump — условный jump, вот, ну и дальше как бы много разных видов пушей, которые нам нужны.

02:08:23.440 --> 02:08:30.540
Ну а dupe — это как бы дуплицирование значения на стеке, ну это очень часто нужно как бы,

02:08:30.540 --> 02:08:40.620
вы там получили результат из функции, как бы вы ее используете в следующей функции и хотите предыдущий результат тоже сохранить на стеке, вот.

02:08:40.620 --> 02:08:51.500
Ну и куча всяких разных штук, как бы связанных с операциями на стеке, свапы, как бы это все для того, чтобы более эффективно все получалось, вот.

02:08:51.500 --> 02:08:56.480
Запись событий, ивентов, вот этот вот log и так далее.

02:08:56.480 --> 02:08:59.700
Здесь есть как бы log для разного количества аргументов.

02:08:59.700 --> 02:09:00.200
Вот.

02:09:00.540 --> 02:09:05.700
Сам call — вызов другого контракта.

02:09:05.700 --> 02:09:12.000
Вот обкод очень важный, как бы create, который создает новый контракт.

02:09:12.000 --> 02:09:18.100
Он говорит там типа «забери байткод этого контракта и создай как бы новый контракт по определенному адресу».

02:09:18.100 --> 02:09:24.060
То есть контракт может не только обращаться к другим контрактам, он может еще и deploy другие контракты.

02:09:24.060 --> 02:09:27.020
И эта штука тоже используется, тоже посмотрим.

02:09:27.020 --> 02:09:28.620
Вот.

02:09:28.620 --> 02:09:30.340
Затем там различные вызовы.

02:09:30.340 --> 02:09:33.500
Call, call code, delegate call — тут много.

02:09:33.500 --> 02:09:39.260
Вторая версия, create2, тоже про нее поговорим, то есть еще один способ deploy контракта.

02:09:39.260 --> 02:09:48.100
Static call — это когда мы обращаемся к библиотеке и говорим, в течение этого вызова как бы ничего в сторидже поменяться не должно быть.

02:09:48.100 --> 02:09:53.300
Ни в коем случае мы не будем трогать вообще сторидж как бы ни в каком виде.

02:09:53.300 --> 02:09:58.740
Такой вызов подешевле, вот, и нужен для обращения к библиотекам.

02:09:58.740 --> 02:10:00.120
Ну, есть еще revert.

02:10:00.340 --> 02:10:05.500
И еще мега интересная инструкция, которая называется self-destruct.

02:10:05.500 --> 02:10:07.120
Значит, что делает self-destruct?

02:10:07.120 --> 02:10:14.140
Self-destruct удаляет полностью весь код контракта, то есть он становится как бы нулевым.

02:10:14.140 --> 02:10:25.820
Затем берет, короче говоря, весь баланс эфира, который есть, ну, есть у этого контракта и отправляет его тому, кто этот self-destruct вызвал.

02:10:25.820 --> 02:10:29.500
Ну, то есть, по сути, вычеркивает отсюда полностью, как бы вот такой контракт.

02:10:29.500 --> 02:10:34.900
полностью вот эту строку, весь эфир возвращает тому,

02:10:34.900 --> 02:10:39.180
кто этот селл-дистракт, не тому, кто вызвал, а на самом деле,

02:10:39.400 --> 02:10:42.520
то есть вызывающий селл-дистракт должен позаботиться о том,

02:10:42.600 --> 02:10:45.580
кому отправить эфир, если он здесь есть, конечно.

02:10:48.500 --> 02:10:53.100
По поводу селл-дистракта идут очень жаркие споры,

02:10:53.240 --> 02:10:55.080
и, скорее всего, его скоро выпилят.

02:10:55.480 --> 02:10:57.840
То есть его просто не будет, его просто не будет.

02:10:57.840 --> 02:11:00.140
Конечно, хотелось бы экономить место в блокчейне,

02:11:00.260 --> 02:11:02.360
вот такие вот контракты выпиливать,

02:11:03.220 --> 02:11:07.840
но это создает очень серьезные проблемы для работы нод,

02:11:08.240 --> 02:11:11.800
потому что нода качает новые блоки, качает новые блоки,

02:11:11.860 --> 02:11:14.640
она тратит свои силы на поддержание стейта,

02:11:15.100 --> 02:11:17.000
здесь контракт жив, здесь контракт жив,

02:11:17.580 --> 02:11:20.860
а пользователь говорит, какой там мой баланс в этом контракте,

02:11:21.400 --> 02:11:23.660
а нода еще не догнала до нового блока,

02:11:23.660 --> 02:11:27.820
и она не знает, вдруг здесь будет селл-дистракт этого контракта,

02:11:27.900 --> 02:11:31.300
может, я ему вообще должна ошибку или ноль выдать,

02:11:31.780 --> 02:11:35.640
а я еще не знаю, возможно, в следующем блоке будет селл-дистракт,

02:11:35.780 --> 02:11:39.180
и она тратит свои силы на то, чтобы индексировать эту всю штуку.

02:11:39.820 --> 02:11:43.900
Гораздо проще было бы вообще не иметь возможности удалять,

02:11:44.220 --> 02:11:48.480
пускай все там живет, и ничего не меняется.

02:11:49.120 --> 02:11:53.920
Вообще, опять же, в базах данных сама инструкция делит,

02:11:53.920 --> 02:11:57.380
она довольно коварная, то есть кажется, что там все просто,

02:11:57.380 --> 02:12:00.280
как бы, удалить данные, но, на самом деле, если вы начнете думать о том,

02:12:00.280 --> 02:12:07.480
как работают всякие сложные выборки, которые там работают с тысячами строк и так далее,

02:12:07.480 --> 02:12:13.380
то, на самом деле, окажется, что делит операция крайне сложная.

02:12:13.760 --> 02:12:17.760
И, как ни странно, внутри многих движков она реализуется при помощи инсертов.

02:12:18.760 --> 02:12:23.560
То есть строка заменяется на новую версию, как бы пустую,

02:12:23.960 --> 02:12:27.320
то есть которой там нету, ну, в общем, много всяких,

02:12:27.320 --> 02:12:32.320
тонкостей, как бы, в общем, удаление штука такая довольно коварная.

02:12:32.320 --> 02:12:36.320
Как можно выпилить self-destruct? Это же нарушится обратная совместимость.

02:12:37.320 --> 02:12:41.080
Ну, да, там для некоторых проектов обратная совместимость нарушится.

02:12:41.080 --> 02:12:44.560
Да, есть такое дело, вот, но, как бы, эфир хочет на это пойти,

02:12:44.560 --> 02:12:53.320
потому что без self-destruct невозможны дальнейшие, как бы, улучшения работы нод, вот.

02:12:53.320 --> 02:12:57.220
Ну, потому что из-за того, что, как бы, возможно, что контракт вдруг к какому-то блоке

02:12:57.320 --> 02:13:04.320
неожиданно исчезнет, создает очень много, как бы, проблем и там всяких ифов именно в коде,

02:13:04.320 --> 02:13:06.320
именно в коде нод.

02:13:06.320 --> 02:13:13.320
Потом старается, держит его state, короче говоря, там, ну, там, следит за его, там, состоянием, как бы,

02:13:13.320 --> 02:13:17.320
а потом он взял, короче говоря, и, как бы, сделал self-destruct.

02:13:17.320 --> 02:13:23.320
И, начиная с определенного блока, один и тот же запрос по адресу контракта, который, там, например,

02:13:23.320 --> 02:13:26.320
там, его код запрашивает или его какое-нибудь состояние, как бы,

02:13:27.320 --> 02:13:34.320
может работать, и ноде, как бы, непонятно, чего отвечать, как бы, то ли это, как бы, то ли это, вот.

02:13:34.320 --> 02:13:37.320
В общем, это довольно сильно, как бы, мешает.

02:13:37.320 --> 02:13:42.320
Вот, если бы его не было, как бы, то, если бы все контракты навеки, как бы, всегда прибиты, как бы,

02:13:42.320 --> 02:13:45.320
гвоздями в блокчейне, то было бы проще.

02:13:45.320 --> 02:13:48.320
С обычными адресами, которые не смысл контракта, так и происходит, да?

02:13:48.320 --> 02:13:50.320
Их нельзя удалить.

02:13:50.320 --> 02:13:57.320
Да, да, да, их нельзя удалить, они так, ну, здесь вообще все, как бы, остается, остается навсегда, вот.

02:13:57.320 --> 02:14:04.320
Просто так, как бы, обойти это нельзя, как бы, но можно при помощи криптографических протоколов разработать софт,

02:14:04.320 --> 02:14:12.320
там, типа ноды, которые ведут только часть, ну, по сути, как бы, которые ведут только контрольные суммы всего этого.

02:14:12.320 --> 02:14:16.320
То есть у них, по сути, есть доказательство, что действительно байткод по такому-то адресу,

02:14:16.320 --> 02:14:25.320
оно имеет вот такой вот хэш криптографический, что действительно баланс, короче, этого пользователя, вот, там, скажем, как бы, такой,

02:14:25.320 --> 02:14:27.320
но при этом сами данные они не держат.

02:14:27.320 --> 02:14:28.320
Вот.

02:14:28.320 --> 02:14:37.320
И, по сути, вот эта часть нод будет обеспечивать безопасность сети, а те, кому, как бы, нужен конкретно, там, сам код в процессе транзакции и так далее,

02:14:37.320 --> 02:14:44.320
это будут уже, там, дополнительные сервисы, дополнительные типы нод, там, в общем, это долго еще рассказать.

02:14:44.320 --> 02:14:52.320
Если прям очень интересно, то читайте, как выглядит эфир 2.0, там, все его, как бы, основные, как бы, механизмы.

02:14:52.320 --> 02:14:56.320
На самом деле, там, очень много сделано и очень хорошо.

02:14:57.320 --> 02:14:58.320
Вот.

02:14:58.320 --> 02:15:00.320
Они очень внимательные.

02:15:00.320 --> 02:15:01.320
Вот.

02:15:01.320 --> 02:15:02.320
Так.

02:15:02.320 --> 02:15:03.320
Окей.

02:15:03.320 --> 02:15:04.320
Поехали дальше.

02:15:04.320 --> 02:15:07.320
Значит, про цену чуть-чуть поговорили.

02:15:07.320 --> 02:15:18.320
Соответственно, про, тоже, если дальше, как бы, говорить, там, про цены, то у нас есть у Hard Limit блока.

02:15:18.320 --> 02:15:25.320
И, как я говорил, когда мы у нас сильно, ну, сильно забитые, сильно забитые цены.

02:15:25.320 --> 02:15:26.320
Да.

02:15:26.320 --> 02:15:36.320
Сильно забитый блокчейн, прям, вот, прям, не знаю, на 100%, как бы, все, все там забито, то вверх идут комиссии.

02:15:36.320 --> 02:15:44.320
Они теперь, они теперь, по сути, как бы, используются чуть-чуть похитрее, чем раньше.

02:15:44.320 --> 02:15:55.320
То есть, есть, ну, случился Е1559 Hard Fork, это было в августе 21 года, после которого было запрещено.

02:15:55.320 --> 02:15:58.320
Ну, то есть, например, ставить, как бы, цену газа ноль.

02:15:58.320 --> 02:16:05.320
То есть, раньше вы, в принципе, могли в теории, как бы, создать, как бы, транзакцию и сказать, цена газа ноль, стоит она ноль, как бы, пожалуйста, как бы.

02:16:05.320 --> 02:16:07.320
Ну, то есть, никто не запрещал.

02:16:07.320 --> 02:16:16.320
Понятно, что никто вашу транзакцию майнить не будет, она никому не нужна, но, тем не менее, в блоках таких транзакций было дофига с нулевой ценой.

02:16:16.320 --> 02:16:17.320
Что это было?

02:16:17.320 --> 02:16:23.320
Это были майнеры, которые одновременно трейдеры, и они, чтобы не запариваться, как бы, просто вставляли, как бы, транзакции с нулевым газом.

02:16:23.320 --> 02:16:24.320
Да.

02:16:24.320 --> 02:16:26.320
Транзакции с нулевым газ-прайсом свои собственные.

02:16:26.320 --> 02:16:32.320
То есть, могу ставить, могу, как бы, беру, доставляю, как бы, и все, и не волнуюсь газ-прайсом.

02:16:32.320 --> 02:16:41.320
Вот, про это тоже будет достаточно богатый разговор, про майнер extractable value, как раз про который докладывал я недавно.

02:16:41.320 --> 02:16:47.320
Вот, там все очень интересно, вот с тем, как борются за включение транзакций в блок.

02:16:47.320 --> 02:16:53.320
Там все гораздо интереснее, нежели в white paper написано, типа, поставил больше денег, тебя быстрее замайнят.

02:16:53.320 --> 02:16:54.320
Вот это вот.

02:16:54.320 --> 02:16:55.320
Не всегда так работает.

02:16:55.320 --> 02:16:59.320
Значит, запретили вот этот вот нулевой газ-прайс.

02:16:59.320 --> 02:17:09.320
Сказали, что есть специальная такая base fee, то есть минимальная цена за газ, которая зависит от вот этой заполняемости блока.

02:17:09.320 --> 02:17:14.320
То есть, блоки забиты на 100%, base fee растет вверх.

02:17:14.320 --> 02:17:20.320
Типа, ребята, sorry, блок-чейн весь забит, как бы, к черту, как бы, давайте, как бы, больше платите, больше денег.

02:17:20.320 --> 02:17:21.320
Вот.

02:17:21.320 --> 02:17:23.320
Потом, как бы, деньги растут вверх.

02:17:23.320 --> 02:17:28.320
Блок перестает заполняться, например, там, на 50%, как бы, он заполнен.

02:17:28.320 --> 02:17:30.320
Он, как бы, идет вниз.

02:17:30.320 --> 02:17:34.320
Вот это вот то, что я говорю, заполнен, измеряется, как вы думаете, в чем?

02:17:34.320 --> 02:17:37.320
Ну, в чем удобно измерять заполняемость блока?

02:17:41.320 --> 02:17:43.320
В мегабайтах?

02:17:43.320 --> 02:17:46.320
Ну, в долях, в количествах чего-то.

02:17:46.320 --> 02:17:48.320
Не-не-не, неудобно.

02:17:48.320 --> 02:17:50.320
Удобнее всего измерять в газе.

02:17:50.320 --> 02:17:52.320
У нас есть...

02:17:52.320 --> 02:17:57.320
У нас есть уже, как бы, универсальный, универсальный, по сути, счетчик.

02:17:57.320 --> 02:18:01.320
Счетчик, считающий, как бы, кванты, как бы, исполнения.

02:18:01.320 --> 02:18:07.320
Чтобы мы не перегрузили, как бы, майнеров, не вставляли в блок, там, какое-то безумное количество транзакций.

02:18:07.320 --> 02:18:09.320
Не замедляли процессинг и так далее.

02:18:09.320 --> 02:18:12.320
У нас есть, по сути, универсальный измеритель, газ.

02:18:12.320 --> 02:18:17.320
Мы взяли первую транзакцию, вторую транзакцию, третью транзакцию.

02:18:17.320 --> 02:18:21.320
У нас есть вот этот большой, так называемый, ну, там, hard limit.

02:18:21.320 --> 02:18:23.320
Его по-разному используют.

02:18:23.320 --> 02:18:32.320
Говорят, что hard limit — это константы, которые в одной транзакции не позволяют потратить, там, ну, скажем, там, больше десяти, там, не знаю, миллионов, короче, газа.

02:18:32.320 --> 02:18:34.320
Но и, как бы, для блока тоже говорят.

02:18:34.320 --> 02:18:41.320
То есть есть hard limit, там, не знаю, там, две тысячи, две тысячи транзакций умножить на текущий hard limit.

02:18:41.320 --> 02:18:46.320
Вот столько газа, как бы, максимум, как бы, может быть, может находиться в блоке.

02:18:46.320 --> 02:18:48.320
Вот этот hard limit, он тоже тюнится.

02:18:48.320 --> 02:18:49.320
Тоже динамический.

02:18:49.320 --> 02:18:50.320
В зависимости от заполняемости.

02:18:51.320 --> 02:18:52.320
В зависимости от заполняемости блока.

02:18:52.320 --> 02:18:53.320
Вот.

02:18:53.320 --> 02:18:56.320
То есть, там, где-то здесь, там, может уменьшается, здесь, там, он увеличивается.

02:18:56.320 --> 02:18:59.320
То есть, там, целая, как бы, модель такая большая.

02:18:59.320 --> 02:19:03.320
На нее, в общем, можно, на нее можно посмотреть.

02:19:03.320 --> 02:19:04.320
Вот.

02:19:04.320 --> 02:19:11.320
То есть здесь вопрос с комиссиями, он здесь, как бы, такой очень глубокий, там, умный.

02:19:11.320 --> 02:19:14.320
За ним, там, много всякой экономики, как бы, построено.

02:19:14.320 --> 02:19:20.320
Раньше эфир просто за каждый блок печатал, там, сколько-то, как бы, эфира майнеру.

02:19:20.320 --> 02:19:28.320
Плюс, как бы, ему, там, назначал, ну, плюс он плюсовал, как бы, фи, то есть, комиссии

02:19:28.320 --> 02:19:29.320
с транзакцией.

02:19:29.320 --> 02:19:32.320
Сейчас все сделано, как бы, по-другому.

02:19:32.320 --> 02:19:36.320
То есть, теперь у него есть, там, базовая штука, у него есть комиссии с транзакцией.

02:19:36.320 --> 02:19:39.320
Плюс еще часть эфира сжигается.

02:19:39.320 --> 02:19:44.320
И сжигается она, как раз, по-моему, в том случае, если есть какой-то недобор в блоке.

02:19:44.320 --> 02:19:49.320
То есть, как бы, народ перестает пользоваться эфиром.

02:19:49.320 --> 02:19:51.320
Значит, он какой-то, там, менее ценный, как бы.

02:19:51.320 --> 02:19:55.320
Значит, надо общее количество эфира уменьшить.

02:19:55.320 --> 02:19:57.320
То есть, просто начать его сжигать.

02:19:57.320 --> 02:19:59.320
Его будет становиться меньше.

02:19:59.320 --> 02:20:03.320
Это будет дефляция, и, как бы, цена эфира поэтому пойдет вверх, как бы.

02:20:03.320 --> 02:20:10.320
Они, там, ну, в общем, тут, чтобы просто не дезинформировать вас именно, как бы, фактами.

02:20:10.320 --> 02:20:12.320
Но самое главное, что эта модель, она, прям, динамическая.

02:20:12.320 --> 02:20:15.320
И там, конечно, обоснованы все эти, все эти истории.

02:20:15.320 --> 02:20:18.320
Можно почитать в ЯИПах, почему так было предложено.

02:20:18.320 --> 02:20:20.320
И это довольно грамотно сделано.

02:20:20.320 --> 02:20:25.320
То есть, сейчас эфир, как бы, такая очень развитая финансовая система.

02:20:25.320 --> 02:20:28.320
Вот.

02:20:28.320 --> 02:20:34.320
Дальше, ну, дальше уже, в принципе, такой, как бы, халявный, достаточно, как бы, кусок.

02:20:34.320 --> 02:20:37.320
Мы с вами на Etherscan, как бы, посидели.

02:20:37.320 --> 02:20:41.320
Сейчас еще чуть-чуть посидим, посмотрим, как бы, как смотреть всякие транзакции.

02:20:41.320 --> 02:20:43.320
Что у них есть.

02:20:43.320 --> 02:20:47.320
Затем я покажу, как примерно выглядит, как бы, там, не знаю.

02:20:47.320 --> 02:20:49.320
Там, разработка.

02:20:49.320 --> 02:20:51.320
Мы будем использовать HardHat.

02:20:51.320 --> 02:20:54.320
Есть такой фреймворк, очень удобный для разработки.

02:20:54.320 --> 02:20:59.320
На самом деле, подсолидить их, прям, несколько штук, там, три, четыре, пять.

02:20:59.320 --> 02:21:01.320
Здесь очень много, как бы, всего.

02:21:01.320 --> 02:21:04.320
Чуть-чуть полазим по разному, там, коду.

02:21:04.320 --> 02:21:05.320
Вот.

02:21:05.320 --> 02:21:06.320
Там, про Flow поговорим.

02:21:06.320 --> 02:21:11.320
То есть, сейчас уже, такой, более, более обзорная часть лекции.

02:21:11.320 --> 02:21:15.320
Etherscan'ом пользуются, наверное, как бы, все, практически, как бы, постоянно.

02:21:15.320 --> 02:21:22.320
Как вы понимаете, это, по сути, как бы, архивная, ну, сервис, который, как бы, бегает в архивные ноды.

02:21:22.320 --> 02:21:26.320
Собирает огромное количество разной информации.

02:21:26.320 --> 02:21:28.320
Размечает адреса.

02:21:28.320 --> 02:21:30.320
То есть, например, он там.

02:21:30.320 --> 02:21:35.320
Вот здесь мы видим, что вот этот адрес называется в RapidEther.

02:21:35.320 --> 02:21:37.320
То есть, что это его, что он является токеном.

02:21:37.320 --> 02:21:40.320
Что это, как бы, контракт токена.

02:21:40.320 --> 02:21:44.320
При этом Etherscan, как бы, понимает, как читать этот контракт, как писать этот контракт.

02:21:45.320 --> 02:21:52.320
Отдельного слова, наверное, как бы, заслуживает вот эта вот штука, что я вам показываю исходник.

02:21:52.320 --> 02:21:55.320
Исходник этого смарт-контракта.

02:21:55.320 --> 02:21:57.320
Откуда исходник взялся?

02:21:57.320 --> 02:22:05.320
Ну, то есть, вроде бы, как чувак задеплоил этот, значит, в RapidEther вот его там адрес.

02:22:05.320 --> 02:22:07.320
Вот его код.

02:22:07.320 --> 02:22:08.320
Это машинные инструкции.

02:22:08.320 --> 02:22:13.320
То есть, если вы просто сюда заглянете, там будет, по сути, его байт-код.

02:22:13.320 --> 02:22:14.320
Вот он.

02:22:14.320 --> 02:22:15.320
Так, creation-код.

02:22:15.320 --> 02:22:18.320
Вот так вот он выглядит в машинных инструкциях.

02:22:18.320 --> 02:22:22.320
Вот там, там, вот так вот.

02:22:22.320 --> 02:22:26.320
Откуда взялся у нас исходный код?

02:22:26.320 --> 02:22:30.320
Для этого, как бы, используется, так называемая, верификация смарт-контракта.

02:22:30.320 --> 02:22:36.320
Вы можете прийти на вот этот адрес, на котором не будет вот этого исходного кода.

02:22:36.320 --> 02:22:40.320
И сказать, я знаю такой исходник.

02:22:40.320 --> 02:22:42.320
Я знаю такой исходник, как бы, который...

02:22:42.320 --> 02:22:44.320
Получается...

02:22:44.320 --> 02:22:47.320
Ну, из которого скомпилирован вот этот вот байт-код.

02:22:47.320 --> 02:22:50.320
Это уже чисто централизованный, как бы, сервис.

02:22:50.320 --> 02:22:52.320
Вы заходите на Etherscan.

02:22:52.320 --> 02:22:54.320
Заливаете туда прямо вот этот текст.

02:22:54.320 --> 02:22:55.320
Вот.

02:22:55.320 --> 02:22:56.320
Видите?

02:22:56.320 --> 02:22:58.320
Даже с этим самым, с лицензионным соглашением.

02:22:58.320 --> 02:23:02.320
Которое понятно и никаким образом в байт-коде, как бы, вот здесь вот не представлено.

02:23:02.320 --> 02:23:05.320
Вы заливаете туда этот текст.

02:23:05.320 --> 02:23:07.320
Что делает Etherscan?

02:23:07.320 --> 02:23:08.320
Он его компилирует.

02:23:08.320 --> 02:23:10.320
Ваш вот этот текст.

02:23:10.320 --> 02:23:11.320
А...

02:23:11.320 --> 02:23:13.320
На самом деле убирает, как бы, еще там конструктор.

02:23:13.320 --> 02:23:16.320
Потому что конструктор не включается, как бы, в байт-код.

02:23:16.320 --> 02:23:19.320
И сравнивает с тем, что находится в блокчейне.

02:23:19.320 --> 02:23:22.320
Вот там вот, собственно, вот с этой вот штукой.

02:23:22.320 --> 02:23:25.320
Там где-то вот здесь вот, там, типа, код конструктора.

02:23:25.320 --> 02:23:28.320
Вначале заканчивается, как бы, и начинается сам код контракта.

02:23:28.320 --> 02:23:33.320
Вот он сравнивает, действительно ли из вашего исходника получился в точности вот этот вот байт-код.

02:23:33.320 --> 02:23:36.320
И если он получился, как бы, то...

02:23:36.320 --> 02:23:38.320
Ну, это все хорошо.

02:23:38.320 --> 02:23:39.320
Вот.

02:23:39.320 --> 02:23:40.320
А...

02:23:40.320 --> 02:23:42.320
Еще вторая, как бы, важная штуковина контракта.

02:23:42.320 --> 02:23:45.320
Это так называемая ABI.

02:23:45.320 --> 02:23:47.320
То есть смарт-контракты в эфире.

02:23:47.320 --> 02:23:52.320
Они ходят, по сути, для того, чтобы вы могли построить DAP.

02:23:52.320 --> 02:23:53.320
Который...

02:23:53.320 --> 02:23:55.320
Приложение, которое работает со смарт-контрактом.

02:23:55.320 --> 02:23:58.320
Вам же нужно знать вот эти все интерфейсы, функции.

02:23:58.320 --> 02:24:00.320
Что принимает депозит?

02:24:00.320 --> 02:24:01.320
Что принимает withdraw?

02:24:01.320 --> 02:24:03.320
Какой тип аргументов?

02:24:03.320 --> 02:24:04.320
Какие из них пишущие?

02:24:04.320 --> 02:24:05.320
Какие из них читающие?

02:24:05.320 --> 02:24:07.320
Там и так далее.

02:24:07.320 --> 02:24:09.320
И эта информация, этот интерфейс, как бы...

02:24:09.320 --> 02:24:12.320
Он представляется в формате ABI.

02:24:12.320 --> 02:24:14.320
Application Binary Interface.

02:24:14.320 --> 02:24:15.320
Вот.

02:24:15.320 --> 02:24:18.320
И здесь, в общем-то, описаны все функции.

02:24:18.320 --> 02:24:23.320
Ну, то есть там написано, там, не знаю, там...

02:24:23.320 --> 02:24:27.320
Где там функция какая-нибудь.

02:24:27.320 --> 02:24:29.320
Ну, короче...

02:24:29.320 --> 02:24:32.320
Я хотел найти какой-нибудь там депозит.

02:24:32.320 --> 02:24:33.320
Депозит.

02:24:33.320 --> 02:24:36.320
Name.

02:24:36.320 --> 02:24:37.320
Payable.

02:24:37.320 --> 02:24:38.320
Ну, в общем...

02:24:38.320 --> 02:24:47.320
Вот здесь вот как бы прописаны все функции данного контракта и типы их параметров.

02:24:47.320 --> 02:24:51.320
То есть здесь внутри где-то как бы зашита функция transfer.

02:24:51.320 --> 02:24:55.320
И мы знаем, что для того, чтобы перевести эти токены к кому-то другому,

02:24:55.320 --> 02:25:02.320
мы должны передать адрес назначения и количество токенов, которые мы должны передать.

02:25:02.320 --> 02:25:03.320
Вот.

02:25:03.320 --> 02:25:05.320
И это описывается вот в этом ABI.

02:25:05.320 --> 02:25:07.320
Ты его подключаешь к JavaScript.

02:25:07.320 --> 02:25:13.320
Это ABI, как бы ты его засовываешь, как бы, там, не знаю, там, в свой скрипт на Python, который общается с контрактом.

02:25:13.320 --> 02:25:18.320
И у тебя появляется, по сути, такой объектный интерфейс к твоему контракту.

02:25:18.320 --> 02:25:19.320
Вот.

02:25:19.320 --> 02:25:28.320
То есть как он там преобразуется в вызовы тоже будет рассказано, когда там низкоуровневые всякие будут смотреть штуки по обращению к контракту.

02:25:28.320 --> 02:25:29.320
Вот.

02:25:29.320 --> 02:25:32.320
Это значит то, что касается ABI.

02:25:32.320 --> 02:25:35.320
Затем, если посмотреть на этот...

02:25:35.320 --> 02:25:36.320
Ну, опять же, как бы...

02:25:36.320 --> 02:25:39.320
На общение с контрактом в RapidEther.

02:25:39.320 --> 02:25:43.320
Это токен такой, как бы, не знаю, там...

02:25:43.320 --> 02:25:48.320
То есть вы можете на своем балансе иметь там сколько-то в RapidEther.

02:25:48.320 --> 02:25:58.320
То здесь есть, например, передача, вкладка, короче, ERC-20 Token Transfers.

02:25:58.320 --> 02:26:05.320
То есть которая покажет, как бы, все транзакции, в которых кто-то кому-то какое-то количество вот этого в RapidEther передал.

02:26:06.320 --> 02:26:14.320
То есть там вот этот парень, как бы, передал там один эфир и, короче говоря...

02:26:14.320 --> 02:26:21.320
А, передал там, не знаю, там один токен Uniswap там кому-нибудь там вот этому в RapidEther.

02:26:21.320 --> 02:26:23.320
Да, непонятно почему.

02:26:23.320 --> 02:26:25.320
Или...

02:26:25.320 --> 02:26:27.320
А, ну это я сейчас...

02:26:27.320 --> 02:26:29.320
Это я с контрактом.

02:26:29.320 --> 02:26:31.320
Значит, как вот эти вот штуки сделаны?

02:26:31.320 --> 02:26:34.320
ERC-721, ERC-1155, короче говоря.

02:26:34.320 --> 02:26:35.320
Как вот эти трансферы сделаны?

02:26:35.320 --> 02:26:43.320
Как вы думаете, что парсит EtherScan для того, чтобы показать, как бы, что токены были переданы?

02:26:43.320 --> 02:26:47.320
Какие данные контракта?

02:26:47.320 --> 02:26:50.320
Вот он показывает все операции в RapidEther.

02:26:50.320 --> 02:26:56.320
Ну, там, все оперирования, как бы, в RapidEther.

02:26:56.320 --> 02:26:58.320
Либо транзакции, либо его лог.

02:26:58.320 --> 02:27:02.320
Ну, правильный ответ именно лог.

02:27:02.320 --> 02:27:04.320
То есть, на самом деле, как бы, не транзакции.

02:27:04.320 --> 02:27:11.320
А вот то, что мы с вами как раз говорили вот про вот эти вот ивенты.

02:27:11.320 --> 02:27:16.320
В стандарте токена записано, что после того, как токены были переданы,

02:27:16.320 --> 02:27:21.320
в случае успеха обязательно в логе должно появляться вот такое событие определенного вида,

02:27:21.320 --> 02:27:27.320
которое называется трансфер с параметрами от кого, кому и какое количество.

02:27:27.320 --> 02:27:28.320
Вот.

02:27:28.320 --> 02:27:31.320
EtherScan, по сути, как бы, висит постоянно на блокчейне,

02:27:31.320 --> 02:27:33.320
постоянно слушает вот эти вот события трансфера.

02:27:33.320 --> 02:27:35.320
Из разных токенов.

02:27:35.320 --> 02:27:38.320
И как только такое событие встречает,

02:27:38.320 --> 02:27:42.320
он, соответственно, у нас вот здесь вот эту транзакцию показывает.

02:27:42.320 --> 02:27:46.320
Там сохраняет, индексирует, там, и так далее, и так далее.

02:27:46.320 --> 02:27:49.320
Все для этого, как бы, нужны ивенты.

02:27:49.320 --> 02:27:51.320
Вот.

02:27:51.320 --> 02:27:53.320
Ну, какой там еще, может, там...

02:27:53.320 --> 02:27:55.320
Еще может какой-нибудь токен показать.

02:27:55.320 --> 02:27:57.320
Ну, точнее, если... Давайте вот так вот.

02:27:57.320 --> 02:28:02.320
Авиа V2, лендинг пулк.

02:28:02.320 --> 02:28:05.320
Ну, это такой, как бы, большой очень...

02:28:05.320 --> 02:28:09.320
Очень большой контракт здоровый.

02:28:11.320 --> 02:28:15.320
Вот так, сейчас я найду implementation.

02:28:15.320 --> 02:28:17.320
Implementation должно быть здесь.

02:28:17.320 --> 02:28:19.320
Прокси.

02:28:19.320 --> 02:28:21.320
Не, ладно, посмотрим.

02:28:24.320 --> 02:28:26.320
Так, не авиа...

02:28:26.320 --> 02:28:28.320
Под словом токен, что имеется в виду?

02:28:28.320 --> 02:28:29.320
А?

02:28:29.320 --> 02:28:31.320
Под словом токен, что имеется в виду?

02:28:32.320 --> 02:28:36.320
Мы с вами активно это разберем.

02:28:36.320 --> 02:28:39.320
Прям контракт токена будем здорово разбирать.

02:28:39.320 --> 02:28:43.320
По сути, под словом токеном подразумевается контракт,

02:28:43.320 --> 02:28:46.320
в котором есть функция transfer,

02:28:46.320 --> 02:28:49.320
в котором есть функция balance.

02:28:49.320 --> 02:28:50.320
Balance...

02:28:50.320 --> 02:28:52.320
Balance of.

02:28:52.320 --> 02:28:55.320
Есть стандарт, который говорит, какие функции должны быть там.

02:28:55.320 --> 02:28:57.320
Transfer from.

02:28:57.320 --> 02:28:58.320
Там есть несколько функций.

02:28:58.320 --> 02:29:01.320
Есть прям стандарт, который называется ERC20.

02:29:01.320 --> 02:29:04.320
Вот прям, по сути, как бы стандарт, который говорит,

02:29:04.320 --> 02:29:07.320
что контракт токена должен иметь вот эти функции,

02:29:07.320 --> 02:29:09.320
а работает он следующим образом.

02:29:09.320 --> 02:29:12.320
Он, по сути, изображает из себя, как бы, криптовалюту.

02:29:12.320 --> 02:29:13.320
В точности, как эфир.

02:29:13.320 --> 02:29:16.320
То есть, токен это такой минимальный, как бы, контракт,

02:29:16.320 --> 02:29:20.320
который говорит, что у Васи там 100 токенов,

02:29:20.320 --> 02:29:24.320
а у Пети там 200 токенов.

02:29:24.320 --> 02:29:26.320
В своем сторидже.

02:29:26.320 --> 02:29:28.320
Вот это вот очень важно, как бы.

02:29:28.320 --> 02:29:30.320
То, что он, как бы, эти балансы держит.

02:29:31.320 --> 02:29:33.320
В своем сторидже.

02:29:33.320 --> 02:29:36.320
И когда делается трансфер, соответственно, там,

02:29:36.320 --> 02:29:39.320
у Васи там списали 20, этому добавили 20.

02:29:39.320 --> 02:29:42.320
Пишет этот токен программист.

02:29:42.320 --> 02:29:43.320
Вот.

02:29:43.320 --> 02:29:46.320
Но зато все, как бы, могут зайти в этот контракт

02:29:46.320 --> 02:29:48.320
и убедиться, что у него здесь в трансфере нету, там,

02:29:48.320 --> 02:29:52.320
какого-нибудь трояна, который позволит ему взять, короче,

02:29:52.320 --> 02:29:55.320
и у кого угодно, там, не знаю, токены на свой адрес перевести,

02:29:55.320 --> 02:29:56.320
утащить, как бы.

02:29:56.320 --> 02:29:58.320
Есть, как бы, и такие затроянные токены.

02:29:58.320 --> 02:30:01.320
То есть, это контракт, который удовлетворяет вот этим,

02:30:01.320 --> 02:30:04.320
как бы, стандартам и ведет себя, как криптовалюта.

02:30:04.320 --> 02:30:07.320
Ну, то есть, у него есть балансы, как бы, представляет собой,

02:30:07.320 --> 02:30:09.320
там, что-то типа, там, денег и так далее.

02:30:09.320 --> 02:30:13.320
Вот на этих токенах строится практически вся, как бы,

02:30:13.320 --> 02:30:14.320
экосистема.

02:30:14.320 --> 02:30:17.320
Такой, как бы, базовый кирпичик, из которого это строится.

02:30:17.320 --> 02:30:18.320
Вот.

02:30:18.320 --> 02:30:21.320
Мы будем, будем очень подробно, как бы, про это смотреть.

02:30:21.320 --> 02:30:23.320
Вот.

02:30:23.320 --> 02:30:29.320
Это, по сути, ну, как бы, когда, как бы, эфир появился,

02:30:29.320 --> 02:30:36.320
начались же вот это, началась эпоха, как бы, ICO, краудфандинга.

02:30:36.320 --> 02:30:40.320
И ICO-шный контракт, он обычно работал следующим образом.

02:30:40.320 --> 02:30:45.320
То есть, есть какая-то цена, например, ну, например,

02:30:45.320 --> 02:30:51.320
я говорю, я делаю специальную криптовалюту, токен, значит,

02:30:51.320 --> 02:30:54.320
у кого есть один токен, то, значит, один час, как бы,

02:30:54.320 --> 02:30:57.320
может на моих, там, самокатах кататься.

02:30:57.320 --> 02:30:58.320
Вот.

02:30:58.320 --> 02:31:00.320
Токен равно один час, как бы, на моих самокатах.

02:31:00.320 --> 02:31:03.320
И пытаюсь убедить людей накидать мне на это денег.

02:31:03.320 --> 02:31:08.320
Я создаю цену, там, цена, которая делает, как бы,

02:31:08.320 --> 02:31:11.320
эфир на мой, там, какой-нибудь самокат-токен.

02:31:11.320 --> 02:31:12.320
Вот.

02:31:12.320 --> 02:31:16.320
Приходит чувак, кидает, как бы, десять эфира, хочет

02:31:16.320 --> 02:31:20.320
очень кататься на самокате, и в ответ, и мой вот этот

02:31:20.320 --> 02:31:23.320
вот смарт-контракт, то есть он там вызывает функцию

02:31:23.320 --> 02:31:26.320
депозит, короче говоря, или там функцию, там, какую-нибудь,

02:31:26.320 --> 02:31:27.320
или просто, там, отправляет, как бы, эфир.

02:31:27.320 --> 02:31:30.320
Это тоже, как бы, программируется.

02:31:30.320 --> 02:31:34.320
И когда он, соответственно, эту функцию вызывает, в

02:31:34.320 --> 02:31:37.320
ответ я ему в сторидже создаю запись.

02:31:37.320 --> 02:31:41.320
Там, это опять Вася у нас, как бы, тебе, Вася, значит,

02:31:41.320 --> 02:31:43.320
дорогой друг, двадцать токенов.

02:31:43.320 --> 02:31:44.320
Сам.

02:31:44.320 --> 02:31:47.320
Как бы, и Вася у себя, как бы, видит в метамаске,

02:31:47.320 --> 02:31:50.320
что у меня двадцать токенов сам теперь.

02:31:50.320 --> 02:31:53.320
А десять эфира, как бы, ушли, легли на баланс, как бы,

02:31:53.320 --> 02:31:56.320
вот этого, на баланс этого проекта.

02:31:56.320 --> 02:31:58.320
В принципе, Вася может и обратно сказать, так,

02:31:58.320 --> 02:32:00.320
все, я передумал, хочу withdraw.

02:32:00.320 --> 02:32:03.320
Я тебе отправляю, как бы, двадцать токенов сам,

02:32:03.320 --> 02:32:05.320
а ты мне возвращай мои десять эфира.

02:32:05.320 --> 02:32:07.320
И там до определенного момента это возможно.

02:32:07.320 --> 02:32:14.320
А потом VCO, как бы, появил, ну, то есть сам контракт

02:32:14.320 --> 02:32:15.320
является токеном.

02:32:15.320 --> 02:32:18.320
То есть кто угодно может прийти, как бы, и спросить,

02:32:18.320 --> 02:32:23.320
какой баланс, какой балансов у Васи.

02:32:23.320 --> 02:32:24.320
И он ответит.

02:32:24.320 --> 02:32:25.320
Вот.

02:32:25.320 --> 02:32:26.320
И он ответит.

02:32:26.320 --> 02:32:28.320
У Васи двадцать токенов.

02:32:28.320 --> 02:32:32.320
Могу, кстати говоря, это даже продемонстрировать.

02:32:32.320 --> 02:32:36.320
У меня в метамаске есть какие-то активы.

02:32:36.320 --> 02:32:38.320
В тестовой сети.

02:32:38.320 --> 02:32:40.320
Нет, по-моему, в тестовой нету.

02:32:40.320 --> 02:32:42.320
Может, в Ринкебе есть.

02:32:42.320 --> 02:32:43.320
Вот.

02:32:43.320 --> 02:32:45.320
У меня тут много разных токенов.

02:32:45.320 --> 02:32:47.320
Каких-то там многих.

02:32:47.320 --> 02:32:49.320
Вот есть Юни.

02:32:49.320 --> 02:32:52.320
Токен, сейчас посмотрим на него.

02:32:52.320 --> 02:32:54.320
Вот он, контракт этого Юни.

02:32:55.320 --> 02:32:56.320
Токена.

02:32:56.320 --> 02:33:00.320
То есть вот он прям с его там трансфер, депозит.

02:33:00.320 --> 02:33:02.320
Вот они все его там эти функции.

02:33:02.320 --> 02:33:07.320
И я могу спросить, а сколько вот у этого чувака, возьму

02:33:07.320 --> 02:33:12.320
свой адрес, вот у этого парня, 0FD, короче говоря,

02:33:12.320 --> 02:33:15.320
сколько у него токенов, балансов.

02:33:15.320 --> 02:33:16.320
Вот я ввожу.

02:33:16.320 --> 02:33:19.320
Это как раз вот эти самые view функции читающие.

02:33:19.320 --> 02:33:21.320
Спрашиваю, он мне возвращает.

02:33:21.320 --> 02:33:22.320
У него шестнадцать токенов.

02:33:22.320 --> 02:33:23.320
Вот.

02:33:23.320 --> 02:33:26.320
Здесь видит шестнадцать и еще вот семнадцать знаков

02:33:26.320 --> 02:33:27.320
после запятой.

02:33:27.320 --> 02:33:28.320
Decimals.

02:33:28.320 --> 02:33:29.320
Вот.

02:33:29.320 --> 02:33:32.320
Я правильно понимаю, что дробные числа в блокчейне

02:33:32.320 --> 02:33:35.320
представляются как числа с фиксированной точкой?

02:33:35.320 --> 02:33:36.320
Да.

02:33:36.320 --> 02:33:39.320
Я как раз про это на прошлой лекции говорил.

02:33:39.320 --> 02:33:43.320
То есть нету никаких дробных чисел в блокчейне вообще.

02:33:43.320 --> 02:33:47.320
Даже там проценты, они все равно как бы представляются

02:33:47.320 --> 02:33:51.320
как бы, как вот такие вот целые, целые там по большей

02:33:51.320 --> 02:33:52.320
части беззнаковые числа.

02:33:52.320 --> 02:33:53.320
Вот.

02:33:53.320 --> 02:33:54.320
Это все как бы из-за детерминизма.

02:33:54.320 --> 02:33:55.320
То есть вы не можете операции нативные с FPU, но с плавающей

02:33:55.320 --> 02:33:56.320
точкой проводить как бы на разных процессорах

02:33:56.320 --> 02:33:57.320
с одними и теми же результатами.

02:33:57.320 --> 02:33:58.320
Вот он.

02:33:58.320 --> 02:33:59.320
Поэтому под это есть специальный библиотек.

02:33:59.320 --> 02:34:00.320
Поэтому все токены, все криптовалюты, биткоины,

02:34:00.320 --> 02:34:01.320
эфиры, короче говоря, какие не возьмете, как бы они

02:34:01.320 --> 02:34:02.320
все вот так выглядят под капотом.

02:34:02.320 --> 02:34:03.320
Как целые, которые вы делите, как бы вы делите.

02:34:03.320 --> 02:34:04.320
Вот.

02:34:04.320 --> 02:34:05.320
Вот.

02:34:05.320 --> 02:34:06.320
Вот.

02:34:06.320 --> 02:34:07.320
Вот.

02:34:07.320 --> 02:34:08.320
Вот.

02:34:08.320 --> 02:34:09.320
Вот.

02:34:09.320 --> 02:34:10.320
Вот.

02:34:10.320 --> 02:34:11.320
Вот.

02:34:11.320 --> 02:34:12.320
Вот.

02:34:12.320 --> 02:34:13.320
Вот.

02:34:13.320 --> 02:34:14.320
Вот.

02:34:14.320 --> 02:34:15.320
Вот.

02:34:15.320 --> 02:34:16.320
Вот.

02:34:16.320 --> 02:34:17.320
Вот.

02:34:17.320 --> 02:34:18.320
Вот.

02:34:18.320 --> 02:34:19.320
Вот.

02:34:19.320 --> 02:34:20.320
Вот.

02:34:20.320 --> 02:34:21.320
Вот.

02:34:21.320 --> 02:34:22.320
Вот.

02:34:22.320 --> 02:34:23.320
Вот.

02:34:23.320 --> 02:34:24.320
Вот.

02:34:24.320 --> 02:34:25.320
Вот.

02:34:25.320 --> 02:34:26.320
Вот.

02:34:26.320 --> 02:34:27.320
Вот.

02:34:27.320 --> 02:34:28.320
Вот.

02:34:28.320 --> 02:34:29.320
Вот.

02:34:29.320 --> 02:34:30.320
Вот.

02:34:30.320 --> 02:34:31.320
Вот.

02:34:31.320 --> 02:34:32.320
Вот.

02:34:32.320 --> 02:34:33.320
Вот.

02:34:33.320 --> 02:34:34.320
Вот.

02:34:34.320 --> 02:34:35.320
Вот.

02:34:35.320 --> 02:34:36.320
Вот.

02:34:36.320 --> 02:34:37.320
Вот.

02:34:37.320 --> 02:34:38.320
Вот.

02:34:38.320 --> 02:34:39.320
Вот.

02:34:39.320 --> 02:34:40.320
Вот.

02:34:40.320 --> 02:34:41.320
Вот.

02:34:41.320 --> 02:34:42.320
Вот.

02:34:42.320 --> 02:34:43.320
Вот.

02:34:43.320 --> 02:34:44.320
Вот.

02:34:44.320 --> 02:34:45.320
Вот.

02:34:45.320 --> 02:34:46.320
Вот.

02:34:46.320 --> 02:34:47.320
Вот.

02:34:47.320 --> 02:34:48.320
Вот.

02:34:48.320 --> 02:34:49.320
Вот.

02:34:49.320 --> 02:34:56.400
то есть насколько минимально он делится вот соответственно этого да что касается как бы

02:34:56.400 --> 02:35:02.860
контракта токина ну а дальше вася была просто функция как бы которая говорит

02:35:02.860 --> 02:35:12.240
там типа забрать все деньги ты потом там три колма не и которая выводила весь эфир

02:35:12.240 --> 02:35:18.700
который выкидали там куча вас как бы это куча этого эфира они отдавали как бы владельцу тому

02:35:18.700 --> 02:35:23.060
кто-то контракт создал и вообще решил там самокатами заниматься но при этом в этой

02:35:23.060 --> 02:35:28.780
функции прям публично можно было представить смарт-контракте написано типа если время как

02:35:28.780 --> 02:35:37.940
бы меньше чем там декабрь короче 2018 года идите нафиг как бы эфир до этого времени я забыл забрать

02:35:37.940 --> 02:35:44.800
если баланс короче говоря меньше чем 1000 эфира то есть если как бы мне накидали денег меньше чем

02:35:44.800 --> 02:35:48.680
1000 эфира как бы все идите нафиг как бы то есть можете забрать свои деньги как

02:35:48.680 --> 02:35:54.620
бы и выйти из если они не наберу на свой проект 1000 эфира на запах самокатов то как бы извините

02:35:54.620 --> 02:36:02.740
вот такой как бы как этот kickstarter по сути как бы просто аналог kickstarter и как бы но

02:36:02.740 --> 02:36:09.500
написанный в виде по 1 смарт-контракта при этом у тех кто как бы участвует у них остаются вот эти

02:36:09.500 --> 02:36:15.740
вот токены баланса как бы они ими могут дальше пользоваться там как угодно и там уже миллион

02:36:15.740 --> 02:36:18.480
идей там типа этими токи нами расплачиваться там за

02:36:18.680 --> 02:36:27.060
не знаю там еще там смотреть там кино короче говоря собирать краудфандинг на создание фильма здесь

02:36:27.060 --> 02:36:33.060
можно тоже конечно куча всяких идей там всякие там и scroll какие-нибудь там знаменитые люди которые

02:36:33.060 --> 02:36:38.360
будут ставить галочки типа прошел ли проект на следующую стадию на следующей стадии можно ли

02:36:38.360 --> 02:36:44.920
ему там достать следующий кусок из этих фамилий то есть очень много всего было сделано и сама идея как

02:36:48.680 --> 02:36:55.340
ничего можно просто краудфандинг заниматься не выходя вообще никуда из эфира вот очень просто

02:36:55.340 --> 02:37:01.580
как бы и проекта на этом многие там миллиард собрали понятно что трэша там было очень много

02:37:01.580 --> 02:37:10.240
то что такое такая свобода просто конечно не дается вот это значит что касается там токенов

02:37:10.240 --> 02:37:18.660
и а из рассказа давайте посмотрим теперь собственно как наверное уже немножечко прям зацепим как бы

02:37:18.680 --> 02:37:27.900
разработку в которой вам придется довольно много работать я в общем-то показываю такой движок такой

02:37:27.900 --> 02:37:34.920
фреймворк который называется hard head это для тех кто любит больше java script чем питон вот

02:37:34.920 --> 02:37:42.980
для тех кто любит больше питон как бы есть очень похожий фреймворк называется брауни вот у меня есть

02:37:42.980 --> 02:37:45.800
hard head потому что там есть там демонстрации некоторых всяких штук

02:37:48.680 --> 02:37:54.560
по сути представьте что я просто решил как бы создать свой контракт не знаю там токина который

02:37:54.560 --> 02:38:00.860
просто чуть-чуть поумнее там у него там не знаю что он берет комиссии там еще что-нибудь у меня

02:38:00.860 --> 02:38:09.020
есть вот этот oversight hard head этоisiónет желестный короче там этот package Zlojko это

02:38:09.020 --> 02:38:12.900
качество называется значит он позволит вам на вашем компьютере вам на вашем компьютере

02:38:13.580 --> 02:38:16.320
хорошо свет сатру

02:38:18.680 --> 02:38:24.320
он на вашем компьютере поднимает но до такую как бы девелоперскую свою собственную которая

02:38:24.320 --> 02:38:33.980
вроде бы как как бы манит блоки вы пишете как бы смарт-контракт этот смарт-контракт затем

02:38:33.980 --> 02:38:40.820
выполняете как бы java скриптовый тест в этом java скриптовом тесте есть диплой этого контракта

02:38:40.820 --> 02:38:48.620
вы это диплой как бы дипло из вот это вот как бы в игрушечный эфир в этом же как бы внутреннем

02:38:48.620 --> 02:38:54.800
в этом скрипте как бы вы станете владельцем адреса на котором есть много много эфира 100 миллионов

02:38:54.800 --> 02:39:02.600
там такой там эфира вы можете здесь же притвориться любым другим адресом в обчине то есть стать как

02:39:02.600 --> 02:39:06.940
бы им там полезно не знаю изменить старич контракты так далее там возможности очень

02:39:06.940 --> 02:39:10.820
много вот на по сути вы можете сделать диплой какой как вот в этом

02:39:10.820 --> 02:39:16.040
виртуальную ноду а потом начать соответственно делать различные вызовы там тесты как бы и так

02:39:16.040 --> 02:39:20.780
далее то есть работать ровно так как он будет работать в блокчейне ваш контракт то есть

02:39:20.780 --> 02:39:27.620
проводить тесты в такой локальный девелопер ноде вот штука крайне удобно ее как бы легко

02:39:27.620 --> 02:39:34.460
запускать как бы и легко программировать сидишь в двух файлах один файл пишешь на солидите второй

02:39:34.460 --> 02:39:39.380
как бы тест на джейсе и в общем то никуда как бы из этой штуки не выходишь как бы тебе ни эфир

02:39:39.380 --> 02:39:40.800
не нужен никакой там не будет

02:39:40.800 --> 02:39:46.560
блокчейн как бы не криптовалюта просидишься в локальном окружении она достаточно удобно и

02:39:46.560 --> 02:39:53.760
а сам hard head как бы и брауни и последние фреймворки чем они круты тем что вот вместо

02:39:53.760 --> 02:40:02.840
вот этого вместо вот этого я могу прицепить майнет начиная с любого блока то есть я могу

02:40:02.840 --> 02:40:10.560
сказать внутри вот этого своего теста джества я хочу сказать я могу сказать так возьми пожалуйста

02:40:10.800 --> 02:40:18.180
как бы ford не сделай прям копию боевого эфира начиная с блока там такого-то такого-то прям вот

02:40:18.180 --> 02:40:26.400
в точности вот прям полностью его состоянии после этого я хочу стать васей вот прям причем реальным

02:40:26.400 --> 02:40:34.440
васи вот прям вот отсюда то есть реальным васи который вот здесь вот там славки это транзакции

02:40:34.440 --> 02:40:39.120
там так далее хочу стать вот этим вот адресом что у меня на балансе был эфир как бы вот такие вот

02:40:40.800 --> 02:40:47.560
то есть ты становишься как вот этим вот адресом он тебя имперсонирует и после этого ты делаешь

02:40:47.560 --> 02:40:53.160
там любые вызовы делаешь либо чего хочешь там эмулируешь работу там с любым протоколом и он

02:40:53.160 --> 02:40:59.100
тебе исполняет это в таком как бы в блокчейне который от почковывается от майонета то есть

02:40:59.100 --> 02:41:05.400
там никого кроме тебя нету как бы и ты там делаешь что хочешь именно в этом кроется как раз причина

02:41:10.800 --> 02:41:16.440
то есть почему как бы здесь хаки такие частые как бы почему хаки такие как бы там большие почему

02:41:16.440 --> 02:41:21.300
как бы хакерам здесь так фривольно потому что у них есть именно вот это вот возможность они

02:41:21.300 --> 02:41:28.320
могут сказать взять в прям в текущем виде как бы прям протокол где лежит там не знаю там 100

02:41:28.320 --> 02:41:33.800
миллионов долларов на разных и в депозитах прикинуться там таким-то как бы участникам

02:41:33.800 --> 02:41:39.540
или просто взойти как бы новым участникам и полностью про эмулировать как бы все атаку там

02:41:40.800 --> 02:41:47.380
со практически со стопроцентной вероятность то есть все данные готовы как бы все состояние

02:41:47.380 --> 02:41:52.680
контракта все будет воспроизведено со стопроцентной точностью не считая конечно то что здесь

02:41:52.680 --> 02:41:58.200
пользователем могут видеть как бы транзакции за это время helping этого не увидит но для так это

02:41:58.200 --> 02:42:03.360
как вне суть то есть вы можете воспроизвести любой контракт в майонете прямо вот в его

02:42:03.360 --> 02:42:09.300
пол к чистом в виде со стопроцентной точностью без особых проблем как это позволяет сделать

02:42:09.300 --> 02:42:10.700
там тоже несколько строчек и то

02:42:10.800 --> 02:42:14.100
Это мега удобно для тестирования.

02:42:15.160 --> 02:42:18.060
У меня здесь есть контракт, их там несколько.

02:42:18.380 --> 02:42:20.040
У меня есть там контракт токена.

02:42:21.040 --> 02:42:23.040
Вот, он такой достаточно как бы тупой.

02:42:23.040 --> 02:42:25.580
Так, давайте я лучше с подсветочкой как-нибудь.

02:42:27.780 --> 02:42:29.980
Так, это тест, это тест.

02:42:30.360 --> 02:42:33.040
Давайте контракт с токеном.

02:42:36.240 --> 02:42:37.680
Так, промахнулся.

02:42:37.680 --> 02:42:40.660
У меня тут много их.

02:42:40.920 --> 02:42:45.940
Ну, соответственно, там солидити указывается версия, как бы солидити.

02:42:46.360 --> 02:42:49.000
Там импорт это относится только к хардкату,

02:42:49.000 --> 02:42:54.140
который дает суперскую возможность писать в консоль из контрактов,

02:42:54.280 --> 02:42:57.720
потому что так-то, когда вы там тестите контракты в блокчейне,

02:42:57.780 --> 02:43:01.420
конечно, там ни консоли нет, ничего, никакого вывода, ничего такого.

02:43:02.900 --> 02:43:05.160
Я писал название своего токена.

02:43:06.680 --> 02:43:07.000
Вот этот мой...

02:43:07.680 --> 02:43:10.200
Public name, по сути, превратился в getter,

02:43:10.460 --> 02:43:11.800
то есть такую функцию name,

02:43:12.000 --> 02:43:14.080
которая возвращает как бы вот такое название,

02:43:14.300 --> 02:43:15.280
my hard hat token.

02:43:15.420 --> 02:43:16.660
Мы уже такой getter видели,

02:43:17.020 --> 02:43:19.320
когда смотрели с вами в rapid эфир.

02:43:21.120 --> 02:43:22.060
Так, где он там?

02:43:23.760 --> 02:43:26.520
Вот, в rapid эфир, как бы, когда мы его смотрели с вами,

02:43:26.620 --> 02:43:28.920
у него тоже можно спросить, как бы, какой у тебя name,

02:43:29.040 --> 02:43:31.140
как бы он возвращает имя в rapid ether.

02:43:32.280 --> 02:43:33.520
Вот такое неявное.

02:43:34.020 --> 02:43:35.640
Очень похоже все-все на OOP.

02:43:35.840 --> 02:43:37.520
Значит, описали, кто владелец данного контракта,

02:43:37.680 --> 02:43:40.680
это, в общем, владельцем будет тот, кто его задеплоил,

02:43:40.780 --> 02:43:43.080
то есть тот, кто отправил транзакцию создать токен,

02:43:43.180 --> 02:43:44.980
как бы он станет олднером.

02:43:45.080 --> 02:43:50.580
И у меня есть просто ассоциативный массив, там dict, как в питоне,

02:43:50.680 --> 02:43:54.780
который эфириумный адрес отображает uint-256.

02:43:54.880 --> 02:43:58.980
uint-256, привыкайте, как бы это будет вообще любимый тип данных ваших.

02:43:59.080 --> 02:44:04.460
Вот, который говорит, у вас есть 100 токенов, у Пети 200 токенов и так далее.

02:44:04.560 --> 02:44:07.460
Вот прям вот примитивно совершенно.

02:44:07.680 --> 02:44:09.680
Затем у меня есть конструктор.

02:44:09.780 --> 02:44:12.680
Когда я буду деплоить этот контракт, у меня пропишется,

02:44:12.780 --> 02:44:15.680
что у того, кто создал данный контракт,

02:44:15.780 --> 02:44:20.680
у него будет вот столько-то токенов, total supply,

02:44:20.780 --> 02:44:22.680
вот сколько у него будет здесь соответственно,

02:44:22.780 --> 02:44:25.680
один миллион токенов, я его сделал, как будто переменную.

02:44:25.780 --> 02:44:28.680
То есть все вот эти токены будут на моем балансе,

02:44:28.780 --> 02:44:30.680
когда я это задеплою.

02:44:30.780 --> 02:44:32.680
То есть я буду их владельцем.

02:44:32.780 --> 02:44:34.680
И я же буду владельцем данного контракта.

02:44:34.780 --> 02:44:36.680
Если у меня будут какие-то админские функции,

02:44:36.780 --> 02:44:37.680
которые будут,

02:44:37.780 --> 02:44:38.680
которые только для Овнер,

02:44:38.780 --> 02:44:40.680
я могу в них делать проверку,

02:44:40.780 --> 02:44:44.680
типа что транзакцию отправил только вот этот чувак Овнер.

02:44:44.780 --> 02:44:47.680
Вот эти вещи, опять же, в Solidity,

02:44:47.780 --> 02:44:52.680
то есть почему похоже на JavaScript,

02:44:52.780 --> 02:44:54.680
но на самом деле совсем не то программирование,

02:44:54.780 --> 02:44:56.680
потому что на самом деле вот это не явно,

02:44:56.780 --> 02:44:58.680
это запись storage.

02:44:58.780 --> 02:45:00.680
То есть то, что я здесь присваиваю переменные,

02:45:00.780 --> 02:45:01.680
это просто для удобства,

02:45:01.780 --> 02:45:06.680
а на самом деле здесь происходит именно запись в переменной storage,

02:45:06.780 --> 02:45:12.680
потому что описанные вот здесь переменные глобальные для всего этого класса контракта,

02:45:12.780 --> 02:45:17.680
они в общем по дефолту отправляются в storage.

02:45:17.780 --> 02:45:19.680
То есть это не временные какие-то переменные.

02:45:19.780 --> 02:45:21.680
Стоит мне изменить total supply,

02:45:21.780 --> 02:45:26.680
и с меня спишут там сколько-то тысяч газа за запись в storage,

02:45:26.780 --> 02:45:30.680
и это изменится в блокчейне, если транзакция пройдет.

02:45:30.780 --> 02:45:33.680
Затем функция transfer.

02:45:33.780 --> 02:45:35.680
Я же хочу, чтобы у меня был токен,

02:45:35.680 --> 02:45:36.680
совместимый с кошельками,

02:45:36.780 --> 02:45:38.680
чтобы они знали, какую функцию дергать,

02:45:38.780 --> 02:45:40.680
поэтому у меня функция такая, как и у других.

02:45:40.780 --> 02:45:43.680
Принимает адрес, называется transfer.

02:45:43.780 --> 02:45:47.680
Сначала она проверяет, что у меня достаточно токенов,

02:45:47.780 --> 02:45:49.680
чтобы сделать этот перевод.

02:45:49.780 --> 02:45:51.680
А что означает external?

02:45:51.780 --> 02:45:54.680
External то же самое, что public.

02:45:54.780 --> 02:45:58.680
Тоже будем разбирать.

02:45:58.780 --> 02:46:01.680
Посчитайте, что это как бы то же самое, что и public,

02:46:01.780 --> 02:46:03.680
как бы просто чуть лучше работает,

02:46:03.780 --> 02:46:05.580
если эта функция...

02:46:05.680 --> 02:46:08.680
Вызывается только снаружи исключительно,

02:46:08.780 --> 02:46:10.680
то есть как бы только в транзакциях.

02:46:10.780 --> 02:46:15.680
Public работает лучше, если она еще и вызывается из других контрактов.

02:46:15.780 --> 02:46:18.680
Газа потребляет меньше.

02:46:18.780 --> 02:46:22.680
Значит, require это типа ассерта.

02:46:22.780 --> 02:46:26.680
Здесь есть, кстати, и ассерт, но типовая как бы это require.

02:46:26.780 --> 02:46:30.680
История такая же, как и в программировании,

02:46:30.780 --> 02:46:33.680
там на C, на C++.

02:46:33.680 --> 02:46:36.680
Если у вас вообще там логика в хламину как бы разломалась,

02:46:36.780 --> 02:46:38.680
и все там автум.

02:46:38.780 --> 02:46:41.680
А require это типа не хватает баланса.

02:46:41.780 --> 02:46:44.680
Все как бы, иди отсюда, произойдет реверт.

02:46:44.780 --> 02:46:48.680
То есть если не выполнится эта штука, то будет реверт.

02:46:48.780 --> 02:46:55.680
Затем консоль лог, которая кроме hardhat у вас не сработает.

02:46:55.780 --> 02:47:00.580
То есть вы, конечно, такой как бы не скомпилите ничем кроме hardhat.

02:47:00.680 --> 02:47:03.580
Вот такую как бы штуку в эфире.

02:47:03.680 --> 02:47:05.680
Потому что там нет никакой консоли как бы.

02:47:05.780 --> 02:47:08.680
Но это позволит нам подебажить как бы это дело.

02:47:08.780 --> 02:47:11.680
Ну и дальше прям все просто как бы.

02:47:11.780 --> 02:47:15.680
У sender удалили, сняли 100 токенов как бы,

02:47:15.780 --> 02:47:17.680
а recipient добавили.

02:47:17.780 --> 02:47:21.680
Еще тоже довольно важная как бы штука в смарт-контрактах,

02:47:21.780 --> 02:47:25.680
что в смарт-контрактах все, что не определено, то ноль.

02:47:25.780 --> 02:47:29.680
Вот все, что неизвестно что, короче говоря, вот оно ноль.

02:47:29.780 --> 02:47:31.680
Вот мы посылаем, короче, Пете,

02:47:31.680 --> 02:47:34.680
а у Пети как бы у него и адресы,

02:47:34.780 --> 02:47:38.680
он адрес там от балды какой-нибудь там рандомный назвал там.

02:47:38.780 --> 02:47:42.680
И вообще как бы у него там ни баланса, ничего нету.

02:47:42.780 --> 02:47:44.680
Что здесь будет как бы?

02:47:44.780 --> 02:47:48.680
На самом деле как бы по дефолту вот эта баланса 100 как бы будет равно нулю.

02:47:48.780 --> 02:47:51.680
К нулю прибавится имаунт как бы.

02:47:51.780 --> 02:47:55.680
И будет создана как бы запись в ассоциативном массиве как бы вот с этим вот имаунтом.

02:47:55.780 --> 02:47:59.680
То есть в этом плане как бы solidity как бы здесь достаточно все просто.

02:47:59.680 --> 02:48:01.680
Если что-то нету, то это ноль.

02:48:01.780 --> 02:48:03.680
Если что-то не вышло, как бы это ноль.

02:48:03.780 --> 02:48:07.680
Вы можете обратиться там к любому там адресу в памяти, куда угодно.

02:48:07.780 --> 02:48:09.680
Как бы никто вам по рукам бить не будет.

02:48:09.780 --> 02:48:12.680
Просто как бы отдадут вам ноль и все как бы.

02:48:12.780 --> 02:48:15.680
Это тоже сделано из-за детерминизма.

02:48:15.780 --> 02:48:17.680
У меня там тоже любимая фраза.

02:48:17.780 --> 02:48:20.680
Да, смарт-контракты должны исполняться детерминированно.

02:48:20.780 --> 02:48:24.680
То есть результаты как бы работы смарт-контракта должны быть детерминированы.

02:48:24.780 --> 02:48:26.680
Но они и ломаться даже должны быть детерминированно.

02:48:26.780 --> 02:48:29.580
То есть одна и та же ошибка на всех компьютерах,

02:48:29.680 --> 02:48:33.580
должна приводить ровно к одному и тому же результату.

02:48:33.680 --> 02:48:36.580
Это тоже достаточно важно.

02:48:36.680 --> 02:48:38.580
Ну и вот у меня функция balance of balance,

02:48:38.680 --> 02:48:41.580
которая просто возвращает баланс у аккаунта.

02:48:41.680 --> 02:48:46.580
Такой прям самый-самый дубовый-дубовый прям вообще в никакую как бы токен.

02:48:46.680 --> 02:48:49.580
Как я его, соответственно, тестирую?

02:48:49.680 --> 02:48:54.580
Здесь там фреймворк какой-то JavaScript для тестов.

02:48:54.680 --> 02:48:57.580
Chai там очень модный с каким-то describe'ами и так далее.

02:48:57.680 --> 02:48:59.580
С асинхронщиной с различными.

02:48:59.680 --> 02:49:04.580
Вот здесь уже можете упражняться, как вам нравится, как бы в этих тестах.

02:49:04.680 --> 02:49:08.580
Есть, соответственно, модификатор, что перед каждым тестом,

02:49:08.680 --> 02:49:11.580
который я буду запускать, должны выполниться следующие функции.

02:49:11.680 --> 02:49:15.580
И вот они нам достаточно интересны.

02:49:15.680 --> 02:49:19.580
То есть первое, как бы здесь используется библиотека ethers,

02:49:19.680 --> 02:49:24.580
которая позволяет работать с эфиром, там деплоить контракты, вызывать их там и так далее.

02:49:24.680 --> 02:49:27.580
Таких библиотек на самом деле в JS несколько.

02:49:27.680 --> 02:49:29.580
Есть web3.js.

02:49:29.680 --> 02:49:30.580
Есть ethers.

02:49:30.680 --> 02:49:32.580
Есть еще какие-то.

02:49:32.680 --> 02:49:34.580
Вот здесь используется ethers.

02:49:34.680 --> 02:49:40.580
Я делаю, так называемую, фабрику контрактов.

02:49:40.680 --> 02:49:46.580
То есть он возьмет мой токен .sol, вот этот мой как бы с алиэйти, скомпилит его

02:49:46.680 --> 02:49:51.580
и инициализирует такой как бы код, который сможет его в блокчейн как бы деплоить.

02:49:51.680 --> 02:49:58.580
Затем я возьму и вот этим вот переменным назначу значение getSigners.

02:49:58.580 --> 02:50:03.480
То есть это по сути там такой десяток синтетических аккаунтов, которые у меня будут созданы.

02:50:03.580 --> 02:50:08.480
То есть мне будет создан owner, у которого будет там 100 тысяч эфира на балансе,

02:50:08.580 --> 02:50:12.480
адрес 1 со 100 тысячами эфира на балансе, адрес 2,

02:50:12.580 --> 02:50:16.480
чтобы я мог изображать из себя как бы пользователя моего протокола.

02:50:16.580 --> 02:50:19.480
То есть у меня в тестах же, наверное, много участников.

02:50:19.580 --> 02:50:22.480
И поэтому как бы таким образом я это все инициализирую.

02:50:22.580 --> 02:50:26.480
Затем вызываю функцию deploy.

02:50:26.480 --> 02:50:28.380
Здесь все как бы асинхронное.

02:50:28.480 --> 02:50:34.380
То есть если я не сделаю как бы это wait, я получу promise на как бы на транзакцию,

02:50:34.480 --> 02:50:37.380
которую мне придется подождать.

02:50:37.480 --> 02:50:44.380
Вот тут я дождался, короче говоря, и теперь у меня, ну, соответственно,

02:50:44.480 --> 02:50:49.380
вот этот hardhat токен как бы будет задеплоен таким вот образом.

02:50:49.480 --> 02:50:55.380
Теперь как бы у меня перед каждым, перед каждым моим тестом будет выполняться

02:50:55.380 --> 02:50:57.280
вот эта вот штука.

02:50:57.380 --> 02:51:00.280
То есть я каждый раз перед каждым тестом буду заново деплоить свой токен.

02:51:00.380 --> 02:51:04.280
У меня вот в этой переменной будет лежать вот этот контракт.

02:51:04.380 --> 02:51:09.280
За меня будет сгенерирован вот это ABI, интерфейс к нему.

02:51:09.380 --> 02:51:14.280
То есть я теперь к этому токену смогу обращаться просто как в объектно-ориентированной штуке.

02:51:14.380 --> 02:51:20.280
То есть есть у него переменная owner публичная, вот она, она public.

02:51:20.380 --> 02:51:24.280
Значит, существует как бы getter публичный, вот такая вот функция как бы,

02:51:24.280 --> 02:51:27.180
которая будет возвращать значение вот этой переменной.

02:51:27.280 --> 02:51:34.180
И я, соответственно, могу как бы проверить то, что овнером стал как бы тот овнер,

02:51:34.280 --> 02:51:37.180
который деплоил этот контракт.

02:51:37.280 --> 02:51:43.180
Ну, там, ну, по дефолту вот здесь вот как бы он от адреса овнера и задеплоил.

02:51:43.280 --> 02:51:46.180
А теперь там протестируем там транзакции.

02:51:46.280 --> 02:51:52.180
То есть я беру как бы hardhat токен своего адреса овнера по дефолту,

02:51:52.180 --> 02:51:57.080
у которого там миллион этих токенов, на адрес 1 перевожу как бы 50 токенов.

02:51:57.180 --> 02:52:06.080
Затем как бы вызываю функцию balanceof и проверяю то, что баланс получателя стал равен 50.

02:52:06.180 --> 02:52:10.080
Вот, там, я по-моему, где-то тест запущен.

02:52:10.180 --> 02:52:16.080
Вот, можно, соответственно, посмотреть как бы то, что в трансфер вот этот мой консоль,

02:52:16.180 --> 02:52:20.080
консоль лог написал, что я перевожу вот с этого адреса на этот 50 токенов,

02:52:20.080 --> 02:52:22.980
и с этого на этот 50 токенов.

02:52:23.080 --> 02:52:24.980
Вот, ну и тесты там проходят.

02:52:25.080 --> 02:52:28.980
Понятно, что я могу здесь все вывести, там, все попечатать.

02:52:29.080 --> 02:52:33.980
Вот, затем точно так же теперь я как бы становлюсь адресом 1,

02:52:34.080 --> 02:52:38.980
то есть у которого 50 токенов, и пытаюсь их перевести на адрес 2.

02:52:39.080 --> 02:52:45.980
Вот, и, ну, ожидаю как бы, что на адресе 2 как бы теперь тоже будет 50 токенов.

02:52:46.080 --> 02:52:49.980
То есть там уже как бы пользователи начинают это делать.

02:52:50.080 --> 02:52:53.980
Дальше, соответственно, проверки как бы, что там все должно падать,

02:52:54.080 --> 02:52:55.980
если не хватает токенов.

02:52:56.080 --> 02:52:59.980
Да, там, адрес 1 теперь как бы токенов ноль как бы,

02:53:00.080 --> 02:53:01.980
а он кому-то пытается один токен перевести,

02:53:02.080 --> 02:53:04.980
и как бы тоже как бы все должно упасть.

02:53:05.080 --> 02:53:08.980
По сути это, да, такой как бы, не знаю, template как бы,

02:53:09.080 --> 02:53:11.980
если захотите как бы начать там разрабатывать.

02:53:12.080 --> 02:53:14.980
Здесь это, как видите, довольно несложно.

02:53:15.080 --> 02:53:18.980
При этом все, что мы здесь делаем, вообще не знаем, где там какой адрес,

02:53:18.980 --> 02:53:21.880
не знаем, где там какой-то там эфир, короче, какие-то блоки,

02:53:21.980 --> 02:53:23.880
что-то там майнится как бы и так далее.

02:53:23.980 --> 02:53:27.880
То есть пока вы не начнете тестировать какие-то более сложные паттерны,

02:53:27.980 --> 02:53:32.880
то есть когда там типа надо задепозитить, подождать пока пройдет там, не знаю, 30 дней,

02:53:32.980 --> 02:53:36.880
чтобы потом пришел как бы второй там какой-нибудь чувак, там третий,

02:53:36.980 --> 02:53:39.880
что будет, если несколько транзакций в один блок как бы затолкать,

02:53:39.980 --> 02:53:43.880
как бы как это все сделать, как бы, то здесь все достаточно просто.

02:53:43.980 --> 02:53:48.880
Вот, и учитывая небольшое, ну, там, например,

02:53:48.980 --> 02:53:52.880
там, да, что балансы должны все правильно апдейтиться, там, и так далее, и так далее.

02:53:52.980 --> 02:53:55.880
То есть здесь там куча всяких разных тестов.

02:53:55.980 --> 02:53:58.880
И если вы будете делать как бы курсовой проект,

02:53:58.980 --> 02:54:01.880
это именно как бы разработка смарт-контрактов на Solidity,

02:54:01.980 --> 02:54:07.880
то вот такой вот репозиторий, это, по сути, как раз то, что вы будете,

02:54:07.980 --> 02:54:09.880
то, что вы будете задавать.

02:54:09.980 --> 02:54:13.880
То есть вы мне будете как бы задавать линк на GitHub-репозиторий,

02:54:13.980 --> 02:54:18.880
там у вас в ритме будет описано, как его там поставить, запустить,

02:54:18.980 --> 02:54:21.880
короче, и что это вообще за проект, что он делает, вот.

02:54:21.980 --> 02:54:25.880
Возможно, как бы там во многих местах как бы очень мне хочется,

02:54:25.980 --> 02:54:30.880
чтобы прям в ритме был вот этот вот вывод в консоли,

02:54:30.980 --> 02:54:36.880
и чтобы там хоть какая-то, короче, вот такая вот инфа в консоли выводилась.

02:54:36.980 --> 02:54:39.880
А вот здесь, короче говоря, у нас там человек пришел,

02:54:39.980 --> 02:54:41.880
там, не знаю, зарегистрировал диплом.

02:54:41.980 --> 02:54:45.880
А вот здесь пришел там верифайер, короче, и подтвердил как бы этот диплом.

02:54:45.980 --> 02:54:48.880
А вот он его, значит, принес как бы проверяющим,

02:54:48.980 --> 02:54:53.880
как бы ему там вот это вот, у него вот это проверяют и так далее, и так далее.

02:54:53.980 --> 02:54:57.880
То есть чтобы вот эту вот трассу можно было более-менее так нормально

02:54:57.980 --> 02:55:00.880
как бы посмотреть в домашнем задании, вот.

02:55:00.980 --> 02:55:04.880
Ну, чтобы я мог заглянуть там, не знаю, там буквально там в тесты,

02:55:04.980 --> 02:55:08.880
посмотреть, насколько они полные, заглянуть в сам контракт,

02:55:08.980 --> 02:55:11.880
посмотреть, как бы насколько он полный.

02:55:11.980 --> 02:55:16.880
И желательно, если я как бы залипну с какими-нибудь версиями там Node.js там

02:55:16.980 --> 02:55:18.880
или там Brownie и так далее,

02:55:18.980 --> 02:55:22.880
я не могу запустить, что я хотя бы мог увидеть в ритме вашу трассу

02:55:22.980 --> 02:55:26.880
и исполнение как бы вашего теста.

02:55:26.980 --> 02:55:31.880
Этого, в принципе, уже как бы по большей части достаточно, вот,

02:55:31.980 --> 02:55:34.880
для того, чтобы сделать именно протокол работающий.

02:55:34.980 --> 02:55:38.880
Значит, я, мы там не будем особо сильно смотреть на то,

02:55:38.980 --> 02:55:41.880
насколько вы там красивые как бы интерфейсы нарисовали,

02:55:41.980 --> 02:55:46.880
но, конечно, если вы прям хотите делать там, не знаю, там NFT, там еще что-то, IPFS использовать,

02:55:46.980 --> 02:55:48.880
то, конечно, какие-то базовые вещи.

02:55:48.980 --> 02:55:52.880
Вы должны как бы показать, да, если у вас там JPEG заливаются как бы какие-то,

02:55:52.980 --> 02:55:56.880
ну, как бы их надо все-таки в браузере отобразить, вот.

02:55:56.980 --> 02:56:02.880
Но как бы на дизайн смотреть они будут точно как бы, скорее всего, именно на тесты.

02:56:02.980 --> 02:56:04.880
Вот, поэтому разработка довольно комфортная.

02:56:04.980 --> 02:56:08.880
Здесь сидишь себе как бы в нескольких, в нескольких файликах в Solidity как бы в тестах,

02:56:08.980 --> 02:56:11.880
гоняешь их как бы туда-сюда, вот.

02:56:11.980 --> 02:56:18.880
Особо это как бы не сильно требовательная штука, и можешь легко вот эту же историю,

02:56:18.980 --> 02:56:22.880
как бы попробовать прямо задеплоить в MyNet.

02:56:22.980 --> 02:56:29.880
То есть ты, ну, хардхед, как бы, так как вот эти вот функции, которые я здесь сделал, короче,

02:56:29.980 --> 02:56:36.880
вот этот вот деплой, по-хорошему, израилу своему неважно, куда как бы этот деплой делать.

02:56:36.980 --> 02:56:40.880
То есть вот эти все вот эти сложные как бы функции, выкладки,

02:56:40.980 --> 02:56:44.880
вы можете точно так же хардхед подключить прямо к реальному кошельку,

02:56:44.980 --> 02:56:48.880
ну, точнее, к не реальному кошельку, а как бы указать,

02:56:48.980 --> 02:56:54.880
что действуй вот с этого адреса, вот тебе публичный, вот тебе секретный ключ от этого адреса,

02:56:54.980 --> 02:57:00.880
на нем есть там сколько-то там боевого эфира, переключись на боевую сеть и иди как бы туда деплой.

02:57:00.980 --> 02:57:03.880
И, в общем-то, проекты так и деплоятся.

02:57:03.980 --> 02:57:07.880
То есть они выкладываются как раз вот при помощи хардхеда,

02:57:07.980 --> 02:57:10.880
здесь есть там специальный как бы JavaScript-овый сценарий,

02:57:10.980 --> 02:57:15.880
если вам надо там задеплоить там 3-4 контракта, правильно их инициализировать,

02:57:15.980 --> 02:57:18.880
то есть вы сделали как бы первый контракт, потом создали второй,

02:57:18.980 --> 02:57:23.880
во втором указали адрес первого, сказали он будет мной управлять, потом создали третий,

02:57:23.980 --> 02:57:27.880
то есть все вот это как бы удобно не в голове держать, да,

02:57:27.980 --> 02:57:31.880
а именно весь этот деплоймент как бы иметь вот здесь вот в тестах.

02:57:31.980 --> 02:57:33.880
Эта штука как бы крайне, крайне удобная.

02:57:33.980 --> 02:57:37.880
И можете это проделать на форке майнета,

02:57:37.980 --> 02:57:41.880
то есть попробовать просто весь сценарий боевой своего деплоя проверить

02:57:41.980 --> 02:57:46.880
прямо со 100% гарантией прямо на копии как бы текущего эфира,

02:57:46.980 --> 02:57:48.880
что все у вас сработает как бы,

02:57:48.980 --> 02:57:50.880
что у вас получится.

02:57:50.980 --> 02:57:53.880
Вот в этом плане разработка крайне удобная.

02:57:53.980 --> 02:58:00.880
Так, ну и, соответственно, там по поводу как бы общих тасков,

02:58:00.980 --> 02:58:07.880
мы много очень будем смотреть всяких разных проектов с вами там пересматривать, вот,

02:58:07.980 --> 02:58:11.880
но, конечно, хотелось бы, чтобы вы как бы почитали сами, что пишется.

02:58:11.980 --> 02:58:16.880
Скорее всего, вы прям сразу закопаетесь в тонны как бы проектов, посвященных финансам,

02:58:16.880 --> 02:58:22.780
там, положил, вынул деньги туда-сюда, у нас под это будут отдельные лекции,

02:58:22.880 --> 02:58:25.780
значит, как я сказал, финансы крайне популярные,

02:58:25.880 --> 02:58:28.780
потому что не надо выходить из эфира никуда.

02:58:28.880 --> 02:58:32.780
Все, как бы, у тебя есть DAB, у тебя, у пользователей есть метамаски,

02:58:32.880 --> 02:58:34.780
у тебя есть смарт-контракты, все.

02:58:34.880 --> 02:58:37.780
Все остальное как бы это уже такая аналитическая обстройка,

02:58:37.880 --> 02:58:41.780
как бы она может там существовать по сути как бы самостоятельно, вот.

02:58:41.880 --> 02:58:45.780
Это мега удобно, работа с финансами, как бы.

02:58:45.780 --> 02:58:49.680
Поэтому они и победили как бы сейчас, пока что, вот.

02:58:49.780 --> 02:58:56.680
А так-то как бы среди тем, которые там, я считаю, как бы крайне перспективными,

02:58:56.780 --> 02:59:01.680
это вообще как бы создание DAO, то есть создание как бы на смарт-контрактах

02:59:01.780 --> 02:59:06.680
таких организаций, ну, по сути, смарт-контракты, управляющие конкретными бизнесами, вот.

02:59:06.780 --> 02:59:10.680
Потому что у каждого бизнеса есть своя собственная там специфика, там, DAO для,

02:59:10.780 --> 02:59:15.680
там, не знаю, для доставки дронами, как бы, DAO для, там, не знаю,

02:59:15.780 --> 02:59:20.680
аудита кода, DAO для выполнения, там, не знаю, там, заказов, не знаю, там,

02:59:20.780 --> 02:59:23.680
подписки на услуги, там, фитнес-тренера, как бы.

02:59:23.780 --> 02:59:25.680
Ну, то есть неважно, у них у всех есть свои нюансы.

02:59:25.780 --> 02:59:30.680
Где-то там надо деньги списывать вестингом, где-то нужны какие-то, там,

02:59:30.780 --> 02:59:34.680
экспертные сообщества, которые голосуют, как бы, там, за что-то и так далее.

02:59:34.780 --> 02:59:38.680
То есть здесь фантазия может как угодно, как бы, работать.

02:59:38.780 --> 02:59:44.680
И, как бы, DAO тема такая, как бы, очень интересная, организация бизнесов на блокчейне.

02:59:44.680 --> 02:59:48.580
Еще тема – это вот эти self-serving identity, verified credentials,

02:59:48.680 --> 02:59:53.580
то есть когда у нас эфир используется просто как публичная база данных,

02:59:53.680 --> 02:59:58.580
в которой можно хранить публичные ключи, адреса, как бы, и вот, ну, адреса,

02:59:58.680 --> 03:00:02.580
которые, по сути, есть как публичные ключи, и доказывать, что ты, там, находишься

03:00:02.680 --> 03:00:07.580
в каком-то там реестре, имеешь какой-то документ, имеешь какой-то пропуск, билет на мероприятие,

03:00:07.680 --> 03:00:13.580
там, или еще что-то. Тоже делается очень красиво, как бы, на контрактах, минималистично, как бы,

03:00:13.580 --> 03:00:20.480
и закончено, вот. Ну, NFT, как бы, это сами, как бы, разберетесь, там, не знаю, там, игры,

03:00:20.580 --> 03:00:24.480
представленные NFT, там, это тоже инфы, как бы, очень много.

03:00:24.580 --> 03:00:32.480
Вот, в общем, есть здесь, что поделать, вот, думайте. Вот, на сегодня, наверное, все

03:00:32.580 --> 03:00:39.480
в качестве post-reader к этой лекции. Ну, значит, что, как бы, важно почитать?

03:00:39.580 --> 03:00:43.480
Ethereum Official Docs – это, по сути,

03:00:43.580 --> 03:00:47.480
вообще, как бы, просто рекомендую, у них хорошая очень документация.

03:00:47.580 --> 03:00:53.480
Есть очень хорошая статья, типа, что происходит, когда вы отправляете один DAI.

03:00:53.580 --> 03:00:58.480
DAI – это токен такой, как бы, ERC-20, там, одного проекта, как бы, крайне популярный,

03:00:58.580 --> 03:01:03.480
который к доллару привязан. Вот, вот там, прям, подробно, вместе со ссылками на,

03:01:03.580 --> 03:01:12.480
прям, вместе со ссылками на исходный код ноды, описывается все, вообще, что происходит

03:01:12.480 --> 03:01:18.380
в момент отправки транзакции. И как она готовится, и что она делает, как бы, на ноде,

03:01:18.480 --> 03:01:23.380
и там, трейсы всяких, как бы, транзакций, и как она обрабатывается, как газ обрабатывается,

03:01:23.480 --> 03:01:28.380
как смарт-контракт исполняется. То есть, это такая чтива на, прям, на несколько часов.

03:01:28.480 --> 03:01:32.380
Но, если прочтете, как бы, то предыдущая лекция по эфиру, как бы, она, в общем-то,

03:01:32.480 --> 03:01:37.380
вам тоже не особо будет нужна. Ну, либо, прям, супер дополнит, вообще, полностью

03:01:37.480 --> 03:01:42.380
понимание того, как эта штука функционирует. Еще раз напоминаю, что другие блокчейны,

03:01:42.480 --> 03:01:47.380
они не сильно отличаются, на самом деле. Ну, то есть, архитектурно не сильно.

03:01:47.480 --> 03:01:52.380
У всех одни и те же требования. У всех БФТ, у всех детерминизм, у всех газ.

03:01:52.480 --> 03:01:58.380
У всех, как бы, execution restriction. Все похожим образом решают.

03:01:58.480 --> 03:02:05.380
Еще одна ссылка, вот здесь вот, это про то, как вычисляется газ динамически.

03:02:05.480 --> 03:02:10.380
То есть, здесь довольно, там, много, вроде бы, как кажется, что это сложно,

03:02:10.480 --> 03:02:12.380
на самом деле, как врубитесь, там, не знаю, в первый, второй этап,

03:02:12.480 --> 03:02:16.380
пункт, а остальные все очень легко, как бы, прочитать. По сути, это описание того,

03:02:16.480 --> 03:02:21.380
как высчитывается, сколько вы должны заплатить, если вы в память записываете

03:02:21.480 --> 03:02:27.380
x байт какой-то информации. Сколько это будет стоить, потому что здесь, там,

03:02:27.480 --> 03:02:32.380
нулевые байты стоят дешевле, ненулевые байты стоят дороже. Все это выравнивается

03:02:32.480 --> 03:02:37.380
слотами по 32 байта, как бы, здесь это, вот это все описано. Это тоже, как бы,

03:02:37.480 --> 03:02:42.380
можно, там, почитать, как бы, для общего развития. Но, вот, как бы, я,

03:02:42.380 --> 03:02:49.280
рекомендую крайне вот эту вот статью, прям она очень классная. Вот, в принципе,

03:02:49.380 --> 03:02:53.280
все. В следующий раз все уже поедем, там, по солидите, уже будет смотреть

03:02:53.380 --> 03:02:57.280
всякие контракты, паттерны, как бы, подразумевается, что, как работает эфир,

03:02:57.380 --> 03:02:59.280
вы, в общем-то, знаете.

03:02:59.380 --> 03:03:02.280
А пример кода с тестами пришлете?

03:03:02.380 --> 03:03:06.280
Имейте в виду вот этот хардхед, да?

03:03:06.380 --> 03:03:07.280
Да.

03:03:07.380 --> 03:03:12.280
А, да-да-да-да, закинул. Да, хорошо. Там, пингонетики,

03:03:12.380 --> 03:03:17.280
ну, это открытая репа. Все тогда. Ладно, тогда мы сегодня завершаем.

03:03:17.380 --> 03:03:19.280
Всем хорошего дня.

03:03:19.380 --> 03:03:21.280
До свидания.

03:03:21.380 --> 03:03:23.280
До свидания.

03:03:23.380 --> 03:03:25.280
До свидания.

