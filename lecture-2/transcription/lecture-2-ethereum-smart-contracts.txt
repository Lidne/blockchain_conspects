Так, отлично. Значит, сегодня у нас, в общем-то, как раз вторая лекция.
Мы опять, как и в первой лекции, мы попробуем довольно-таки быстро обозреть,
как душами смарт-контракты эфирные, как они работают для того,
чтобы вы дальше могли выбирать себе курсовые проекты,
может быть, там, потыкать где-то в код, как бы посмотреть.
Первая домашка, соответственно, тоже к курсу, как бы это, по сути,
внести дифы в Solidity код, вот, особо не пугайтесь,
он достаточно легко, как бы, читается, и модифицировать его тоже, как бы, несложно.
Вот, сложности, как бы, смарт-контрактов, они, на самом деле, в понимании
таких низкоуровневых механизмов, вот, как бы, в самом, там, грубо говоря,
написании кода, там, большого количества каких-то таких страшных тонкостей нет.
Вот, значит, поехали.
Возвращаясь к процессингу транзакций, то есть на этот раз мы уже их посмотрели,
затем со стороны клиента, то есть как это выглядит вообще общение со смарт-контрактами
для клиентов, то есть для ваших, там, пользователей, вот.
Ну, например, предположим, я зашел на какой-то сайт, который посвящен финансам,
я сейчас нахожусь в тестовой сети, сейчас уже не помню в какой, в Герле.
Вы ее, кстати говоря, будете довольно часто использовать, возможно,
имеет смысл, как бы, туда, как бы, деплоить свои, не знаю, там, проекты,
то есть вы можете там разворачивать свои контракты, пользоваться этой сетью спокойно.
В Герле сейчас наиболее из всех вот этих вот тестовых сетей, как видите, там много.
Ринки бай уже, как бы, скоро будет деприкейтед.
Герле сейчас наиболее такая свежая, как бы, которая поддерживает последнюю версию эфира,
как бы, так что, значит, в ней, собственно, и, скорее всего, придется работать.
Очень удобно.
А там есть копия сайта, ну, кстати, да, в отличие, как бы, от источника,
остальных от Web2 сервисов, в Web3 можно взять и скопировать свой сервис
и запустить его в тестовые сети с игрушечным эфиром.
Представьте, если бы у вас был там Тинькофф или Сбер, как бы, с игрушечными рублями,
как бы, но стопроцентно повторяющий полностью, абсолютно всю бизнес-логику основного приложения.
Ну, вот.
Там, на самом деле, такие же, такие и есть, как бы, штуки,
и недавно в Сбере была какая-то дичайшая бага как раз с тестовой версией приложения.
Значит, для взаимодействия со смарт-контрактом,
то есть для отправки вот такой же, вот такой вот транзакции,
вот, в которой, как я говорил, находятся вот здесь вот в импуте,
закодировано, какую функцию данного смарт-контракта я хочу вызвать.
То есть я хочу бросить транзакцию вот на этот адрес
и вызвать такую-то функцию с такими-то парами.
Они здесь упакованы, конечно, но, тем не менее,
выглядит это следующим образом.
Ну, там, предположим, я хочу там включить,
не знаю, свой, там, эфир, как калатору.
Я сейчас отправлю, по сути, как бы, функцию, которая говорит,
типа, разреши мне посылать, там, не знаю, эфир в этот смарт-контракт.
То есть у него внутри произойдет запись.
Для клиента это выглядит вот таким вот образом.
То есть у него всплывает вот этот вот метамаск
или какой там у вас есть, там, не знаю, там, кошелек там какой-нибудь
и предлагает эту транзакцию подписать.
Я эту транзакцию подтверждаю.
Я не отправляю никакого эфира, вот.
Но мне, конечно, придется заплатить за эту транзакцию.
Сейчас надо нажать.
Вот.
И все, транзакция, как бы, поехала.
Я жду, пока она, там, что-то там заманится,
пока майнеры ее примут, пока они включат блок,
пока, как бы, но...
Я тоже не особо любитель плюс-сайза, да и таковым не являюсь.
Я думаю, что...
Никита, выключи микрофон.
Да.
И, соответственно, теперь, когда транзакция дошла,
то собновился, вот.
И, соответственно, эфир, как бы, теперь у меня включен.
Я могу теперь его, там, например, не знаю, там,
какое-то количество этого эфира положить, там, не знаю, процент, например.
Будет выглядеть все точно так же.
В чем, как бы, ну, как бы, удобство веб-три приложения,
что я вот ровно таким же образом хожу, там, в сотни проектов
абсолютно разных, как бы, могу делать в них, как бы,
все делать при помощи одного и того же, не знаю,
даже одного и того же адреса, одного и того же, вот, этого расширения.
Нигде, как видите, нет никаких ни логинов, ни регистрации,
вообще ничего, как бы, этого добра нет.
Все свалено на пользователя.
То есть за безопасность своих адресов, своей крипты, я отвечаю сам.
То есть никто мне здесь не поможет никаких, там, восстановить аккаунт,
ничего этого нету.
А так, на секунду, так, вообще, как бы, взломы аккаунтов, угоны,
короче говоря, получение персональных данных,
оно в Web2-сервисах, в разных, там, почтах, как бы, сервисах
очень часто делается.
Как раз через функции восстановления доступа к аккаунту.
Всякие вот эти секретные вопросы, Wi-Fi и так далее.
Вы все это, как бы, в security штуках, как бы, видели.
Ну, вот я положил, там, сколько-то, там, 0.12 эфира,
положил под 11% годовых, все, они там валяются,
потом захочу, как бы, вытащу.
Вот, то есть все, как бы, довольно просто.
И с точки зрения разработки ваших проектов,
это тоже достаточно, как бы, удобно, потому что вы пишете,
ну, если так, в минимальном варианте, то вы пишете смарт-контракт,
деплойте, выкладываете его в сеть, куда-нибудь, там, не знаю, в тест-нет-герле,
и пишете просто на Node.js какой-то, там, простейший, как бы, интерфейс.
Ну, как бы, за этим интерфейсом, там, коду, на самом деле,
там, на три строчки буквально, которые с эфиром общаются,
потому что вся бизнес-логика, по сути, находится там где-то, в тест-нете.
Вот, а бэкэнд вам нужен для того, чтобы на вашем проекте показывать,
ну, всякие, там, цифры.
Цифры, агрегации, там, сколько, там, не знаю, какие там проценты,
total balances, вы можете взять, брать что-то из контрактов,
но что-то вам понадобится, там, агрегировать, собирать статистику,
чтобы пользователю дать больше информации,
и для этого как раз используются бэкэнды, вот,
поэтому с этой точки зрения Web3-разработка,
она включает в себя, в том числе и Web2-разработка,
то есть вам надо, там, курсы какие-то там переводить,
еще что-нибудь, в общем, все это делается на бэке.
Вот, значит, поехали.
Значит, что происходит с транзакцией?
На самом деле, на начальном этапе, когда мы ее только кинули,
когда она попала в ноду, у нее, конечно, нету ни хэша-блоков,
в которые она была включена, ни номера блока, вот,
неизвестно, сколько она потратила газа, эта транзакция,
то есть после того, как она была, как бы, замайнена.
У нее непонятно, на какой позиции в блоке она находится, вот,
но, в принципе, все остальное, как бы, оно, в общем-то, одно и то же,
то есть вот здесь подпись,
сколько эфира она на себе тащит, ее, соответственно, нагрузка,
вот этот hex bytes.
Кстати, что интересно, как бы, хакеры бывают, ну, точнее, не бывают,
когда довольно часто переписываются с проектами
вот посредством вот этих hex bytes,
то есть вы можете отправить там транзакцию кому-нибудь с эфиром
и здесь написать в комментарии, типа, вот, как бы, не знаю, там,
спасибо за хак, короче говоря, вот, заберите часть денег.
То есть бывает такое.
Что и с хакерами переписываются, собственно, через вот эти вот hex bytes тоже бывает.
Значит, что происходило вот здесь, когда я работал с Metamask?
Сделал транзакцию, подписал транзакцию,
затем мой вот этот вот Metamask,
я напоминаю, это не ваше приложение,
то есть не ваш DAP сделал эту транзакцию,
ну, точнее, он ее изготовил, эту транзакцию сформировал,
а подписал и отправил ее именно как раз Metamask,
никакой JS с вашей страницы этого не делает,
это делает расширение в валюту, то есть саму транзакцию отправляет, вот.
Ну, а здесь, как бы, в JS-ке вы можете сделать, там, не знаю,
PubSub, там, подписаться, там, на обновление, там, от Metamask, там, от ноды, как бы,
и в нужный момент, когда пришла информация, что все, транзакция включена,
как бы, галочки переключилась, стейт изменился.
Соответственно, там используется обычный, там, JSON-RPC интерфейс,
обычно у нод есть, как бы, два интерфейса, HTTPS и WebSockets,
WebSockets, которые позволяют, как бы, вам держать все время открытым соединение,
то есть если вам надо, как бы, там, непрерывно получать апдейты,
все время страничку обновлять, как бы, это более удобно, ну, вот.
Здесь, как бы, все стандартно, и поэтому, как бы, ноды, они, по сути,
представляют собой, ну, так, для внешнего наблюдателя, по сути, такой веб-сервер,
который прям JSON-RPC API, то есть открытые порты, как бы, вы можете,
туда кинуть какой-нибудь запрос, и он вам в ответ, как бы, ответит,
как бы, можете кинуть, там, послать транзакцию, и нода, как бы, отправит транзакцию.
Значит, что делает нода? Нода валидирует транзакцию, чтобы ее, там,
мусором не закинули, всякие черновые проверки, кладет, как торрент,
как бы, начинает раздавать, как бы, через торрент и, там, через P2P эту транзакцию, вот.
Причем, там, есть, по сути, как бы, несколько,
несколько протоколов, по которым они работают, там, родной эфирный P2P,
есть стэк, как бы, который использует другие ноды, вот, то есть, несколько вариантов,
как бы, но смысл один и тот же, то есть, нода рассказывает другим, типа,
чуваки, у меня есть, вот, новые хэши транзакций, кому надо, как бы, если хотите,
я вам, типа, перешлю тело этих транзакций, ну, чтобы дважды, как бы, не слать.
Вот, наконец, она добирается, там, до майнера, вот, и, соответственно, майнер,
ее применяет. Значит, затем, ну, и после этого, после того, как, как бы,
нода объявила о транзакции полной ноды, она стоит и ждет, как бы, новых блоков,
подписывается на все, как бы, новые блоки. Когда прилетает новый блок,
она узнает, что, как бы, я жду результатов вот этой транзакции,
то есть, когда она будет включена в блок, она, по сути, как бы, подписана, в общем,
на эти события, вот, она получает новый блок, проверяет его, выбирает,
в соответствии с консенсусом, годится ли этот блок или нет, как бы, попадает ли он
в основную цепочку, в мастер-чейн. Если и надо, как бы, как я там показывал
на схемах, как бы, откатывать, может быть, предыдущие блоки и накатывать вот эти вот
новые, вот, с ревертом, как бы, всех транзакций. Затем накатывает все транзакции
из вот этого нового блока на свою state database. Вот, возможно, среди этих
транзакций есть и наша, вот. И как раз вот в этот момент,
когда она применяет, как бы, этот, ну, применяет, по сути, блок, бежит по
транзакциях и делает вот эту вот apply, вот ровно в этом месте работает код
контракта. Прямо здесь как раз запускается виртуальная машина, вот, и вот здесь, как
бы, она бежит-бежит, как бы, по транзакции, по сути, исполняет, как бы, код контракта.
Вот. Далее она решает, как я говорил, любой smart-контракт, любой вызов к smart-контракту
заканчивается всего двумя исходами, да, типа, все окей, как бы, и реверт, и в случае реверта,
как бы, ну, ничего не происходит. То есть никаких изменений абсолютно, как бы, вот, кроме, как бы,
списания денег с баланса отправителя за потраченный газ. А в самой state database,
как бы, там, во всех, там, данных контракта никаких значений, никаких изменений не происходит.
После чего она обновляет state root, вот это вот в дерево организованное значение, грубо говоря,
state, ну, hash state database, такой общий, который, как бы, зависит от всех значений этой базы
данных, и, соответственно, проставляет транзакции, как бы, сколько было потрачено газа, какой блок
она была включена, там, какой индекс, и так далее, и так далее. В этот момент наш metamask, как бы,
висит на этой ноде, там, по вебсокетам или опрашивает ее по HTTPS, вот, и ждет, когда
появится информация о его транзакции. Значит, приходит новый блок,
он ждет, как бы, будет ли доказательство того, что моя транзакция попала в мой блок. Здесь, как раз,
используются вот эти вот merkle proof, то есть доказательство того, что транзакция, она, как бы,
в блок попала, в то время как в блоке есть буквально одно только число. Ну, про меркл деревья мы с вами
обязательно, там, поговорим подробно, это широко используемый паттерн в блокчейнах. То есть она ждет,
как бы, еще и доказательство того, что транзакция в текущий блок попала, вот.
Затем получает, соответственно, апдейты от ноды, как бы, ну, там, она запрашивает, там, любые, там,
интересные значения, например, там, включен ли флажок он для эфира для вот этого адреса клиента,
который, как бы, запросил. Если да, то он там что-то отрисовывает. Вот, она это все дело опрашивает,
и, как бы, после того, как понятно, что транзакция включена, все изменилось, как бы,
все данные из контрактов получены, она апдейтит мордочку.
Вот, то есть выглядит весь вот этот цикл таким образом.
Кто является клиентами? То есть кто может дергать, как бы, оперировать эфиром? Значит,
самые популярные это браузеры вот с этими расширениями, там, помимо Metamask есть еще много,
там, всего. Есть, там, просто десктопные программы-клиенты, но браузеры, они, почему они,
как бы, наиболее популярны? Ну, потому что, как я сказал, как бы, я своим браузером бегаю, там, я
не знаю, по десяткам, как бы, проектов, что хочу, там, закладываю, перекладываю, как бы, как угодно,
там, не знаю, в финансы регистрируюсь, играю, там, в игры, там, NFT какие-нибудь создаю, и все это
делается при помощи, по сути, одного расширения в этом браузере. Это крайне удобно. Вот, то есть,
как бы, тот, у кого, как бы, есть на балансе эфир, по сути, имеет доступ, там, к сотням разных
финансовых инструментов, совершенно, там, разных типов, как бы, и, там, возможностям, там, десяткам
и вообще кучу всего. Все это при помощи буквально одной софтины. Но есть еще, мы тоже будем про них
говорить, это, наверное, самый надежный способ защитить отдельный адрес, это железные ключи
хардварные. Это такие типа флешки, как бы, штуки, вставляются в USB, и их основная суть, то, что у
них внутри зашит приватный ключ, они никогда его в жизни наружу не показывают. Вот, ты в эту флешку,
как бы, ну, ты в этот ключ, как бы, не можешь, ну, как бы, не можешь, ну, ты в этот ключ, как бы,
передаешь транзакцию а он в ответе выдает ее подпись то есть типа да я подписал вот и там
если там например кнопочка есть на этой флешке то хакера как бы даже полностью захватив компьютер
он не может получить не может получить доступ к этой кнопочки то есть как минимум там нажать
нажать confirm и подписать за вас ну и там это маска умеет коннект с этими с этими ключами вот
в общем их рекомендуется использовать мобильные валятся значит то что вы набираете когда вы
наберете там эфириум wallet мобайл по большей части на самом деле это обрезанные браузеры такие
которые входят на ограниченное количество сайтов то есть без строки url ада как вас кучей там не
знаю там линков там favorites и тоже встроенные как бы истории управления ключами пока и это
имеется паблике и инфо
structure то есть там приватные публичные ключи адреса там и так далее вот то есть такие как
бы популярные браузеры мобильные кошельки это по сути как бы браузер для того чтобы ну им было
удобно ходить сюда там городить особо ничего не надо потому что джессон рпс и все стандартно все
как в вебе как бы особо что-то придумать как бы смысла нет если вы будете самописный валит там
писать на java вот вам придется реализовать вообще там ну ты фига там всяких взаимодействий там так
далее
и в этом же еще причина почему мобильщики не любят особо крипту значит потому что смотрите вы сделали
какую-нибудь вас там мобилка у вас здесь ваша опка не знаю какая там крутая игра как бы там
здесь эфир значит можно чего-нибудь покупать продавать всякие там предметы игровые там какая
экономика интересная но для того чтобы каждую транзакцию вам отправить вам нужные подписались
Для этого вам нужен секретный ключик, личный ключик, адреса.
И зачастую вот это реализовать сложнее, чем реализовать всю вашу апку целиком.
Потому что ваша апка, там, не знаю, красивые картинки плюс несколько типов транзакций,
а вот здесь вот надо прям сильно поскрепеть, потому что здесь требования к безопасности очень высокие.
То есть вам придется, по сути, в свое приложение встроить валет.
А требования к валету, они крайне серьезные.
То есть здесь вы что-то там набажете, как бы это еще можно будет поправить,
а здесь что-нибудь не так сделаете, там, не знаю, генерацию адресов, там еще что-то.
И будет очень плохо, как бы валет поломают.
Вот, ну, буквально недавно там вот тоже дичайшая история в Салане.
То есть когда там было взломано, там, не знаю, сотни, как бы тысячи адресов,
огромное количество крипты было украдено как раз просто потому,
что один из валетов, он генерировал...
адреса несекьюрным образом.
Вот, там, секретный ключ из него, публичный из него, там, адрес, соответственно.
Он делал, ну, несекьюрно, как бы, и, по сути, это было взломано.
Так, нет. Нет, я нет, я набрал.
Нет, на самом деле, он не несекьюрный, да, я извиняюсь,
а он отправлял дебажную информацию, дебажную информацию в сервис-центре.
И там среди дебажной информации валялись, как бы, приватные клиенты.
То есть то, что полностью вз installing, ну, перiąдовACcurrency и там е-ч Biern el ...
كignment и и так далее,
поэтому, наверное, ещё иyn клиент,
поэтому его нужно вставить вот сюда,
так что weekends.
Ну, в общем, хоть и нелегче, но с генерацией адресов это вот,
буквально, совсем недавняя бага, вот.
Есть софт, который позволяет генерировать красивые адреса там с ноликами и так далее,
как бы, и, вот, в этой генерации была найдена уязвимость.
Все, кто автоматически ходят в эфир и шлют туда транзакции.
Что-то там запрашивают.
У них обычно приватные ключи в конфиге.
Пугаться тут вообще особо не нужно, потому что штука вообще простая.
На любом языке программирования, Python, Rust, JS и так далее,
есть там прям куча библиотек, которые вам позволят сгенерировать адрес эфириумный
и спокойно там все подписи ставить и так далее.
То есть все вообще делается на самом деле очень просто, там несколько строчек.
Вот, поэтому если вы что-то пишете автоматизированное, что работает там,
не знаю, с эфиром, как бы это очень просто.
Вот, то есть создать транзакцию, создать адрес, как бы создать ключ,
можно без особых проблем.
Вот, и еще, наверное, еще одна история про клиентов,
которые могут работать со смарт-контрактами, про которые часто забывают,
это различные девайсы.
Вот, на хакатонах довольно часто, как бы раньше там довольно популярно,
популярная штука была сейчас, по-моему, не очень уже стала, как бы популярная,
а так-то раньше, как бы много народа, как бы пытались соединить эти вещи.
Действительно удобно, как бы интернет вещей, ему блокчейн достаточно интересен,
просто потому что нет единой точки отказа, то есть плевать любая сеть, короче,
любая нода, как бы ваше устройство, считай, как бы подключено к сети, вот,
у вашего устройства есть приватный ключ, есть адрес, как бы, который никто, как бы,
там не остановит, как бы.
Никто им там особо, как бы, не управляет, вот, и оно там может всякие штуки делать.
Ну, у нас там знакомый проект, например, Робономика очень много занимается
соединением как раз всяких, там, не знаю, там роботов, датчиков, там, и так далее,
всего, как бы, с блокчейнами.
Если у вас есть какая-то девайсина, мы, например, делали там счетчик электричества,
там, 100 киловатт насчитал, он, соответственно, формирует транзакцию,
то есть, мое следующее показание – это 100 киловатт, значит, подписывает ее,
отправляет в сеть, у нас там была другая сеть, как бы, ну, неважно, например,
отправляет в эфир, а здесь смарт-контракт, как бы, принимает эти показания,
100 киловатт, у него есть, там, 90 предыдущие показания, как бы, теперь у него стало 100,
у него получается 10, и он за эти 10 списывает плату по текущей, там, цене,
как бы, за киловатт, то есть, такая, достаточно.
Понятная, как бы, история, и при этом, что, как бы, удобно, ни одного сервера нету,
ну, то есть, у вас нет ни облака, никаких, там, бэкэндов, никаких хайпи, короче,
у вас есть просто счетчик, и все, как бы, его просто как-нибудь подрубить, там, не знаю,
к Wi-Fi или куда-нибудь в сеть, он уже там сам разберется, там, достучится до какой-нибудь,
до какой-нибудь, там, из сотни нод публичных, и отправит, как бы, туда транзакцию,
вот он, там, считает, соответственно, показания, но для этого есть некоторые ограничения.
Технически, прошу прощения, в первую очередь, они связаны с тем, что такие девайсы должны быть
достаточно производительными, потому что им нужно будет сделать электронную подпись
с использованием вот такой электрической кривой, то есть, это арифметика с числами,
как бы, 256-битными, и на каком-нибудь, там, мелком каком-нибудь орудии,
там, которые еле-еле, там, как бы, что-то там пашет, как бы, вы, скорее всего,
такую подпись произвести не сможете. Ну, вот, а Raspberry Pi, например, может достаточно спокойно,
как бы, сформировать транзакцию и ее отправить. Вот, ну, и понятно, что там должна быть, там, сеть,
короче, там, вебка и так далее, то есть, возможность обращаться к ноде и сделать, по сути,
JSON-RPC вызов, вот, то есть, ну, это тоже хороший вариант, и вот.
Теперь, следующий такой кусочек.
Как бы, важный. Это ноды, то есть, сами, сами ноды, которые наши узлы, как бы, наши узлы вот этой
эфириум-сети. Кто-то из них майнером является, кто-то из них является, там, не знаю, валидатором,
все они умеют принимать, как бы, транзакции от пользователей, все они, как бы, друг другу,
как бы, про эти транзакции рассказывают, каждый из них, как бы, от других нод получает блоки,
тоже так.
То есть, они, как бы, строят цепочку по одним и тем же правилам, с одним и тем же консенсусом, вот.
Но, опять же, в централизованном мире, мы видим, как бы, такую историю, нам говорят, как бы, вот, у нас есть, типа, Монго,
она у нас, там, на четырех репликах, как бы, там, одна реплика, там, не знаю, в Китае, другая, там, в USA, как бы, третья реплика, там, не знаю, в России,
и вот между ними настроена репликация, вот они вот так общаются.
Вот этот софт, он одинаковый.
То есть, везде, как бы, здесь стоит Монго, здесь стоит Монго, здесь стоит Монго, здесь стоит Монго,
то есть, весь один и тот же код, один и тот же программный продукт одних и тех же версий.
Из-за того, чтобы я говорил, что эфир — это, как бы, в первую очередь, как бы, протокол, да, нежели имплементация,
у эфировских нод, у неё, вот, это вот просто самые, только известные, как бы,
имплементации ноды.
То есть, у вас здесь стоит здесь, здесь стоит Nethermind, написанный, там, не знаю,
на C-Sharp, здесь
GES на горшке написан,
здесь какой-нибудь
OpenEthereum, который на Rust
написан, как бы здесь стоит
Eragon,
такая чуть более
быстрая версия GES,
тоже на горшке написано.
Вот, и они все друг с другом, как бы
по одному и тому же протоколу,
в общем-то, общаются. Там есть у них отличия
в P2P, там, в стэках и так далее,
но, как бы, по большей части они все, как бы, друг друга
видят и друг друга понимают.
И в этом, собственно, крутость
как раз
всей вот этой вот истории,
потому что, когда были атаки на эфир,
ну, такие прям вот эксплойты
как бы на ноды, он
достаточно достойно их выставил, потому что
была там, по-моему, там атака на
там Rust-имплементацию, как бы
их там много сразу полегло,
а там горшечная, она, как бы,
осталась в строю,
ну, или наоборот, как бы было, вот.
Но смысл в том, что клиентов много,
и всех атаковать, как бы, сразу
не получится, найти дыры, как бы,
одновременно во всех. А оставшиеся
продолжат тащить сеть, как бы,
да, там отвалится, может, часть майнеров, там,
еще что-то, но сама сеть продолжит работать.
Это, опять же,
в пользу довода о том,
что блокчейны круто подходят, как бы,
в условиях тотального киберпротивостояния,
как бы, крайне устойчивой
сети.
Отличаются они,
ну, как бы, с точки зрения
протокола, отличаются они,
не сильно, вот, но
отличия все-таки есть, как бы,
ну, например, там у них
различные API, то есть какие-то стандартные
функции, как бы, есть везде,
вот, а какие-то,
какие-то вот эти, вот, как бы, функции
через JSON RPC, как бы, вызываются,
как бы, на некоторых нодах написано,
типа, not supported.
То есть кто-то там не отдает, как бы,
сырые транзакции в байтах,
кто-то там не позволяет, там, типа, не знаю,
подписаться на какой-то особый вид,
я не знаю, там, событий.
Тут еще там что-то, как бы, то есть
здесь уже, как бы, колдует
команды разработки.
И это, кстати говоря, разработка
нод, вот, собственно, вот этого софта.
Это тоже называется,
как бы, блокчейн-разработка, не та,
которую мы будем изучать,
то есть это, собственно, люди, которые сами ноды
разрабатывают. И эта работа,
она больше похожа на системную
разработку. То есть
можете считать, как бы, что те, кто
пишут эти ноды, ну, точнее, даже
не можете считать, а на самом деле там, собственно,
которая этим занимается это разработчики которые до этого разрабатывали движки субэдэ различные
это и там из маиску или какого-нибудь там кто делал там поздно с манги редис и и так далее
то есть те кто вот это писали прям вот по сути изнутри собственно сам сам как бы движок вот они
же пишут и вот чей на победителями в языках здесь однозначно как бы являются го и раз
потому что именно вот эти вот два языка как бы они могут обеспечить во первых как бы крайне
высокую производительность да как бы хотя как бы но блокчейн и да может и не славятся у нас
там миллионами tps и меня там каждый раз на конференции холод надо объяснять как вы
через сделаю вообще зачем сюда пришел как бы со своими этим блокчейн ими тормознут ими вот
но на самом деле внутри как бы здесь not как бы оптимизации производительности огромное внимание
в деле
поэтому пишется они в основном на низкоуровневых языках как бы гошка за счет того что у нее
многопоточность как бы хорошо сделано здесь прям это там серьезно там надо много к на эту держать
там подписываться на кучу событий все это трекать одновременно в нужном порядке устраивать ну а раз
потому что он просто позволяет там контролировать буквально там каждый чих то есть там вообще любой
как бы там любой алгоритм прямо как бы гвоздями прибит как он исполняется максимально оптимизирован
вот поэтому там блокчейн и как бы на питоне блокчейн и там на растя не сильно приветствуется
но вот есть еще пример как бы например nether майнт тоже там знакомый к команда как раз писал
они написали его на си шарпе вот что в принципе наверно как бы тоже вполне себе варианта у них
очень достойных сочи клиент получился как бы nether майнт его тоже используют во все вот так что и на
java вот эта консорциум гипер ledger тоже как бы сделал свою имплементацию
на java не знаю как она поддерживается мы с ней дела не имели далее тоже по терминологии
как бы вот этих вот нод когда я буду говорить ну то есть по сути есть наверное два вида как
бы нот ну точнее не 2 я первым может быть сюда даже добавил как бы архивные ноды если
говорить как бы об эфире значит архивная нода я прям с нее наверно начну
архивная нода если вам кстати такая нужна то вы можете получить там в сервисе типа алкими возможно
вам и понадобится если вам нужна своя нода как бы вы идете как бы вот здесь вот регистрируйтесь и вам
бесплатно дадут доступ но по сути прям дадут урл секретный ваш собственный как бы к по которому вы
можете обращаться к ноде эфира там у меня есть там ноды майнета есть но до этого тестового герле а вот
и вы можете как бы с ней работать как бы это будет бесплатно пока вы там совсем и не нагрузить там
немеряным количеством запросов вот тогда с вас денег попросят вот для обучения прекрасно как бы
хватает значит архивные ноды это самые честные ноды блокчейна то есть та которая собирает все
блоки начиная там с первого и до текущего вот такого вот блока она полностью ведет короче говоря
абсолютно все апдейты она сохраняет все транзакции на ней есть которые были за время существования
эфира и что самое важное вы у архивной ноды всегда можете запросить состояние прям стоит то есть
обратиться к этой базе данных на на какой-то определенный блок зафиксированы если вы говорите
хочу короче что ты мне сказала как бы вот начиная с этого блока какое было вот это вот значение там
тракте как чему была равна вот этот переменная там не знаю там три дня назад ровно в 5 утра вот на
этот номер блока и архивные ноды вам ответить то есть она умеет перепроигрывать весь эфир как бы
вперед-назад как вам нравится она довольно большая сейчас чтобы ее крутить как бы надо там там больше
двух терабайт место занимает эфир по моему 16 или 17 терабайт вот это вся как бы полностью вся инфа
и чтобы просто догнать эту ноду до последнего блока она же по-честному как бы бежит его
фабула по блоковых накатывает как бы нужно несколько дней на очень хорошем и мощном
сервере так что эта штука не дешевая крайне дайте мне секундочку потерял
вот а
архивные надо штука довольно такая прожорливая вот и в общем один из путей как бы развитие эфир
это как раз но облегчение not вообще по сути даже как бы отказ от архива вот этого от архива
транзакции от архива блоков от снапшотов вот этой вот базы как бы это один из путей по сути
развития эфира вы не можете скелет эфир довести его там до десятков и сотен тысяч транзакций в
и все это как бы хранить вот на архивной ноде у вас как бы никого компьютер как бы никогда это
не потянет вот поэтому но при этом как бы должны соблюдаться все крипто графические доказательства
того что какие-то конкретные транзакции были включены в блоке там и так далее поэтому задача
такая немаленькая обычно мы все используем вот когда вот я смита маскам до отправлял
транзакция все используют так называемые фолл-ноды это нода которая тащит актуально
стоит database то есть последнего последнего формата она может не сохранять как бы транзакции
вот она просто накатывает как бы новые блоки получают как бы новый блок накатывают и и
растает database держит последний там не знаю там последний какой-то кусочек как бы блокчейна
вот держит актуальную версию вот этой вот как бы стоит базы данных перепроверяет вот но при
всеми по всей по сути истории вот но еще понятие light но да как бы но тут ее прям как-то
формализовать довольно сложно потому что от структуры блокчейна сильно зависит как бы ну
что вообще нужно от этой light но да то есть легкая нода который вообще как-то ну там минимальная там
самое дешевое в поездка который просто висит где-то там на конце как бы блокчейна у нее
есть там какая-то может маленькой стоит database который следит только за заданными адресами
зафиксирован имя зафиксирован ими контрактами протоколами то есть здесь можно конечно
народить как бы чего угодно очень много простора для творчества вот поэтому то есть это такое
понятие как бывает но до легкий но вы там чуть ли не ноты в браузере которые понимаются вот в
некотором видео но были идеи до бутыльных которые вообще как бы работает из браузер то есть вы
включаете браузер власты к аппарату джаз на странице как бы начинает общаться с другими
браузерами и учиться к тому-то нет поршивны的 района видов sacred board с той Halloween
как бы в работе такого блокчейна такие идеи тоже это были ну и конечно же но до валидатор которые
производят блоки вот но это по сути то же самое и ему сгодится как бы full но да да как бы валидатор
штука нагруженная получает последнюю версию блока у него есть как бы текущий стейт даты
бейсом формирует как бы новый блок формирует изменения в стейт даты бейс как бы все это
записывает как были отдает как другим ну то есть майнеры майнеры валидаторы так далее вот это значит
к софту мы про надо еще тоже как бы поговорим с вами вот это просто для того чтобы вы обозрели
как бы горизонт софта как бы с которым придется работать а теперь значит про распределенные базы
данных распределенные базы данных
ну то есть блокчейн подают по сути как какой-то какое-то новое не знаю там направление какой-то
отдельный какой-то там не знаю там область знания но на самом-то деле на самом деле сама вот это
как бы идея вот этого блокчейна как бы сетевого консенсуса она уже изо всех сил прорабатывается
в базах данных то что много у кого были бы были базы данных вот чтобы изоляция
транзакции там какой-то хэдлок репликация было у кого-нибудь
так понятно ну ладно ну вообще это довольно как бы важная такая концепция и кстати говоря
над sky до что для блокчейна разработчика база данных это типа одна из областей как бы знаний
в которой хорошо бы хорошо рубать у нас в общем то наверное если так
сформулируйте по требования какие был член разработчики крутые то но так вот если на
пальцах то это человек который имеет хорошие такие глубокие знания в трех из пяти как бы
областей области такие лишь первый это алгоритм и структуры данных второе это там криптография
но это понятно естественно это все как вы говорили третье это как ни странно базы данных 4 это
операционная система потому что но именно прям вот как внутри как бы устроена операционная
система переключения процессов всякие там страничные механизмы так далее то что там на
самом деле очень много всего используется крайне эффективно как бы зубья из алгоритмов и 5 это там
безопасность сетевые протоколы то есть умение построить именно сам протокол там я тебе рандом
ты мне подпись этого рандома как бы я тебе в ответ как бы там еще что то то есть то есть понимание
таких низкого уровня механизмах тоже круто для всего в трех из пяти этих областей как бы
да то есть если вы действительно хорошо разбираетесь то с букчейнами будет не очень сложно значит
про репликации я уже много раз говорил значит мы говорим о самом сложном виде репликации которые
есть он называется master мастер значит таким мастер и если вы заходите на индекс там на какую
бы там страницу там не знаю на страницу маркета и делайте выборку дай мне все товары как бы цена
короче говоря и которые там чайники там например у вас происходит выборка из базы данных и вам api
вам api соответственно выдает все вот эти чайники отрисовывать значит на самом деле вы обращаетесь
к базе данных который называется слив и в этой базе данных лежат все чайники но она ридон ли
то есть она заточена на число запросу что вот этих селектов их немерено их там сотни тысяч и
поэтому как бы в яндексе огромное количество этих слоев серверов там не знаю там сотни как
бы там я не знаю там сотни там не знаю может быть тысячи а на самом деле серверов в которой
ведется запись куда добавляются чайники чайники добавляются гораздо реже чем они всплывают как
бы запросах такие базы как бы которые именно у right они называются мастер вот вот мы как бы
все это как бы архитектуры этих слоев как бы забыли у нас есть только мастера теперь
вот по сути майнеры там валидаторы блок-блок продюсер это база данных она довольно часто
эта штука как бы нужно если мы говорим о банке о каком-то дата у нас есть там не знаю там 100
долларов на счету здесь как бы а банк международный и у него вот эта реплика там юсей как бы вот эта
и нам нужно консистентность между ними соблюсти то есть если человек одновременно отправит запрос
сюда и сюда и скажет как бы здесь минус 100 баксов я покупаю велосипед а здесь минус 100 баксов я
покупаю там чайник то как бы надо будет что-то делать то есть либо у него станет баланс минус
100 долларов вот ну то есть поставка не договорятся как бы и там придется там как-то это решать либо
каждый из этих серверов должен поменяться как бы сказать у меня вот столько времени а чувак хочет
снять 100 баксов ты типа согласен тут говорит но у меня время попозже так что я вот ему дам от лук
как бы а тебе как бы разрешаю выполнить эту транзакцию и потом еще и вот и вот это спросит
как бы это же получит вам ответ или там или динай посчитает эти голоса вот в общем мастер мастер
репликация штука такая непростая вот и когда начинаешь читать эти алгоритмы вот этой мастер
мастер репликации там raft access если вам там интересно то они почитают
то после изучения как бы консенсуса в блокчейне вы увидите что это вообще как бы одно и то же
просто как бы здесь будут вместо типа ответов битиков типа окей не окей будут просто электронные
подписи участников ну и проверка что они в правильном реестр там находится и так далее
то есть здесь те же самые как бы подтверждение между репликами это значит тут по сути репликация
данных между между базами данных теперь что такое брайтах от лока
мы теперь смотрим на одну базу данных в которой постоянно валится дофига всяких запросов там
вставка удаления но у нас там в базе данных там соответственно строчки как бы кто-то как бы добавил
новую строчку там с васей как бы его 100 долларов то таки за вычеркнул какую-то строчку там у него
баланс до нуля кто-то про апдейтил строчку insert апдейт и доделит вот они валятся тут мастер реплика
как она это дело процессе во-первых если она будет их просто накатывать как бы атомарно каждую
транзакцию вот так вот как бы на таблицу возникает проблема различных блокировок то есть там я сейчас
вот апдейт вот эту вот строчку а мой менеджер делает выборку там не знаю делает среднее там
не знаю число как бы денег на балансе и вот пока как бы я вот эту свою апдейт не закончу не разберусь
его менеджеру придется подождать потому что он там тоже там стучится со своими там не знаю там
селекциями там и так далее то есть я вот эту штуку блокирую на это время или оставляя там тысячу новых
как бы строк или еще что-то а еще как бы в базы данных вот эти вещи они объединяются в транзакции
то есть там сначала две вставки потом одно удаление потом один апдейт то есть это в одну
таблицу другую то встретит 4 и все это должно выполняться еще атомарно то есть
либо все выполнилось либо все как бы откатилась целиком то есть баз данных нам так позволяют
делать как бы не задумываться что там под капотом как бы а под капотом там как раз находится вот этот
в райдах от лог то есть лог который пишет только вперед значит туда вот эти все транзакции складываются
t1 t2 t3 прям в порядке в котором они приходят t4 там и у него есть понятие у этого в райдах лога так называемый чекпоинт
ну потом опять сколько транзакции потом опять как бы потом опять чипом там опять в транзакции опять
как бы чип он вот чип видом . в которой в нашей базе данных информация фиксируется то есть сделали
т1 т23 т4 поставили чекпоинт то есть провели первую транзакцию вторую транзакцию третью
транзакцию 4 транзакция за комит или по сути как бы сделали комик в базы данных
есть прям собственно инструкция такая как бы комит провести вот эту мою транзакцию как бы
и в конце как бы сделать камень если все хорошо прошло вот соответственно база запоминает свои
так называемые снэпшоты снимки как бы на каждый чекпоинт и если вот здесь вот я вырублю свет
внутри как бы чекпоинт ну то давайте вот здесь вот короче говоря выключу свет то есть я сделал
там закатил первую транзакцию вторую а вот 3 4 не успел как бы у меня компьютер вырубили то
в следующий раз когда база поднимется она поймет как бы что она находится вот на этом
чекпоинте она поймет что вот эти накаченные мной изменения на диск запиши записаны они
еще не за комыми чен и то есть они еще не в комите и она как бы откатит базу да вот это
учит по это и начнет как с него работать а начнет наказывать как бы то есть такие как
бы именно такието
точки невозврата, по сути, вот этим, как бы, чекпоинтами,
и базы данных умеют быстро между ними переключаться,
то есть быстренько сбрасывать.
То есть там есть версии строк, там, в общем, куча разных механизмов.
Это, кстати, очень, ну, очень полезно почитать.
Полезно почитать, как это сделано там в MySQL, в Postgres, наверное,
наиболее такая, как бы, хорошо описанная, как бы, вот эта вот история
с версионированием строк, как они вот с этим работают.
То есть интересно, да, почитать, как это все сделано в KVL, в базах данных.
Значит, в KVL, в базах данных, вот всякие наши Mongo и Redis,
вот эти вот транзакции, то есть почему они такие быстрые,
потому что они очень простые, то есть они просто, как бы, тупые,
они не бегают, как бы, не захватывают там миллионы строк, как бы,
в одной транзакции, вот, ну, либо они как-то очень так
аранжируются там правильно, там быстрее работают чекпоинты,
вот эти вот откаты, как бы, поэтому эти базы, они более,
более...
более быстрые, вот.
Но они, конечно, такую логику, как SQL, не позволяют реализовать,
там, типа, не знаю, там, там, очень сложных выборок.
Вот, и вот эта вот конструкция называется Write a Headlock.
Секрет KVL в баз данных, как раз, вот тоже, в Mongo и Redis,
в том, что они бегут по вот этому логу крайне предсказуемо
с точки зрения потребления ресурсов.
То есть они вот эти вот расстояния между чекпоинтами,
они, в отличие от SQL, очень здорово измеримы, то есть прям
по количеству обновляемых ключей, то есть здесь прямо
есть какое-то такое фиксированное N, как бы, и они очень здорово
отмеряют вот эти вот кванты исполнения, и у вас компьютер,
ну, задействован, задействован на полную, как бы, мощность,
он прям жрет максимальное количество вот этих транзакций.
А в SQL потенциально может прилететь вот эта вот прям
огромная какая-нибудь штука, которая все это дело, как бы,
затормозит сильно надолго.
Ну, и в SQL базах там бывают, как бы, всякие там процедуры
оптимизации вот этих таблиц, уплотнения, когда они приходят,
здесь все начинает тормозить, все, все, как бы, останавливаются,
процессинг вау останавливается, вот.
И есть такой класс, как бы, k-value баз данных, levelDB,
его наследница rocksDB, здесь такие две, короче говоря,
k-value базы данных.
Которые знамениты тем, что они наиболее предсказуемым образом
вот этот вот вал, как бы, процесса, то есть очень-очень ровно,
то есть никогда не бывает у вас там на компьютере, что CPU у вас вот такой,
а потом вдруг вот такой вот, потому что пришел скрипт компактификации
вот этой вот таблицы или там что-нибудь еще, то есть или там пришел там,
я не знаю, там какой-то супер запрос, который все, как бы, повалил,
то есть они работают прям ровно, то есть больше ключей вот так вот,
вот так вот.
И пока не упрутся в 100%, как бы, ну, там уже, как бы, да, ловить нечего,
там все умерло, вот.
И, ну, у них там специально от слова, как бы, level, там на самом деле идет,
как бы, вот этот первый вал в write a headlock, данные из него собираются,
как бы, там во второго уровня, там level 2, как бы, там упаковываются,
там достаточно тоже предсказуемо, потом level 2, как бы, еще,
упаковываются в следующий, как бы, лейер, вот.
И вот таким вот образом здесь получается такой очень ровный, предсказуемый процессор.
Поэтому вот блокчейн ноды выбирают вот такие вот базы данных,
level db, rocks db, под капотом и у Геса, и там, по-моему, и у Эрегона,
и в RAST-имплементациях, и в Тоне, и в Polkadot, короче говоря,
ну, то есть и в разных блокчейнах, как бы, под капотом очень часто стоит вот это вот level db,
или rocks db, как раз вот за счет вот этих вот ее фишек.
Очень жестко структурированные транзакции, прибитые прям гвоздями, там, по размеру,
по времени исполнения, предсказуемая вот эта компактификация, как бы,
и отсутствие таких производительности просадок таких жестких, вот.
Потому что для блокчейна это смерти подобно.
Если вы можете какой-то транзакции вызвать, не знаю, залипание блокчейн ноды
в очень серьезное время, как бы, вы, по сути, атаковали блокчейн.
Вот, если найдете такую штуку, вот, можете приватно отрепортить, как бы, разработчикам,
получите баунти.
Теперь, опять же, с этой точки зрения, тоже, как бы, у кого не было, у кого не было баз данных,
объясню, что такое хранимая процедура.
Хранимая процедура – это как раз вот эта вот пачка вставок, делитов, еще какая-то логика,
там, типа, если, как бы, там, не знаю, там, денег.
Больше нуля, то еще сделать вставку в такую-то таблицу, и так далее, и так далее.
Там, проапдейтить.
И вся вот эта вот штука, она, по сути, лежит в базе данных, прям код, как бы, вот этой вот процедуры,
он прям лежит прямо в SQL-базе данных, и вы вызываете его названием функции.
Ну, например, в Тинькофф, как бы, приносите деньги, там, не знаю, там, оплата, как бы, за кредит.
У него в базе вызывается вот эта вот хранимая процедура, что же это про сейджи,
как бы, увеличит вам баланс, потом, там, типа, удалит, там, типа, задолженность за текущий месяц,
за current month, там, не знаю, платеж, например, если за кредит.
Типа, если, как бы, там, остались еще деньги, как бы, на кредите,
то он вам еще добавит, короче говоря, еще план платежей на следующий месяц,
проапдейтит ваш кредитный рейтинг.
И исполняться вот эта функция, она будет тоже, как бы, атомарной.
Да.
То есть либо выполнится, либо целиком не выполнится, как бы,
либо целиком выполнится, то есть для того, чтобы целостность в базе данных обеспечена.
Такие штуки называются хранимые процедуры.
Вот, там, по-разному, там, вот, там, вызывают в разных базах,
там, где функции, где хранимые процедуры, вот, в общем, там, терминологии, как бы, очень много.
Но, по сути, это, как бы, пачка атомарных действий с...
Атомарная пачка действий из базы данных.
И смарт-контракты очень похожи на вот эти...
хранимые процедуры. То есть если просто
рассматривать эфир как базу данных, то как бы
смарт-контракт это, можно сказать, как бы в нем
хранимые процедуры. Транзакции,
это понятно, как бы пишущие,
это транзакции, которые пишут
в базу, то есть такая же
аналогия. Консенсус
алгоритма это репликация мастер-мастер,
то есть точно
так же как бы то, что здесь
у нас ноды для того, чтобы
договориться о том, как бы
принять блок или не
принять блок, использовать для этого как бы
деньги какие-то там, я не знаю,
там Proof of Work или там Kilowatt,
или там в Proof of Stake договариваться
как бы входишь ли ты в список валидаторов,
за которые деньгами проголосовали.
Это на самом деле второй вопрос.
Здесь просто получается
решать вот эту проблему
распределенного консенсуса этой репликации
при помощи экономических механизмов.
Потому что многие действия как бы просто
невыгодны большинству участников.
Вот. А
по сути это как бы и есть та самая
репликация мастер-мастер,
причем это на
низком уровне это репликация
LevelDB, ну там или
ROXDB, там неважно, какие вы или базы данных
как бы получаются, на самом деле как бы по сути
это механизм репликации
для вот этих вот баз данных, так если
прям совсем как бы на пальцы.
Вот.
Тогда в этом случае наш write a headlock
вот этот, в который мы как бы складируем
транзакции одни за другой, потом их
оформляем как бы в пачки и накатываем
их, то есть на там
чекпоинт,
то как бы вот это вот наш пул транзакций
в P2P, который висит
полностью такой публичный,
а чекпоинты
и коммиты в этом
в этом write a headlock
это по сути как бы новые блоки.
То есть произвели блок,
взяли вот такое вот количество транзакций,
а тамарных накатили
как бы на state database, если потом блок
нам не понравился, мы его откатили
так же как бы а тамарных.
Там вернулись вот сюда как бы к предыдущему
как бы чекпоинту.
Это к тому, что
как бы блокчейн не какие-то там
космолеты, а на самом деле в общем по сути
используют штуки, которые
большие, там крупные
как бы сайты, высоконагруженные
приложения, как бы используют уже годами.
То есть там уже очень много
всего сделано. Там под капотом на самом
деле все те же самые механизмы
находятся.
Вот это про как бы
аналогии с базой данных.
Теперь про
сам шаг.
Смарт-контракт. Так, давайте по прошлому.
Материалы есть? Какие-то вопросы?
Тишина.
Все понятно.
Да, вопросов нет. Отлично.
Так, я еще хотел узнать
как идет ли у нас
запись. Да, идет. Отлично.
Так, поехали.
Вращаю обратно.
Теперь что же
с собой представляется собственно сам
смарт-контракт? Что на них можно
делать? Тоже немножко сегодня
поговорим.
Вернемся обратно как бы
к той нашей как бы прошлой табличке.
Что значит у нас там был Вася,
у него соответственно
был баланс эфира,
у него был анонс
счетчик его транзакций,
у него не было никакого кода,
вот, у него не было
никакого там сториджа.
Вот. И потом он задеплоил
смарт-контракт в сеть.
У этого смарт-контракта появился
адрес, что очень важно. То есть у смарт-контрактов
есть адрес.
У него есть баланс эфира. Когда он создал
он, например, был ноль, как бы, но
в принципе, если контракт позволяет
его код принять себе
как бы эфир, то он может как бы быть
и не нулевым. У него тоже
есть нонс у этого контракта.
Он меняется, если контракт
создает другие контракты, то есть
деплоит как бы там следующие,
как бы там контракты, то у него
нонс меняется.
Вот.
У него есть байт-код.
То есть прям вот
как, не знаю, как содержимое
экзешника, грубо говоря, по сути.
Машинные инструкции, как бы, которые
исполняются EOM.
А, и этот код, как бы, может обращаться
к своему собственному сториджу,
который представляет собой k-value.
Я вообще решил, наверное,
ну, я раньше всегда рисовал вот так вот,
типа кусочки в этом k-value, там, типа,
что у адреса один, там, такие-то данные,
у адреса два, как бы, вторые, другие данные.
Но это вообще не очень правильно,
когда я вам рисую, как бы,
ну, я очень люблю вот эту картинку,
когда здесь, типа, код,
а здесь у нас записано, типа, что там
у Васи, как бы, 100 токенов, значит,
а у Пети 200 токенов.
Вот просто может, как бы, показаться,
что они один за другим идут,
как бы, вот эти вот адреса, там, как-то в памяти
они, там, располагаются рядом.
На самом деле, ну, не так.
То есть вся адресация, она именно k-value,
то есть у этого есть ключ, как бы,
у этого есть ключ,
а value является,
как бы, вот этой вот штукой.
Вот, может, какой-то другой способ изобретать, рисовать
эту вещь. Вот.
Значит,
очень важная, как бы, история о том,
как устроен
storage-контракт. Это штука
такая, как бы, тоже
относится к тому, что я сейчас
рисовал.
Смотрите,
у меня,
один и тот же код, у меня есть какая-нибудь переменная,
variable a,
значит, она где-то, как бы, в storage-е находится.
Вот, вот здесь, вот у меня, вот здесь,
ссылается, как бы, на переменную a.
У меня там записано 100.
Как бы, потом я говорю a равно 200,
как бы, здесь становится 200.
И
вот этот вот код, представьте,
что он...
Ой, простите.
Тихо, ну.
Что этот код, он, как бы, не имеет никакого значения.
Что этот код, он, на самом деле, находится
на большом количестве разных компьютеров
с разной архитектурой.
Если бы мы этот код
запускали, как бы, в разных, там,
ну, не знаю, там, на JS
и в разных браузерах, на
C++, короче говоря, на разных
машинах, то у нас у этой
переменной каждый раз бы выделялся
определенный адрес памяти, какой-нибудь, там,
0x, там, не знаю, там,
fa0000001,
кто там на C, там, прогал.
Вот.
И эти адреса
этой переменной, они, на самом деле,
были бы разные. То есть в другом контракте,
как бы, по D2A было бы
выделено, было бы выделено другое
место в памяти с другим
адресом, там, и так далее, и так далее.
Значит, для того, чтобы
даже storage,
как бы, имел полностью детерминированный
вид на всех, как бы, компьютерах,
переменные в смарт-контрактах,
все внутренние, как бы, они адресуются
исключительно по ключу. Вот.
Причем довольно просто.
Смотрите, у меня есть смарт-контракт,
я объявил в нем первую переменную
размером,
ну, здесь у нас
все будет размером 256 бит,
практически все по дефолту, то есть любые
данные размером 256 бит, любые
ключи размером 256 бит.
Сейчас объясню, почему.
Я создал первую
переменную, и
грубо говоря, так называемый
слот, есть такое, как бы,
понятие в смарт-контрактах, вот этот вот слот,
как бы, его адрес
будет равен хэшу,
вот тот самый, как бы, там,
алгоритм хэширования, от
адреса контракта и
номера вот этого слота.
Вот это, как бы, называется слот
номер. Я
переменную a объявил первой, как бы, она
заняла слот 0.
Она стала, как бы, вот сюда. То есть
слот номер-то, конечно, 0,
и когда я создам, как бы,
переменную b, скажу, что там
b равно a,
и она у меня, переменная b, как бы,
попадет в слот номер 1,
хэш от контракта и от
единицы. Вот здесь у меня будет
переменная a, здесь будет переменная b,
которая там будет равна,
там, не знаю, там, 200.
Тем не менее,
то есть сам адрес
вот этой вот ячейки в сторидже,
он будет хэшом
от адреса контракта и
единицы.
Для чего это сделано?
Это сделано, чтобы на низком уровне
в той же самой k-value базе данных,
да, в нашей leveldb или roxdb
один и тот же
контракт работал всегда,
ну, чтобы вот эту информацию
о сторидже контракта хранить в
k-value базе данных.
То есть я на другом компьютере
синканул блокчейн,
накатил, как бы, свою state database,
у меня там вот по вот этому адресу
лежит переменная a
от моего контракта,
а по этому адресу
лежит переменная b от адреса.
Ну, от адреса контракта.
Я могу всегда ее найти.
И это будет абсолютно
одинаково на всех компьютерах.
То есть даже, как бы, значения переменных
вот эти, они, по сути, будут в блокчейне
реплицироваться через обновление
вот этой вот state database.
То есть кто-то выполнит транзакцию,
запишет что-то в b,
у b появится слот
в сторидже, этот слот
в сторидже, по сути, займет, как бы,
определенную, ну, там,
определенную данную
и запишет, как бы, вот в этот вот leveldb,
и
вот этот ключ значения,
они будут реплицированы.
Ну, и, конечно, войдет в state root, будет включено
в блок, там, и так далее. То есть каждые такие
операции вот с этими переменами,
которые находятся в сторидже,
они все выполняются в консенсусе.
То есть все изменения их
реплицируются. Это довольно,
как бы, важная штука, чтобы понимать, как бы,
что там внутри контрактов происходит.
То есть это, по сути,
как бы, не оперативная
память. Очень любят, как бы,
там, контракт, как бы, выглядит
так это по коду, как бы, что я
объявил переменную, она у меня равна, там,
тому-то, тому-то, но она там как-то сохраняется.
На самом деле это именно
сторидж.
Сторидж это то, что аналог,
я не знаю, записи на диск
в реальной программе. Вот.
А так у контракта, конечно же,
есть у него, как бы, и оперативная
память, memory,
ему же там что-то надо делать, ему надо
там, там, циклы какие-то делать, там,
что-то там разворачивать в память, массивы
в них там создавать, значит, бегать по ним,
что-то там считать и так далее. То есть там
тоже есть выделение памяти,
локация этой памяти,
ну, под определенные вещи. Ну, понятно,
есть, конечно, там и del-локация,
как бы, памяти, как бы, но она автоматом
происходит, когда транзакция завершается,
провод, все это выкидывается.
А так, по-хорошему, есть, да, действительно,
как бы, оперативная память. Поэтому не путайте, как бы,
memory есть в смарт-контрактах,
как бы, memory это
отдельная история. Это то,
что на момент исполнения одной функции,
как бы, есть у контракта,
то есть оперативная память,
а есть storage.
Вот, и
поэтому там часть переменных, как бы, относится
к storage, как бы, а часть переменных вы можете
объявить, как бы, в памяти.
Вот, это такая довольно важная штука.
То, что storage в случае успешного
завершения функции, если не будет
реверта, как бы, оно сохраняется,
так и вы, любая из данных, то есть вы присвоили
а, там, 200, как бы, и оно будет
все время 200, как бы, всегда,
как бы, во всех следующих функциях вы
обращаетесь к а, как бы, получите 200,
там, через 100 блоков, там, если
где-то обменений не было.
Вот. Это такое, как бы,
персистентное хранилище.
Значит,
сам код смарт-контрактов
мы сейчас тоже будем смотреть.
Давайте, может, прям сразу
сходим, какой-нибудь там глянем.
Простенький.
RapidEther. Вот здесь можно
посмотреть контракт его.
Там есть, правда, там
по-дурацки довольно. Sorry, там.
Не знаю, как побольше сделать.
То есть, вот так.
Значит,
так, тоже кратко, как бы, если по этой
штуке, как бы, пробежаться, то
на самом деле, в уме, как бы,
слово контракт можно заменить на слово
класс. Прям, вот, как
C++ класс. Здесь, действительно,
работает изо всех сил
объект-ориентированное программирование.
Солидить — это объект-ориентированный язык.
Что мы еще,
как бы, знаем, что у нас есть
в объект-ориентированных языках?
У нас есть конструкторы.
Здесь они тоже есть. То есть,
в тот момент, когда вы будете
деплоить, размещать вот этот ваш код,
как бы, у вас выполнится код конструктора,
который инициализирует какие-то базовые вещи
в сторидже.
У нас есть публичные
и приватные переменные.
Вот здесь тоже, как бы, есть там public.
Здесь, там, три вида, как бы, переменных.
Вот.
Имеются области видимости.
Если это public, вы можете снаружи к ней обратиться,
получить ее значение, использовать там
каких-то там внешних функций.
Если она private, то вы ее можете только
внутри контракта использовать.
Вот, снаружи не можете запросить.
Здесь есть,
ну, типы данных,
там, все это мы с вами как раз
на следующей лекции будем смотреть.
То есть, самые, как бы,
типовые солидите паттерны.
Здесь есть ассоциативные массивы,
там, массивы, как бы,
с динамическим размером,
фиксированной длины.
Вот.
Есть, соответственно, функция,
вот, собственно, их название.
У них тоже есть
области видимости.
Вот, есть всякие там ключевые словечки.
Например, payable означает, что можно вызвать эту функцию
и прислать в нее эфир.
То есть, я могу
создать транзакцию, сказать, вызываю функцию
deposit и прикладываю к этому вызову
10 эфира.
Вот. Соответственно,
контракт, если эту функцию правильно обработает,
он съест мои 10 эфира,
увеличит свой баланс на 10,
как бы, запишет там,
что-то себе, как бы, в storage про то, что
я принес 10 эфира.
Вот. Ну и, соответственно, функция там
закончится. Вот.
И есть функции
getter'ы, а есть функции
setter'ы. Так, чтобы я точно,
как бы, ничего не забыл.
Кстати, уберу вот это
окно, мне клип мешает.
Есть функции getter'ы, есть setter'ы.
Значит, getter'ы, вот это ключевое
слово view, это, по сути,
функции, которые ничего
не записывают.
И у людей сразу, соответственно, вопрос, блин,
ты же говорил, типа, что в блокчейне за все
платят, как бы, а что, за вызов
этой функции не платят?
Ну вот, да, здесь есть
проблема, за вызов этой функции не платят.
То есть, если я хочу вызвать total supply
у какого-нибудь контракта,
вот, смотрите, в rapid-эфир,
давайте у него вызовем функцию total supply.
ReadContract
здесь функция. Вот я хочу, короче, вызвать
у него функцию total supply, вот он ее возвращает.
Вот столько-то в rapid-эфире
было, соответственно, там, выдано,
там, напечатано пользователям
и так далее.
Как называется этот токен,
сколько у него десятичных знаков после запятой
и так далее.
Какой баланс этого эфира у какого-то адреса.
На эти вопросы,
на вот эти вот view'ы
мне нода отвечает,
в общем-то, бесплатно.
То есть, у меня
вот мой вот этот metamask,
мой клиент, как бы,
он идет на ноду,
он делает jsonrpc,
как бы, запрос, говорит
дай-ка мне функцию total supply
total supply
вот у этого контракта
и нода просто, как бы, лезет, соответственно,
сюда, там, в storage этого контракта
вызывает вот эту view'шную функцию,
которая view читает это значение,
как бы, отдает его мне бесплатно,
потому что никаких записей в блокчейн
произведено не было,
ни за что платить не надо,
никакие блоки сформированы не были,
но и, как бы,
view функции, они, по сути,
бесплатны.
Тут есть некоторая такая,
некоторый обман, потому что
по поводу того, что они бесплатны,
потому что, ну, они могут быть
не совсем бесплатны,
если у вас внутри вот здесь вот есть, как бы,
функция, которая пишет в write,
и она, как бы, внутри себя
вызывает
вот эту вот view функцию,
ну, которая считает, например, вот это вот
total supply.
То есть она ее вызывает
и потом использует ее результат.
Тогда, как бы, когда
майнер будет исполнять, как бы, вот эту штуку,
он, конечно, зайдет вот в эту функцию
и с удовольствием
вычитает с вас денежки
за то, что ему пришлось, там, лезть
в storage, что-то там обращаться,
число получать, там, load делать,
как бы, и так далее.
То есть вот эта вот стоимость, как бы, этой функции,
она все-таки будет приплюсована к газу.
Так что, как бы, view не то, чтобы
прям вот прям совсем бесплатный.
Если их использовать внутри, как бы,
других пишущих функций, они платные.
А если вы снаружи, как бы, дергаетесь,
то, пожалуйста, как бы, запрашивайте.
На здоровье, как бы, они, ну,
они открыты.
Вот.
Еще довольно важный, как бы,
кусок контракта
это так называемые ивенты.
Это такие, как бы,
события,
такой, можно сказать, как бы, особый вид
сториджа. Это, как бы, у нас будет
называться сторидж.
Грубо говоря,
ивенты это лог,
давайте я вот здесь, там, напишу, как бы,
это лог событий
контракта. То есть просто,
как бы, он тоже фиксируется
в блокчейне. То есть то, что у вас, как бы,
произошло вот здесь, вот,
emit, где у нас там.
Вот здесь, по сути,
вызывается ивент.
Ну, там, в новых версиях Solidity, на самом деле,
тут надо явно ключевое слово
emit писать.
Типа, произвести событие
withdraw.
То есть, вот этот чувак, msg sender,
адрес отправителя,
вывел столько-то
вот этих вот вадов. Ну, там, вывел
такое-то количество эфира, если все
хорошо, если здесь нигде ничего не упало.
Вот.
То тогда в этом логе появится
сообщение withdraw.
Withdraw, там, адрес,
там, не знаю, 100 токенов. Потом пришел другой
чувак, сделал, там, депозит,
там, A2, там, не знаю, там, 10.
И так далее, и так далее.
То есть это лог, который
привязан к контракту.
Вот здесь вот.
И, ну, в чем, как бы, его
важность? Во-первых, он
дешевый. Вот.
То есть он стоит дешевле, чем записать сюда
то, что вот, короче, вот этот чувак,
значит, положил 100 токенов, и это
его, там, депозит. Понятно, что здесь
значение, как бы, есть. Но
писать в лог, во-первых, дешевле. По газу,
там, 3000 плюс, там, количество
за каждый байт данных придется
заплатить. Во-вторых, из
контракта сходить в лог нельзя.
То есть контракт не может, как бы,
сходить и посмотреть, какие события произошли
вот в том контракте. Как бы, дай мне список,
там, ивентов, что-то отфильтровать. То есть
это такая, как бы, более, более тупое, как бы,
хранилище, которое просто сохраняет,
как бы, эти ивенты. Но они крайне удобные,
для клиентов.
То есть, когда я ходил вот сюда, там,
на компаунд,
на самом деле, когда я вам сказал, типа,
я подписался, типа, на
транзакцию, на самом деле,
чуть-чуть я схитрил, потому что
интерфейс подписался на
события, коллатер был
включен, или, там,
типа, деньги были положены. Как бы, он
подписался на вот это событие с
моим адресом. То есть, он подписался,
типа, и на попсабе висит
и ждет, когда произойдет
ивент, как бы, что
вот этот вот чувак, как бы, сделал
какой-то, там, не знаю, депозит.
И, соответственно, он висит, как бы,
с нодой общается, как бы, ждет, пока нода,
как бы, ему пришлет апдейт. Да, такое событие
произошло, вот этот ивент, как бы,
и, соответственно, можно, там, не знаю, извести
вот этот флажок. Поэтому
ивенты — это крайне важная штука
именно для, именно, взаимодействия
с блокчейном. Чем
еще они вам будут интересны,
как бы, эти ивенты? Это, если вы собираетесь
что-то там анализировать в блокчейне,
собирать, там, типа, не знаю,
инфу, короче, кто, какие,
там, какие были, там, не знаю, там,
сделки с этим токеном,
кто ходил, как бы, в этот контракт, кто, там,
не знаю, NFT-шки минтил и так далее.
То есть вы, когда, как бы, парсите,
парсите блокчейн, как бы,
вы бежите по блокам, из этого
блока получаете, по сути, пачку ивентов
и фильтруете
их.
И фильтруете их, соответственно, по адресу контракта,
по, там, по
топикам и так далее. Тоже чуть-чуть посмотрим
на этот код с вами, потому что
с этим, если вы займетесь блокчейном, вам тоже
придется работать.
Вот, ивенты — такой источник информации.
Так, поехали
дальше.
Тоже, что
очень важно, как бы, что один
контракт может вызывать другой
контракт. То есть у нас есть, как бы,
два контракта, AC-штрих
какой-нибудь, там, 0, там,
0 — неважно, у него тоже есть код.
Здесь есть специальный
апкод, специальная инструкция
call, которая,
как бы, может пойти
в другой контракт, исполнить там
функцию и, соответственно, вернуться обратно.
То есть,
опять же, когда вы
строите что-то серьезное,
то по большей части, как бы,
ваша система представляет не один
смарт-контракт, а много.
И они отвечают, как бы, за разные вещи.
То есть у вас есть какой-нибудь, там, базовый
контроллер,
здесь есть какой-нибудь, там,
пришел пользователь, делает какой-нибудь, там,
депозит, вносит вам 10
эфира.
На самом деле ваш контроллер, как бы, функцию
депозит, там,
исполняет, а 10 эфира
кладет на адрес
волта какого-нибудь, ну, то есть
такой, как бы, крепости, как бы, на которой,
как бы, хранится, там, не знаю, там, столько,
как бы, эфира от пользователей.
Контракт этот сильно простой, как бы, чтобы
его не ломанули, чтобы не утащили, как бы,
вот, весь эфир.
Затем, там, не знаю, там, следующий, там,
какой-нибудь контракт, в котором, там,
например, там, access,
access list,
там, кто, там, админы,
кто, там, команда,
кто привилегированный пользователь, там,
прописано, как бы, именно в этом контракте
его сториджи, и контроллер, как бы,
ходит сюда, типа, спрашивает, а вот этому
можно сделать, там, какое-то административное
действие, ну, в ответ, там,
тоже при помощи вот этого
кода и так далее.
То есть, все современные проекты
на, ну,
на эфире, как бы, представляют собой
целые пачки смарт-контрактов,
которые между собой
взаимодействуют. Давайте, там,
что-нибудь
посмотрим, там, мы будем
подробно смотреть,
ну, просто какую-нибудь репу.
Вот, собственно, как раз такая
достаточно простая, да, как бы,
репа, через которую, не знаю,
там, сотни миллиардов долларов прокачивается
вот, как бы, ее все контракты,
на самом деле, там, буквально, там,
раз-два, как бы, и плюну.
Один контракт, Factory,
который, кстати говоря, это Pattern Factory,
который в объектно-ориентированном программировании,
когда один объект, как бы, печатает
другие объекты однотипные,
вот этот вот Factory, как бы,
выкладывает в сеть, как бы,
по желанию пользователя контракты
V2Payer,
вот, ну, и там, соответственно,
там, при этом используется токен,
вот, то есть, смарт-контрактов у нас
на самом деле, всего-то, как бы,
в общем-то, ничего. И вот, если вы
посмотрите, да, кода здесь очень мало.
То есть, это вам
не backend, как бы,
здесь кода достаточно мало,
как бы, просто над каждой строчечкой
придется подумать чуть-чуть больше.
Вот.
Так.
Значит, это, что касается
смарт-контрактов. Ну, и
про Strictly Restricted by Execution Cost,
про это мы уже с вами
очень подробно в тот раз, как бы, поговорили.
Ни одна функция вот этого контракта,
этих контрактов, если мы вот здесь вот будем
смотреть,
вы здесь не найдете нигде,
например, циклов,
если эти циклы
не прям жестко, там, прибиты сверху,
там, чуть ли не константами.
То есть, там, не знаю, там,
for1, to, короче, не знаю, там,
максимум, там, десяток, как бы,
какой-нибудь, там, сущностей. То есть,
если вы посмотрите, они все прям линейные, линейные,
линейные эти функции,
максимально экономящие
место. Ну, то есть, например, там, в Uniswap'е
время
приводится к 32
битам просто для того, чтобы сэкономить,
как бы, 32 бита.
Таймстемп 64 бита,
как бы, а здесь, как бы, 32,
потому что надо пожать,
чтобы данные более эффективно
упаковались, там, в слоты. То есть, экономия
идет на таких, на спичках,
и ее здесь очень много.
Потому что
каждый раз, когда вы вот здесь вот, как бы,
пробуете что-то неоптимально,
то есть, вы запрограммировали, не знаю,
там, цикл, который жрет зря,
как бы, газ, вы какую-то функцию выполняете
больше, чем нужно,
больше, чем, там, один раз
за блок, платят за это ваши
пользователи. То есть, приходит
пользователь, отправляет транзакцию в
контракт, исполняет ваш код, как бы,
ваш код неоптимальный, как бы, и жрет,
там, 100 тысяч газа вместо, там,
60 тысяч газа, и пользователь платит
100 долларов вместо 60 долларов.
Именно поэтому,
собственно, и спрос, как бы, такой, с блок
чейн разработчиков очень серьезный
в плане, как бы, алгоритмов и структур данных.
То есть, если, как бы,
да, ну, как бы,
если ты, там, не знаю, там,
не понимаешь, как бы, там, сложности алгоритмов
или просто, как бы, там, не знаю, прям
в лобешник, как бы, решаешь, типа, задачу,
а, да, все, прям, запихали
в массив, пробежали, сортирнули,
как бы, и потом, и взяли, там,
верхнее число, то, в общем,
на солидите лучше, как бы, не идти программировать,
вот, потому что здесь, прям,
об этом надо думать на каждой строчке.
Это очень серьезно.
Вот. Активные
используются всякие, там, не знаю, там,
может быть, кэширование,
надо при этом, как бы, понимать,
какая транзакция,
куда, ну, какая пишет
сторч, какая пишет память,
какая потребляет, как бы, соответственно, сколько,
сколько газа, это, вот, довольно
серьезная история в солидите
разработке.
Дальше, что еще интересно,
как бы, такое рассказать про смарт-контрол,
про контракты, ну, в частности,
например,
здесь
различных хитрых математических
функций, их довольно-таки
мало, потому
что, как я сказал, как бы, все
операции, они
целочисленные, вот, и поэтому
практически с любой экзотикой,
которая у вас появится, например,
даже квадратный корень, как бы,
является экзотикой, как бы, вам придется
разбираться самостоятельно.
А из-за жестких требований,
там, к битности, к экономии,
зачастую
многие виды, как бы,
математики приходится
реализовывать самостоятельно.
Вот, например, здесь, как видите, как бы,
квадратный корень, квадратный корень,
как бы, сделан вручную.
Нету в солидите, нету, как бы,
апкода квадратный корень.
Вот, вам придется его, как бы, реализовать
самостоятельно, здесь этот вавилонский
метод используется. И то же самое
касается большинства математических
функций.
Собственно,
даже для, там, операций,
там, перемножения, как бы, балансов
здесь используется своя собственная
математика,
вот, для того, чтобы
это влазило. Почему здесь 100-112
бит, например, у них используется?
Чтобы 112 бит
умножить на 112 бит дало
224 бита,
и плюс к этим
224 битам добавить
еще 32 бита
вот того таймстемпа, вот этого времени,
которое было в пэре. И получится, как раз,
256 бит, который можно затолкать
в...
который можно затолкать ровно
в один слот
сториджа. Он, у него размер, как бы,
256 бит, и у него здесь будет, как бы,
один баланс, здесь будет второй баланс, а здесь
будет время. И получится, вот, ровно
256 бит. Это, вот, с точки зрения
потребления газа, крайне,
ну,
оптимально. Потому что пользователь платит
за каждый выделенный, вот,
этот вот слот, как бы, 256 бит.
То есть, с чего
я, как бы, вдруг приплевывал
операционные системы, как бы, к блокчейнам, да?
А потому что, вообще, как бы,
всякая, там, страничная
организация памяти, да, когда вам нужно
на одну переменную выделить 4 байта,
а операционка вам, на
самом деле, как бы, выделяет сразу целиком
страницу размером 4 килобайта,
да еще и делает это
лениво, то есть она отображает это на физическую
память, там, и там, и так
далее, соответственно, и
инициализирует ее только, когда вы
делаете запись в эту штуку. Вот понимание
этих механизмов, на самом деле, делает
понимание того, что здесь происходит
за смарт-контрактами, прям, очень простым.
То есть, потому что это все, в общем-то,
как бы, одно и то же, как бы, единственно
только, ну, сдобренное
key-value вот этими,
как бы, хэшами.
Вот. Так.
Теперь, значит,
про
ограничения, getter и setter,
значит,
вызовы контрактов, контракты
мы прям будем тоже очень подробно смотреть.
Здесь очень много всяких, как бы, нюансов
есть. Вот.
Теперь чуть-чуть
продолжим, как бы, про газ.
Я уже вам в тот раз, как бы, рассказал
про то, что каждая инструкция стоит, там,
сколько-то денег. Вот.
Соответственно,
вот мы поговорили про газ.
И
теперь чуть-чуть поглубже, соответственно,
что внутри, под капотом у этих
смарт-контрактов происходит и как работает
EVM. То есть это вот сейчас, наверное,
там,
основная история.
Значит, как я говорил,
EVM — это, по сути,
микроконтроллер, можно сказать.
Те, кто у вас, как бы, такой, как бы, виртуальный
процессор, просто сделан, как бы, в софте.
Вот. Там в софте есть объект,
как бы, у которого есть, как бы, свой
собственный, там, storage, у которого есть собственный,
там, не знаю, там, код.
Кстати,
на микроконтроллерах или ассемблере
многие писали, тоже, кстати,
интересный вопрос.
Ну, на ассемблере писали,
на курсе C++.
Ага.
Ну, это, кстати,
кстати, вот тот случай, да,
когда, вот, кажется, да, в институте, что
и когда мне это, блин,
пригодится, я
тут эти самые сайты на Django делаю,
как бы, а вы какой-то микроконтроллер,
какие-то ассемблеры, хрен его знает, куда это мне надо.
Здесь это довольно
важная история в блокчейнах,
как бы, причем, кстати,
реально во всех. То есть это достаточно
полезные знания, вот,
того, как работает, как работает, собственно,
сам микропроцессор, потому что именно так
работает виртуальная машина.
Даже при изучении C++
полезно, чтобы понимать, когда
компилируется, как.
Да, да, да, да, именно, как выделяется память,
там, и так далее. Ну, я могу сказать,
по моему, как бы, рабочему опыту,
даже если вот эти теоретические знания
из института о низком уровне, там,
всякие, там, параллельные программирования,
архитектуры, там, систем, там, и так далее.
То есть, если они, как бы, по жизни
и не пригождались, да, там, суперкомпьютеры,
там, я не программировал, да, как бы,
и, там, микроконтроллеры для роботов,
то, когда ты начинаешь решать
проблемы, например, в какой-то сложной
системе, там, высоко нагруженной,
там, не знаю, предположим,
предполагаешь, почему, как бы, вот, на этой
системе вдруг процессор, как бы, начал
прям, как ни в коня, жрать.
Или, там, почему память утекла, и так далее.
То тут, как раз, эти знания здорово
помогают. Потому что ты вспоминаешь,
а, блин, мы же здесь вот добавили, как бы,
вот, вычисления, такое, как бы,
блин, и, может быть, не оптимально, как бы,
оно жрет процессор, как бы, по ходу дела в нем.
Вот. То есть, оно помогает, на самом деле,
копать и находить проблемы.
Вот.
Ну, и тоже, как,
так, в качестве философского, как бы,
напутствия, да, как бы,
написать систему, которая работает, несложно.
Вот. Но,
как бы, в тот момент, когда начнутся
проблемы, когда эта система, как бы, подойдет,
как бы, к пику своих
возможностей на текущих машинах,
то есть, когда перестанет хватать сервировка, да,
они станут, как бы, уходить, там,
в 100%, когда начнутся проблемы,
вот, с производительностью, вот, в этот момент,
как бы, прям, вот это
непонимание низкоуровневых
механизмов, оно прям вернется
сразу же, как бы, сторицей, потому что
придется очень долго, как бы, колупаться,
что там упало, почему, как бы,
что мы там такого сделали, как бы,
и так далее. То есть, вот это вот
эффективная утилизация, как бы, железа
штука важная. И если вы собираетесь
в крупную компанию, как бы, идти,
то там, возможно, как бы,
оптимизация пары строчек
кода может спасти компании, там, не знаю,
миллион долларов в месяц, спокойно,
на серверах, просто потому что они перестанут,
их не нужно будет такого количества.
Так что это важно.
Вот. Значит,
итак, EVM у нас представляет
собой такой, как бы, процессор,
мы бежим, как бы, по инструкциям,
у него есть
instruction pointer,
который говорит, на какой я сейчас
инструкции нахожусь,
у него есть, соответственно, память,
если эта инструкция делает какой-нибудь
M-load, там, не знаю, там,
загружать какие-то данные с памяти,
то процессор, как бы, сходит по вот этому адресу
в оперативную память, возьмет данные,
загрузит их куда-то там
в регистр, у него есть
stack,
ну, вот это, соответственно, memory называется,
у него есть обязательно stack,
значит,
как stack работает, тоже, как бы, надо знать,
да, всякие, надеюсь, как бы, все знают,
это push-pop,
да, то есть положили на stack что-то,
оно, как бы, попало вот сюда,
мы сделали push,
и stack pointer,
то есть указательно переместился
вверх, как бы, еще сделали
push, как бы, он еще вверх поместился,
сделали pop, как бы, мы
вернулись вниз, как бы, про вот эти вот забыли
данные.
Чем stack, как бы, удобен, да, тем, что
для того, чтобы, как бы, следить за stack-ом, нам
достаточно хранить одно число, вот это вот,
stack pointer, и все, как бы,
то есть и тогда у нас вот эти все push и pop
как бы прекрасно работают.
Соответственно, она
бежит по инструкциям последовательно,
исполняет, как бы, каждую инструкцию,
вот, и, как бы,
до тех пор, пока, как бы, не наткнется,
типа, на все там, типа, окей, я
закончила.
При этом, как мы с вами в тот раз, как бы,
выяснили, она каждый раз добавляет
сколько было
потрачено на данную инструкцию
газа, то есть у нас
есть специальные, как бы, цены, как бы,
на вот этот вот газ,
вот, и если
этот газ, газ,
газ,
становится больше определенного лимита,
какого-то там серьезного, не знаю, там,
10 миллионов газа, например, там,
то делается реверт,
то есть все откатывается,
и, как бы,
транзакция падает с
сообщением out of gas, но при этом
включается в блок, как бы, и вам придется,
как бы, заплатить за это. Лимит
этот указывает пользователь, то есть вы
в своей транзакции говорите, я готов
потратить не больше, чем там
100, чем 100 тысяч газа,
как бы, то есть это, в принципе, на совести
пользователя.
Вот. Чисто технически, если я укажу
бесконечный лимит, ну, у меня программа, как бы,
будет крутиться, пока не доберется
до, так называемого, hard, hard
лимита. Значит,
как это все дело выглядит?
Вообще, если мы будем строить
блокчейны, да, и нам нужна
будет вот именно вот эта вот механика,
она во всех блокчейнах на самом деле
присутствует, то есть где-то там по-другому
чуть-чуть считается, как бы, вот эти вот
попугаи, то есть сколько вы потратили
вычислительных ресурсов, но там, где они считаются,
как бы, это не блокчейны.
Вот. Блокчейны, как раз, только там,
где это считается, как бы,
и смарт-контракты.
Мы бежим. В принципе, можно построить
несколькими способами. Значит,
первое — это написать свою собственную
виртуальную машину, что и сделал Эфир.
Они написали, как бы, EVM, вот здесь
всякие, можно даже посмотреть примеры
инструкций,
там, не знаю, там, проверка является
то, что она лежит на стейке нулем.
Затем, если является,
то условный переход, там, туда-то,
туда-то, вот на вот это вот AE,
значит, куда-то.
— Какой уровень выполняет стэк?
Это стэковые машины?
— Да.
Вот. Я
прям про стэк сейчас,
ну, я сейчас прям подробно расскажу.
Потому что здесь есть
серьезные отличия.
Это значит написать свою
виртуальную машину. Второй
подход, как бы, который, на самом деле,
к которому идет прям очень широкая работа,
как бы, — это использовать WebAssembly.
WebAssembly — это
наш новый с вами, короче,
JavaScript,
такой, когда у вас есть браузер,
и вам здесь надо, там, 3D-модель нарисовать,
как бы, и крутить ее, и сделать это на
JS, как бы. Вы когда попробуете
сделать на JS, как бы, вы офигеете,
как бы, какая у вас будет производительность,
вряд ли у вас это получится.
И для этого появился стандарт
WebAssembly, который позволяет вам
написать программу, как бы, на
таком ассемблере. Вот он
вот так вот приблизительно выглядит.
И просто
прямо на JS-кой странице, типа,
сказать, там, JS, там, не знаю, там,
compile, там, что-нибудь там,
JS, там, .exec, вот этот вот
ассемблерный код. И в браузер
встроена виртуальная машина,
которая исполняет вот этот WASM,
и она делает это, там, в тысячу раз быстрее,
чем это делать на QNAME или каким-нибудь
при помощи JS-а.
Пробрасывает прямо в процессор инструкции,
там, и так далее. То есть
эта штука в тысячу раз быстрее, чем
такой, как бы,
JavaScript на стероидах, как бы,
ассемблерный. Тоже очень
популярная, как бы, штука.
И, конечно, хотелось бы, да,
писать смарт-контракты именно
на WebAssembly. Тем более, как бы,
WebAssembly
у него есть компиляторы,
компиляторы, которые
компилируют вот этот вот WASM
в WebAssembly
прямо там, ну, что хотите, хотите, там,
Python, JS, короче говоря,
там, Rust,
и так далее, там, не знаю, там, C,
C++. Все это, как бы, можно просто
компилировать именно как раз
в WebAssembly, и он будет исполняться в браузере
со всеми
штуками. Но у нас, конечно,
на WebAssembly в блокчейнах,
как я говорил, как бы, накладываются
требования по детерминизму,
поэтому у вас вот этот WebAssembly
в чистом виде, вот как в WebStore
стандарт, как бы, он не используется
в блокчейнах, потому что у него внутри
здесь может быть, как бы, какой-то рандом,
у него там есть
получение текущего времени
внутри этого WebAssembly, там, у него есть,
короче говоря, FPU
инструкции, и они все, как бы, ломают
детерминизм, вот. Поэтому
там, где WebAssembly используется,
в частности, там, в Polkadot
используются вот эти
смарт-контракты на WebAssembly в EOS,
еще там, на самом деле,
в кучу языков, да и эфир, в общем-то,
тоже, как бы, у него есть там
EIP и там стандарты
и подход к снаряду, они тоже,
как бы, хотели переезжать на WebAssembly,
вот, пока, как бы,
не переехали там, просто WebAssembly
в этой виртуальной машине, вот это
выпиливается и остается,
как бы, голый WebAssembly,
ну, такой, как бы,
детерминированный, вот. С ним
уже, там, соответственно, можно работать.
Ну, еще, в принципе,
один из кандидатов, как бы, это
и Яловский, и, там,
C-Sharp, короче, Bytecode,
вот такой, ну, как бы, чем не виртуальная машина
софтовая, как бы, в теории, как бы, тоже
можно использовать, но
тоже придется, как бы, поколдовать детерминизм,
чтобы ничего вот этого, как бы, не было.
Вот.
Ну, вот, часто бывает, что, как бы,
пишут блокчейны,
типа, у нас есть смарт-контракты, но они заботятся
о вот этом детерминизме, поэтому,
как бы, да, имейте в виду, в эту ловушку
не попадаете, там, просто не понимают,
как бы, люди.
Вот. Значит,
по поводу stack-based
машины. Значит, что, значит, вообще
stack-based,
stack-based
и register-based?
Мне кажется,
все знают, что это такая машина.
Ну,
не знаю, вот, не уверен,
если кто-то, как бы, на ASME, как бы, не писал.
Посмотрите, у меня есть какая-то
функция, которая принимает, как бы, два
аргумента, значит, она что-нибудь, там, делает
A плюс B, короче, возвращает,
там, типа, делает return,
return
A плюс B.
Вот. Такая. Я ее,
соответственно, в ASME пишу.
Вот.
И, значит, как
выглядит стековая машина? У меня есть
stack.
И,
как бы, вот эти слова stack и register,
на самом деле, ну, прям можно
воспринимать, как парадигма
передачи параметров функций. То есть,
каким образом функция получает свои
параметры. В стековой машине,
как бы, вот этот код вызову этой функции,
когда я сделаю, там,
F от 3 и 5,
вызову, как бы, ее,
то мне
компилятор создал следующий
код. Он сделает push
5, там, push
3 или push 3
push 5, как бы, там, по-разному.
Затем вызывает функцию
сложить
and,
ну, и потом, соответственно,
ну, не знаю, там, это
return, короче говоря, или, там,
не знаю, там, загрузить
со стека, как бы, результат,
там, не знаю, там, load, короче говоря,
там, в какой-нибудь, там,
память. Значит,
как это будет выглядеть? Сначала я положу
на stack 5, потом
я положу на stack 3, потом
я вызываю функцию add, которая, что делает?
Она делает pop
3, то есть она снимает, как бы, 3
со стека сначала, потом снимает
5 со стека, а потом кладет на stack
8. То есть делает push, как бы, вот,
8.
Ну, и, соответственно, я знаю,
что после выполнения этой инструкции, как бы,
на стеке будет результат вот этих вот
вот этих вот операций.
То есть это, как бы, простой достаточно способ.
А
register-based
виртуальные машины, они, как бы,
работают как? Они, на самом деле,
делают не push, а они делают
давайте в
первый регистр запишем 5,
затем, там, в EBX
запишем 3,
а потом, как бы, вызовем add,
там, там, EACS, там, EBX,
там, и так далее. То есть они, как бы, будут
использовать регистры,
как, собственно, используют наши,
как используют наши процессоры, там,
всякие intelовые, там, рисковые, и так далее.
Вот. И тогда в регистре
EACS, как бы, уже появятся, там,
результаты от 8, и мы его запишем
в память. То есть в теории
можно было бы сделать EVM, как бы,
и регистровать, то есть сделать, там,
нам пачку регистров договориться
о том, как между ними продают
передаются параметры и делать
вот эту вот стековую машину.
Значит,
у регистровой машины,
которая, там, напрямую работает
с процессором, у нее, наверное,
у нее, в общем-то, есть, как бы, преимущество,
потому что операции с регистрами, они быстрее, чем
операции со стеком. То есть
процессор гораздо быстрее, как бы, работает,
там, все перекидывает, как бы, в
регистрах. Если, там, дальше вот это
используется для дальнейших вычислений, все будет
прям сильно-сильно быстрее, не надо
в память ходить, там, и так далее.
То есть, это преимущество у регистровых
машин есть. Ну, еще можно, там, разные
окна регистров использовать, если вот
эти заняты, можно потом пойти, там,
ЕЦХ, ЕДХ, как бы, их, там,
современных процессоров, этих процессоров,
этих регистров немерено.
Вот, можно кучу всяких разных, там,
оптимизаций делать, но
это бьет, правда, по детерминизму
исполнения. То есть,
потому что здесь
внутри есть всякие предсказания, там,
переходов, и вот эти вот окна
регистров в процессоре, то есть, когда
у процессора, как бы, один и тот же набор
регистров, он мгновенно переключается
между, там, десятками, сотнями,
как бы, версий. Наш
процессор, когда мы в операционной системе
работаем, он постоянно между процессорами
переключается, и он, по сути, сейчас
он выполнял, там, Notepad,
а сейчас ему надо, как бы, в часы
как-то переключиться, Clock. Он раз, короче,
перескочил, сразу следующий контекст,
там уже другой набор регистров.
Потом, там, еще какой-нибудь, там, Scheduler,
как бы, там другой набор регистров, он, там,
работает постоянно, как бы, с разными
контекстами. И
поэтому, прям, какого-то такого четкого
софтового детерминизма от
регистровой машины
сложнее его реализовать.
Ну, и код сильно сложнее, как бы,
чем у стековой машины. А еще,
что важно, если у вас
вместо стековой машины находится такой
софтовый процессор, как бы, с регистрами,
то вам, чтобы сохранить его состояние,
если вам нужно
save сделать,
то вам нужно сохранить состояние
регистров. То есть, вот этот, вот этот,
вот этот, вот этот, чему они равны, короче
говоря, там, и так далее.
А у стековой машины, чтобы сохранить
его состояние, надо просто, как бы,
сохранить stack pointer,
вот я нахожусь, вот, на этой инструкции,
у меня instruction pointer,
то есть, ну, на какой
инструкции я стою, и
на каком месте стека я нахожусь в оперативной
памяти. Все, как бы, вот этих двух чисел,
как бы, достаточно, чтобы, там, пойти сделать
свои дела какие-то, потом вернуться,
как бы, и просто продолжить исполнять.
То есть мне, чтобы контекст установить, достаточно
всего двух чисел. Вот.
Ну, и стековая машина гораздо
более предсказуемая
в плане, как бы, поведения.
То есть, как бы, все
операции очень-очень сильно
однотипные, то есть
нет никаких, там, возможностей,
там, сделать, если мы A и B
писали в эти, например, регистры,
а на другом компьютере решили вот через вот эти
регистры сделать сложение, как бы, пожалуйста.
Ну, то есть, все вот это вот должно,
как бы, хендлиться. Вот.
Но, тем не менее, как бы, можно делать и так,
и так, и была выбрана, как бы, стековая
машина. Ну, я могу сказать, что
например, в блокчейне TON,
который,
Telegram, который строился там,
есть TVM, короче, и они тоже
выбрали стековую машину.
Вот. Что, как бы, для блокчейнов,
как бы, более правильно.
Но она, знаете, она такая, она более ровная,
она более предсказуемая, она более простая,
как бы, в ней меньше
может быть уязвимостей, связанной
с тратой ресурсов.
Различно. А вообще,
если взять какой-нибудь просто код,
как бы, того же, как бы, там,
современного смарт-контракта и скомпилировать
его в WebAssembly, в Wasm,
то у Wasm есть еще одна
проблема.
WebAssembly разрабатывался для того, чтобы вы
в своем браузере, да, могли
крутить 3D-объекты.
То есть, там есть, там предусмотрен
код, как бы, который может вам взять,
как бы, и заалоцировать, там, не знаю, там,
10 мегабайт оперативной памяти.
Там, не знаю, какого-нибудь объекта
и пойти, там, с ним, как бы, работать
и так далее. То есть, там очень много
аллокаций памяти. То есть,
выделить память под объект,
а когда вы работаете с объектами
вот такого размера,
у вас ваш аллокатор памяти,
он может, там, заранее, как бы, что-нибудь резервировать.
Там, выделю я, пожалуй, сейчас 10
килобайт вот этому чуваку, но еще вот здесь
вот, как бы, такой кусочек выделю, как бы,
вдруг он захочет потом расширить этот массив,
чем-нибудь дописать.
Дай-ка его, и вот здесь я тоже
с запасом сделаю, там, еще
что-то. И получается
так, что очень простой
код на, грубо говоря,
самая простая логика
в АСМе, она может порождать большое
количество аллокаций
аллок и фри.
Ну, и освобождение, как бы,
памяти. Просто потому, что у вас думают,
ну, а вдруг сейчас, как бы, в этой переменной
вдруг появится, там, не знаю, там, 10
мегабайт, как бы, а вдруг этот цикл
сейчас будет, там, какой-то, там, безумный, там,
и так далее. То есть, там есть, там, всякие, как бы,
оптимизации. То есть, для блокчейнов он не
очень-то подходит. Поэтому
в блокчейнах под WebAssembler
пишут, как бы, свои собственные
компиляторы. У Polkadot есть свои
собственные, там, однопроходные компиляторы
для WebAssembler. То есть, его все время нужно
докручивать. Вот.
Поэтому пока что
в смарт-контрактах победили специализированные
виртуальные машины.
Вот. Они являются наиболее такими
востребованными.
Так.
Время 13.40.
Мы уже час 40 с вами проговорили.
Поэтому я предлагаю сейчас перерыв.
Давайте
на 15 минут. То есть,
до 13.55.
В 13.55 я вернусь.
Раз чайку попьете.
Так. Все.
Тогда перерыв.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
Продолжение следует.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
55 мм.
То есть видно, что это как бы там запушили одно значение, другое значение, сохранили в память куда-то там, выделили, соответственно, в памяти кусочек, запушили, вызвали там какую-нибудь там функцию, которая вернула там размер входных аргументов, сравнили больше-меньше, условный переход.
То есть, в принципе, похоже как бы на работу с ассемблером, вот, и как бы все смарт-контракты, они представляют собой вот этот вот, собственно, набор как раз обходов, вот они как бы их байты, там, когда мы, скажем, выкладываем контракт в сеть, то, по сути, его машинные, ну, вот прям, как бы, собственно, байт-код его функции, вот он находится вот здесь вот где-нибудь там в инпуте, то есть достаточно как бы большой, вот можно, например, посмотреть.
Вот, у нас вот так вот все, наши контракты, этот вратит эфира.
Так, ну, будет, будет очень долго, не, на самом деле, можно посмотреть самую первую, как бы, его транзакцию, когда он только был создан первый раз, там, last, как бы, контракт creation, то есть в тот момент, когда он был создан.
Так, ладно, что-то он тут уже прям не доматывает.
Вот, и там можно увидеть, соответственно, байт-код контракта.
Байт-код контракта, который там размещался, он это сейчас, в общем, не так критично.
А можно вопрос?
Да.
У нас же показаны были разные байт-коды, да, естественно, как они вообще не разные байт-коды запускаются?
Ну, грубо говоря, сначала, сначала я создаю транзакцию create-контракт, create-контракт, у меня вот здесь внутри находится как раз байт-код моего контракта, вот эти вот там 6060,
6040, 52, вот это вот прям, он по сути, как бы, весь, как бы, байт-код контракта с определенными штуками.
И когда майнер применяет, когда майнер применяет, как бы, вот эту вот транзакцию, create-database, он создает, как бы, запись, что теперь, как бы, есть контракт по новому адресу, вот.
Датадес, кстати, вычисляется из моего, вот, из этого, из АВАСи, вот, там, с балансами фиры, там, с пустым нонсом, как бы, сюда прям копируется, вот,
байт-код, на самом деле
не целиком, там, за исключением
конструктора,
и теперь, как бы, он может вызываться.
То есть, на самом деле, может быть, как бы, много контрактов
с одним и тем же байт-кодом.
Пожалуйста, как бы.
Но это байт-код EVM, да?
Байт-код, да, именно EVM.
А если в AppAssembly
он транслируется в EVM?
Нет.
Но имеется в виду, что вы сюда
разместите, как бы, можете любой мусор
здесь разместить, но EVM его не обработает.
Конечно, в процессе он, как бы, при помощи EVM.
Вот.
Я так понимаю, в эфире
используется только EVM?
Да, в эфире только
EVM. Ну, в смысле, как?
Есть история,
есть, как бы, предложение
компилировать, солить, ну, чтобы
EVM умел еще, как бы, и
в WebAssembly байт-код.
Ну, значит, будут контракты, как бы,
здесь, которые
на WebAssembly, как бы, написаны. Здесь будут инструкции
в WebAssembly идти.
Вот.
А, то есть это просто
для общего развития. Да, да, да.
А так-то, на самом деле, да, как бы,
в эфире это в основном EVM. Но, и
как я уже говорил, она, в общем, по сути
является победителем
в гонке, как бы, смарт-контрактов,
потому что даже тот же самый
WebAssembly, который, казалось бы, ну, блин, ну,
как, это же стандарт, там, у Mozilla, там,
Google использует этот WebAssembly,
там, значит, все, там, поддержка, там,
машины виртуальные.
Но все равно его приходится допиливать
для блокчейнов. Как бы, лучше оказалось,
как бы, проверенное уже, там,
сколько, 7 лет, как бы, этой EVM,
которая кучей
детских болезней переболела.
То есть огромное количество изменений
в security, там, во всем, там, были сделаны.
Я обещал поговорить, как бы, про
стоимость газа.
Вот. И вот, собственно, как раз
и поговорим
сейчас, да, просто для, как бы,
примера. Ну, вот, например, там,
Push, да, это... Можно вопрос, пока я не забыл?
Да, да, да.
Вот. Вы скинете потом презентацию
в чат? Да, да, да.
Будет вместе с записями, как бы, да.
Будет все рядом лежать.
Не волнуйтесь.
Значит,
ну, просто так, по стоимости, да, как бы,
то есть мы просто взяли из головы
какие-то, там, не знаю, очки, как бы,
какие-то, там, не знаю, execution costs
и так далее. Придумали свою
собственную виртуальную машину. У нас вот такая
вот, как бы, куча инструкций.
И давай им, значит, цену назначать.
Но операции со стеком у нас должны быть дешевые.
Да, там, три, как бы, там,
запушить, как бы, значение на стек.
Ну, сложение, понятно, как бы, что там,
прочитали пару значений, процессор
сложил.
Значит, там,
здесь я что-то прям,
ну, наверное, не очень,
как бы, точно указал, как бы, обратились
к оперативной памяти, и эта штука уже, как бы,
сильно потяжелее. Потому что неизвестно,
сколько я хочу сохранить. Если я хочу сохранить
килобайт, как бы, и, там, мегабайт,
то у меня должна быть разница
в тысячу, как бы, по цене.
То есть, поэтому написано, там, перслот.
То есть, оценивается по количеству
выделяемых слотов эта история, там,
наверное, трешка, я, наверное, прям написал.
Там,
jump, условный переход.
Ну, это, собственно, как у нас везде,
как бы, ну, везде есть,
как бы, условный переход. Без него компьютер
невозможен, как бы, и тюринг полный,
как бы, вообще, хоть какие-то языки.
Поэтому, вот, если у нас условный переход,
проверка условий стоит 10.
И вот, мега-дорогие
операции.
Очень сильные, короче. Это загрузка
из сториджа и сохранение
в сторидж. Почему самая
дорогая, ну, сохранение в сторидж,
ну, потому что вы сохраняете свою переменную
в сторидж, вот в эту k-value баз данных,
и она будет скопирована на тысячи
компьютеров в эфире, как бы. Поэтому, да,
за это, как бы, придется заплатить.
Заметьте, сохранить одно значение
стоит, ну, прямо с нуля, как бы, у вас
пустой контракт, вы просто какое-то значение
сохраните в сторидж, стоит 20 тысяч газа.
При этом перевод
эфира стоит 21 тысячу
газа. То есть, вот, просто, как бы, послать
кому-то эфир будет стоить, как бы, там,
есть у нее, там, base cost, как бы, основная
цена 21 тысяча эфира.
Вот.
Сохранение одного значения, там,
20 тысяч. Вызов
другого контракта.
Понятно, что штука, как бы, сложная,
как бы, ну, на сам кол, как бы, надо, за него
надо заплатить, потому что нам надо
для этого, там, глобальные перемены
подтянуть, там, контекст вызовов подготовить,
и так далее, как бы.
Но, по-хорошему, когда я
иду из одного контракта в другой, да, то
у меня, как бы, газ с этим вызовом передается.
То есть, я сейчас, там, не знаю,
там, бегу по первому
контракту, потратил 50
тысяч газа, потом у меня происходит
вызов, я иду в другой, в другой контракт,
там продолжается исполнение,
здесь тоже, как бы, газ суммируется,
я потратил, там, еще, еще плюс 22
тысячи газа, как бы, вернулся
обратно, и у меня уже здесь 72,
ну, и продолжу дальше.
То есть, там, там тоже, как бы, механизмы
довольно, там,
разные есть, можно с вызовом послать, там,
любое количество газа, какое вам нравится,
то есть, все это делается.
Ну, и то, что я говорил про лог, это про
вот эти, вот, ивенты,
которые в контракте
происходят.
То есть, вот эти, вот, которые
депозит выбрал,
господи ты боже,
сори, намотал.
Вот он. Вот эти, вот,
то, что в момент трансфера происходит
ивент трансфер, в момент депозита
происходит ивент депозит, вот,
они стоят соответственно довольно дешево вот 375 плюс ну плюс цена короче говоря ну за размер
данных то есть ни одного байта еще раз напоминаю как бы ни одни 1 байт бесплатно как бы не процессе
если говорить о наборе инструкции здесь есть соответственно обходы мы видим по сути в общем
то то же самое описание там виртуальной машины как ассемблера да вот там сложение на стеки
должно быть два числа на выходе на стыке будет как бы в сумму умножение деление все как бы
понятные истории сравнения сравнение двух чисел да там на стыке будет результатом труды фолз тоже
все как бы известно там сравнению с нулем там и так далее так далее сдвиги первое наверное
интересная инструкция на котором мы натыкаемся от инструкции сша 3 который нету как был в
современных процессах
микроконтроллеров крайне важный который считает хэш от данных в оперативной памяти то есть вы
говорите как бы там где оперативной памяти лежат данные сколько байт прочитать и от них надо
посчитать хэш вот он стоит соответственно но он считает как раз хэш вот этот алгоритм хэширование
кетчуп 256 который еще называют не называют официальное название сша 3 то что это третий
международный стандарт хэширования который всем миром принято
алгоритм хэширования 256 бит и вот он как бы ключевой в эфире весь эфир построен вот на этом
как бы кичаки мы его дизайн будем рассматривать на симметричных микрографии обход который получает
адрес текущего контракта на стыке обход который получает баланс эфира данного адреса пожалуйста
как бы там ну там всякие там типа кто вызвал кто вызвал этот контракт сколько он эфира послал вместе с эфиром
то есть мы сейчас выполняем как бы транзакцию и у нас есть по сути глобальные перемены когда мы
процессе наш контракт этот код как бы бежим к нему а нам еще вдобавок как бы сюда передаются глобальные
перемены это то есть кто отправил транзакцию сколько предложил ему денег вот инструкция
которая позволяет параметры загрузить связанные с этим вызовом колдата это как бы называется вот еще
такая как бы интересно инструкция код сайдс размер кода то есть она довольно тупая как бы
из того что я вам рисовал у васи как бы но у него там баланс как бы у него кода никакого
нету а вот у нашего контракта как бы код есть вот эта инструкция она просто выдает размер
как бы кода то есть можно при помощи ее узнать как бы на этот адрес является контрактом или
просто адресом с эфиром вот с этим тоже там много связано безопасности тоже как бы поговорим
Вот там всякие, и так далее.
Значит, Coinbase — это довольно интересная штука.
Когда майнер будет исполнять смарт-контракт, вот в этой переменной, блок Coinbase,
то есть можно в смарт-контракте обратиться, получить адрес майнера, который этот блок произвел.
То есть вы можете в текущем блоке получить адрес того, кто этот блок произвел.
Когда отправлять транзакцию, вы этого не знаете.
Но когда транзакция будет исполняться, понятно, что майнер подставляет сам адрес того,
адрес того, кто произвел блок, и вы получите, соответственно, его можете в контракте использовать.
Мега важная штука — блок timestamp, по сути, получение текущего времени.
Как я говорил, у всех транзакций в одном блоке одно и то же время текущее.
Это время вот этого блока.
И без всяких там...
Без всяких расхождений.
Ну, там номера блока, difficulty.
Важная довольно штука — газ-лимит.
То есть сколько в этом блоке максимально может быть потрачено газа, причем как бы на все транзакции.
Ну, то есть сколько как бы в данном блоке всего, как бы вот этих попугаев на все транзакции будет.
То ли всего, а может быть и на данную транзакцию какой-то там hard-limit, честно говоря.
Уж как бы наизусть о спецификации, конечно, не знаю.
Важный параметр — chain ID.
То есть это как бы идентификатор сети.
Видите, здесь там MyNet, Robsten, Girly и так далее.
То есть каждый форк эфира, ну, такая как бы копия эфира, которая хочет как бы у себя реализовать EVM,
и чтобы все контракты были совместимы, как бы чтобы они правильно возвращали как бы идентификатор цепочки,
то в разных блокчейнах chain ID разный.
Например, если я вот здесь вот там выбираю как бы между там Girly, Ethereum, MyNet,
по сути у меня будет в транзакциях меняться вот этот вот chain ID, а контракты могут это дело проверять.
То есть там твоя транзакция как бы для этого chain ID как бы предназначена, вот.
Затем как бы баланс самого контракта, там, короче, там базовые фичи, сейчас чуть-чуть тоже о них поговорим.
Загрузка память — mLoad, mStore.
mStore.
mStore там одного байта, как бы это операция с оперативной памятью.
То же самое с mLoad и mStore, такие же операции, но со стороджем.
Здесь уже видите, как k-value, здесь уже никакие не обсеты, вот.
Jump — условный jump, вот, ну и дальше как бы много разных видов пушей, которые нам нужны.
Ну а dupe — это как бы дуплицирование значения на стеке, ну это очень часто нужно как бы,
вы там получили результат из функции, как бы вы ее используете в следующей функции и хотите предыдущий результат тоже сохранить на стеке, вот.
Ну и куча всяких разных штук, как бы связанных с операциями на стеке, свапы, как бы это все для того, чтобы более эффективно все получалось, вот.
Запись событий, ивентов, вот этот вот log и так далее.
Здесь есть как бы log для разного количества аргументов.
Вот.
Сам call — вызов другого контракта.
Вот обкод очень важный, как бы create, который создает новый контракт.
Он говорит там типа «забери байткод этого контракта и создай как бы новый контракт по определенному адресу».
То есть контракт может не только обращаться к другим контрактам, он может еще и deploy другие контракты.
И эта штука тоже используется, тоже посмотрим.
Вот.
Затем там различные вызовы.
Call, call code, delegate call — тут много.
Вторая версия, create2, тоже про нее поговорим, то есть еще один способ deploy контракта.
Static call — это когда мы обращаемся к библиотеке и говорим, в течение этого вызова как бы ничего в сторидже поменяться не должно быть.
Ни в коем случае мы не будем трогать вообще сторидж как бы ни в каком виде.
Такой вызов подешевле, вот, и нужен для обращения к библиотекам.
Ну, есть еще revert.
И еще мега интересная инструкция, которая называется self-destruct.
Значит, что делает self-destruct?
Self-destruct удаляет полностью весь код контракта, то есть он становится как бы нулевым.
Затем берет, короче говоря, весь баланс эфира, который есть, ну, есть у этого контракта и отправляет его тому, кто этот self-destruct вызвал.
Ну, то есть, по сути, вычеркивает отсюда полностью, как бы вот такой контракт.
полностью вот эту строку, весь эфир возвращает тому,
кто этот селл-дистракт, не тому, кто вызвал, а на самом деле,
то есть вызывающий селл-дистракт должен позаботиться о том,
кому отправить эфир, если он здесь есть, конечно.
По поводу селл-дистракта идут очень жаркие споры,
и, скорее всего, его скоро выпилят.
То есть его просто не будет, его просто не будет.
Конечно, хотелось бы экономить место в блокчейне,
вот такие вот контракты выпиливать,
но это создает очень серьезные проблемы для работы нод,
потому что нода качает новые блоки, качает новые блоки,
она тратит свои силы на поддержание стейта,
здесь контракт жив, здесь контракт жив,
а пользователь говорит, какой там мой баланс в этом контракте,
а нода еще не догнала до нового блока,
и она не знает, вдруг здесь будет селл-дистракт этого контракта,
может, я ему вообще должна ошибку или ноль выдать,
а я еще не знаю, возможно, в следующем блоке будет селл-дистракт,
и она тратит свои силы на то, чтобы индексировать эту всю штуку.
Гораздо проще было бы вообще не иметь возможности удалять,
пускай все там живет, и ничего не меняется.
Вообще, опять же, в базах данных сама инструкция делит,
она довольно коварная, то есть кажется, что там все просто,
как бы, удалить данные, но, на самом деле, если вы начнете думать о том,
как работают всякие сложные выборки, которые там работают с тысячами строк и так далее,
то, на самом деле, окажется, что делит операция крайне сложная.
И, как ни странно, внутри многих движков она реализуется при помощи инсертов.
То есть строка заменяется на новую версию, как бы пустую,
то есть которой там нету, ну, в общем, много всяких,
тонкостей, как бы, в общем, удаление штука такая довольно коварная.
Как можно выпилить self-destruct? Это же нарушится обратная совместимость.
Ну, да, там для некоторых проектов обратная совместимость нарушится.
Да, есть такое дело, вот, но, как бы, эфир хочет на это пойти,
потому что без self-destruct невозможны дальнейшие, как бы, улучшения работы нод, вот.
Ну, потому что из-за того, что, как бы, возможно, что контракт вдруг к какому-то блоке
неожиданно исчезнет, создает очень много, как бы, проблем и там всяких ифов именно в коде,
именно в коде нод.
Потом старается, держит его state, короче говоря, там, ну, там, следит за его, там, состоянием, как бы,
а потом он взял, короче говоря, и, как бы, сделал self-destruct.
И, начиная с определенного блока, один и тот же запрос по адресу контракта, который, там, например,
там, его код запрашивает или его какое-нибудь состояние, как бы,
может работать, и ноде, как бы, непонятно, чего отвечать, как бы, то ли это, как бы, то ли это, вот.
В общем, это довольно сильно, как бы, мешает.
Вот, если бы его не было, как бы, то, если бы все контракты навеки, как бы, всегда прибиты, как бы,
гвоздями в блокчейне, то было бы проще.
С обычными адресами, которые не смысл контракта, так и происходит, да?
Их нельзя удалить.
Да, да, да, их нельзя удалить, они так, ну, здесь вообще все, как бы, остается, остается навсегда, вот.
Просто так, как бы, обойти это нельзя, как бы, но можно при помощи криптографических протоколов разработать софт,
там, типа ноды, которые ведут только часть, ну, по сути, как бы, которые ведут только контрольные суммы всего этого.
То есть у них, по сути, есть доказательство, что действительно байткод по такому-то адресу,
оно имеет вот такой вот хэш криптографический, что действительно баланс, короче, этого пользователя, вот, там, скажем, как бы, такой,
но при этом сами данные они не держат.
Вот.
И, по сути, вот эта часть нод будет обеспечивать безопасность сети, а те, кому, как бы, нужен конкретно, там, сам код в процессе транзакции и так далее,
это будут уже, там, дополнительные сервисы, дополнительные типы нод, там, в общем, это долго еще рассказать.
Если прям очень интересно, то читайте, как выглядит эфир 2.0, там, все его, как бы, основные, как бы, механизмы.
На самом деле, там, очень много сделано и очень хорошо.
Вот.
Они очень внимательные.
Вот.
Так.
Окей.
Поехали дальше.
Значит, про цену чуть-чуть поговорили.
Соответственно, про, тоже, если дальше, как бы, говорить, там, про цены, то у нас есть у Hard Limit блока.
И, как я говорил, когда мы у нас сильно, ну, сильно забитые, сильно забитые цены.
Да.
Сильно забитый блокчейн, прям, вот, прям, не знаю, на 100%, как бы, все, все там забито, то вверх идут комиссии.
Они теперь, они теперь, по сути, как бы, используются чуть-чуть похитрее, чем раньше.
То есть, есть, ну, случился Е1559 Hard Fork, это было в августе 21 года, после которого было запрещено.
Ну, то есть, например, ставить, как бы, цену газа ноль.
То есть, раньше вы, в принципе, могли в теории, как бы, создать, как бы, транзакцию и сказать, цена газа ноль, стоит она ноль, как бы, пожалуйста, как бы.
Ну, то есть, никто не запрещал.
Понятно, что никто вашу транзакцию майнить не будет, она никому не нужна, но, тем не менее, в блоках таких транзакций было дофига с нулевой ценой.
Что это было?
Это были майнеры, которые одновременно трейдеры, и они, чтобы не запариваться, как бы, просто вставляли, как бы, транзакции с нулевым газом.
Да.
Транзакции с нулевым газ-прайсом свои собственные.
То есть, могу ставить, могу, как бы, беру, доставляю, как бы, и все, и не волнуюсь газ-прайсом.
Вот, про это тоже будет достаточно богатый разговор, про майнер extractable value, как раз про который докладывал я недавно.
Вот, там все очень интересно, вот с тем, как борются за включение транзакций в блок.
Там все гораздо интереснее, нежели в white paper написано, типа, поставил больше денег, тебя быстрее замайнят.
Вот это вот.
Не всегда так работает.
Значит, запретили вот этот вот нулевой газ-прайс.
Сказали, что есть специальная такая base fee, то есть минимальная цена за газ, которая зависит от вот этой заполняемости блока.
То есть, блоки забиты на 100%, base fee растет вверх.
Типа, ребята, sorry, блок-чейн весь забит, как бы, к черту, как бы, давайте, как бы, больше платите, больше денег.
Вот.
Потом, как бы, деньги растут вверх.
Блок перестает заполняться, например, там, на 50%, как бы, он заполнен.
Он, как бы, идет вниз.
Вот это вот то, что я говорю, заполнен, измеряется, как вы думаете, в чем?
Ну, в чем удобно измерять заполняемость блока?
В мегабайтах?
Ну, в долях, в количествах чего-то.
Не-не-не, неудобно.
Удобнее всего измерять в газе.
У нас есть...
У нас есть уже, как бы, универсальный, универсальный, по сути, счетчик.
Счетчик, считающий, как бы, кванты, как бы, исполнения.
Чтобы мы не перегрузили, как бы, майнеров, не вставляли в блок, там, какое-то безумное количество транзакций.
Не замедляли процессинг и так далее.
У нас есть, по сути, универсальный измеритель, газ.
Мы взяли первую транзакцию, вторую транзакцию, третью транзакцию.
У нас есть вот этот большой, так называемый, ну, там, hard limit.
Его по-разному используют.
Говорят, что hard limit — это константы, которые в одной транзакции не позволяют потратить, там, ну, скажем, там, больше десяти, там, не знаю, миллионов, короче, газа.
Но и, как бы, для блока тоже говорят.
То есть есть hard limit, там, не знаю, там, две тысячи, две тысячи транзакций умножить на текущий hard limit.
Вот столько газа, как бы, максимум, как бы, может быть, может находиться в блоке.
Вот этот hard limit, он тоже тюнится.
Тоже динамический.
В зависимости от заполняемости.
В зависимости от заполняемости блока.
Вот.
То есть, там, где-то здесь, там, может уменьшается, здесь, там, он увеличивается.
То есть, там, целая, как бы, модель такая большая.
На нее, в общем, можно, на нее можно посмотреть.
Вот.
То есть здесь вопрос с комиссиями, он здесь, как бы, такой очень глубокий, там, умный.
За ним, там, много всякой экономики, как бы, построено.
Раньше эфир просто за каждый блок печатал, там, сколько-то, как бы, эфира майнеру.
Плюс, как бы, ему, там, назначал, ну, плюс он плюсовал, как бы, фи, то есть, комиссии
с транзакцией.
Сейчас все сделано, как бы, по-другому.
То есть, теперь у него есть, там, базовая штука, у него есть комиссии с транзакцией.
Плюс еще часть эфира сжигается.
И сжигается она, как раз, по-моему, в том случае, если есть какой-то недобор в блоке.
То есть, как бы, народ перестает пользоваться эфиром.
Значит, он какой-то, там, менее ценный, как бы.
Значит, надо общее количество эфира уменьшить.
То есть, просто начать его сжигать.
Его будет становиться меньше.
Это будет дефляция, и, как бы, цена эфира поэтому пойдет вверх, как бы.
Они, там, ну, в общем, тут, чтобы просто не дезинформировать вас именно, как бы, фактами.
Но самое главное, что эта модель, она, прям, динамическая.
И там, конечно, обоснованы все эти, все эти истории.
Можно почитать в ЯИПах, почему так было предложено.
И это довольно грамотно сделано.
То есть, сейчас эфир, как бы, такая очень развитая финансовая система.
Вот.
Дальше, ну, дальше уже, в принципе, такой, как бы, халявный, достаточно, как бы, кусок.
Мы с вами на Etherscan, как бы, посидели.
Сейчас еще чуть-чуть посидим, посмотрим, как бы, как смотреть всякие транзакции.
Что у них есть.
Затем я покажу, как примерно выглядит, как бы, там, не знаю.
Там, разработка.
Мы будем использовать HardHat.
Есть такой фреймворк, очень удобный для разработки.
На самом деле, подсолидить их, прям, несколько штук, там, три, четыре, пять.
Здесь очень много, как бы, всего.
Чуть-чуть полазим по разному, там, коду.
Вот.
Там, про Flow поговорим.
То есть, сейчас уже, такой, более, более обзорная часть лекции.
Etherscan'ом пользуются, наверное, как бы, все, практически, как бы, постоянно.
Как вы понимаете, это, по сути, как бы, архивная, ну, сервис, который, как бы, бегает в архивные ноды.
Собирает огромное количество разной информации.
Размечает адреса.
То есть, например, он там.
Вот здесь мы видим, что вот этот адрес называется в RapidEther.
То есть, что это его, что он является токеном.
Что это, как бы, контракт токена.
При этом Etherscan, как бы, понимает, как читать этот контракт, как писать этот контракт.
Отдельного слова, наверное, как бы, заслуживает вот эта вот штука, что я вам показываю исходник.
Исходник этого смарт-контракта.
Откуда исходник взялся?
Ну, то есть, вроде бы, как чувак задеплоил этот, значит, в RapidEther вот его там адрес.
Вот его код.
Это машинные инструкции.
То есть, если вы просто сюда заглянете, там будет, по сути, его байт-код.
Вот он.
Так, creation-код.
Вот так вот он выглядит в машинных инструкциях.
Вот там, там, вот так вот.
Откуда взялся у нас исходный код?
Для этого, как бы, используется, так называемая, верификация смарт-контракта.
Вы можете прийти на вот этот адрес, на котором не будет вот этого исходного кода.
И сказать, я знаю такой исходник.
Я знаю такой исходник, как бы, который...
Получается...
Ну, из которого скомпилирован вот этот вот байт-код.
Это уже чисто централизованный, как бы, сервис.
Вы заходите на Etherscan.
Заливаете туда прямо вот этот текст.
Вот.
Видите?
Даже с этим самым, с лицензионным соглашением.
Которое понятно и никаким образом в байт-коде, как бы, вот здесь вот не представлено.
Вы заливаете туда этот текст.
Что делает Etherscan?
Он его компилирует.
Ваш вот этот текст.
А...
На самом деле убирает, как бы, еще там конструктор.
Потому что конструктор не включается, как бы, в байт-код.
И сравнивает с тем, что находится в блокчейне.
Вот там вот, собственно, вот с этой вот штукой.
Там где-то вот здесь вот, там, типа, код конструктора.
Вначале заканчивается, как бы, и начинается сам код контракта.
Вот он сравнивает, действительно ли из вашего исходника получился в точности вот этот вот байт-код.
И если он получился, как бы, то...
Ну, это все хорошо.
Вот.
А...
Еще вторая, как бы, важная штуковина контракта.
Это так называемая ABI.
То есть смарт-контракты в эфире.
Они ходят, по сути, для того, чтобы вы могли построить DAP.
Который...
Приложение, которое работает со смарт-контрактом.
Вам же нужно знать вот эти все интерфейсы, функции.
Что принимает депозит?
Что принимает withdraw?
Какой тип аргументов?
Какие из них пишущие?
Какие из них читающие?
Там и так далее.
И эта информация, этот интерфейс, как бы...
Он представляется в формате ABI.
Application Binary Interface.
Вот.
И здесь, в общем-то, описаны все функции.
Ну, то есть там написано, там, не знаю, там...
Где там функция какая-нибудь.
Ну, короче...
Я хотел найти какой-нибудь там депозит.
Депозит.
Name.
Payable.
Ну, в общем...
Вот здесь вот как бы прописаны все функции данного контракта и типы их параметров.
То есть здесь внутри где-то как бы зашита функция transfer.
И мы знаем, что для того, чтобы перевести эти токены к кому-то другому,
мы должны передать адрес назначения и количество токенов, которые мы должны передать.
Вот.
И это описывается вот в этом ABI.
Ты его подключаешь к JavaScript.
Это ABI, как бы ты его засовываешь, как бы, там, не знаю, там, в свой скрипт на Python, который общается с контрактом.
И у тебя появляется, по сути, такой объектный интерфейс к твоему контракту.
Вот.
То есть как он там преобразуется в вызовы тоже будет рассказано, когда там низкоуровневые всякие будут смотреть штуки по обращению к контракту.
Вот.
Это значит то, что касается ABI.
Затем, если посмотреть на этот...
Ну, опять же, как бы...
На общение с контрактом в RapidEther.
Это токен такой, как бы, не знаю, там...
То есть вы можете на своем балансе иметь там сколько-то в RapidEther.
То здесь есть, например, передача, вкладка, короче, ERC-20 Token Transfers.
То есть которая покажет, как бы, все транзакции, в которых кто-то кому-то какое-то количество вот этого в RapidEther передал.
То есть там вот этот парень, как бы, передал там один эфир и, короче говоря...
А, передал там, не знаю, там один токен Uniswap там кому-нибудь там вот этому в RapidEther.
Да, непонятно почему.
Или...
А, ну это я сейчас...
Это я с контрактом.
Значит, как вот эти вот штуки сделаны?
ERC-721, ERC-1155, короче говоря.
Как вот эти трансферы сделаны?
Как вы думаете, что парсит EtherScan для того, чтобы показать, как бы, что токены были переданы?
Какие данные контракта?
Вот он показывает все операции в RapidEther.
Ну, там, все оперирования, как бы, в RapidEther.
Либо транзакции, либо его лог.
Ну, правильный ответ именно лог.
То есть, на самом деле, как бы, не транзакции.
А вот то, что мы с вами как раз говорили вот про вот эти вот ивенты.
В стандарте токена записано, что после того, как токены были переданы,
в случае успеха обязательно в логе должно появляться вот такое событие определенного вида,
которое называется трансфер с параметрами от кого, кому и какое количество.
Вот.
EtherScan, по сути, как бы, висит постоянно на блокчейне,
постоянно слушает вот эти вот события трансфера.
Из разных токенов.
И как только такое событие встречает,
он, соответственно, у нас вот здесь вот эту транзакцию показывает.
Там сохраняет, индексирует, там, и так далее, и так далее.
Все для этого, как бы, нужны ивенты.
Вот.
Ну, какой там еще, может, там...
Еще может какой-нибудь токен показать.
Ну, точнее, если... Давайте вот так вот.
Авиа V2, лендинг пулк.
Ну, это такой, как бы, большой очень...
Очень большой контракт здоровый.
Вот так, сейчас я найду implementation.
Implementation должно быть здесь.
Прокси.
Не, ладно, посмотрим.
Так, не авиа...
Под словом токен, что имеется в виду?
А?
Под словом токен, что имеется в виду?
Мы с вами активно это разберем.
Прям контракт токена будем здорово разбирать.
По сути, под словом токеном подразумевается контракт,
в котором есть функция transfer,
в котором есть функция balance.
Balance...
Balance of.
Есть стандарт, который говорит, какие функции должны быть там.
Transfer from.
Там есть несколько функций.
Есть прям стандарт, который называется ERC20.
Вот прям, по сути, как бы стандарт, который говорит,
что контракт токена должен иметь вот эти функции,
а работает он следующим образом.
Он, по сути, изображает из себя, как бы, криптовалюту.
В точности, как эфир.
То есть, токен это такой минимальный, как бы, контракт,
который говорит, что у Васи там 100 токенов,
а у Пети там 200 токенов.
В своем сторидже.
Вот это вот очень важно, как бы.
То, что он, как бы, эти балансы держит.
В своем сторидже.
И когда делается трансфер, соответственно, там,
у Васи там списали 20, этому добавили 20.
Пишет этот токен программист.
Вот.
Но зато все, как бы, могут зайти в этот контракт
и убедиться, что у него здесь в трансфере нету, там,
какого-нибудь трояна, который позволит ему взять, короче,
и у кого угодно, там, не знаю, токены на свой адрес перевести,
утащить, как бы.
Есть, как бы, и такие затроянные токены.
То есть, это контракт, который удовлетворяет вот этим,
как бы, стандартам и ведет себя, как криптовалюта.
Ну, то есть, у него есть балансы, как бы, представляет собой,
там, что-то типа, там, денег и так далее.
Вот на этих токенах строится практически вся, как бы,
экосистема.
Такой, как бы, базовый кирпичик, из которого это строится.
Вот.
Мы будем, будем очень подробно, как бы, про это смотреть.
Вот.
Это, по сути, ну, как бы, когда, как бы, эфир появился,
начались же вот это, началась эпоха, как бы, ICO, краудфандинга.
И ICO-шный контракт, он обычно работал следующим образом.
То есть, есть какая-то цена, например, ну, например,
я говорю, я делаю специальную криптовалюту, токен, значит,
у кого есть один токен, то, значит, один час, как бы,
может на моих, там, самокатах кататься.
Вот.
Токен равно один час, как бы, на моих самокатах.
И пытаюсь убедить людей накидать мне на это денег.
Я создаю цену, там, цена, которая делает, как бы,
эфир на мой, там, какой-нибудь самокат-токен.
Вот.
Приходит чувак, кидает, как бы, десять эфира, хочет
очень кататься на самокате, и в ответ, и мой вот этот
вот смарт-контракт, то есть он там вызывает функцию
депозит, короче говоря, или там функцию, там, какую-нибудь,
или просто, там, отправляет, как бы, эфир.
Это тоже, как бы, программируется.
И когда он, соответственно, эту функцию вызывает, в
ответ я ему в сторидже создаю запись.
Там, это опять Вася у нас, как бы, тебе, Вася, значит,
дорогой друг, двадцать токенов.
Сам.
Как бы, и Вася у себя, как бы, видит в метамаске,
что у меня двадцать токенов сам теперь.
А десять эфира, как бы, ушли, легли на баланс, как бы,
вот этого, на баланс этого проекта.
В принципе, Вася может и обратно сказать, так,
все, я передумал, хочу withdraw.
Я тебе отправляю, как бы, двадцать токенов сам,
а ты мне возвращай мои десять эфира.
И там до определенного момента это возможно.
А потом VCO, как бы, появил, ну, то есть сам контракт
является токеном.
То есть кто угодно может прийти, как бы, и спросить,
какой баланс, какой балансов у Васи.
И он ответит.
Вот.
И он ответит.
У Васи двадцать токенов.
Могу, кстати говоря, это даже продемонстрировать.
У меня в метамаске есть какие-то активы.
В тестовой сети.
Нет, по-моему, в тестовой нету.
Может, в Ринкебе есть.
Вот.
У меня тут много разных токенов.
Каких-то там многих.
Вот есть Юни.
Токен, сейчас посмотрим на него.
Вот он, контракт этого Юни.
Токена.
То есть вот он прям с его там трансфер, депозит.
Вот они все его там эти функции.
И я могу спросить, а сколько вот у этого чувака, возьму
свой адрес, вот у этого парня, 0FD, короче говоря,
сколько у него токенов, балансов.
Вот я ввожу.
Это как раз вот эти самые view функции читающие.
Спрашиваю, он мне возвращает.
У него шестнадцать токенов.
Вот.
Здесь видит шестнадцать и еще вот семнадцать знаков
после запятой.
Decimals.
Вот.
Я правильно понимаю, что дробные числа в блокчейне
представляются как числа с фиксированной точкой?
Да.
Я как раз про это на прошлой лекции говорил.
То есть нету никаких дробных чисел в блокчейне вообще.
Даже там проценты, они все равно как бы представляются
как бы, как вот такие вот целые, целые там по большей
части беззнаковые числа.
Вот.
Это все как бы из-за детерминизма.
То есть вы не можете операции нативные с FPU, но с плавающей
точкой проводить как бы на разных процессорах
с одними и теми же результатами.
Вот он.
Поэтому под это есть специальный библиотек.
Поэтому все токены, все криптовалюты, биткоины,
эфиры, короче говоря, какие не возьмете, как бы они
все вот так выглядят под капотом.
Как целые, которые вы делите, как бы вы делите.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
то есть насколько минимально он делится вот соответственно этого да что касается как бы
контракта токина ну а дальше вася была просто функция как бы которая говорит
там типа забрать все деньги ты потом там три колма не и которая выводила весь эфир
который выкидали там куча вас как бы это куча этого эфира они отдавали как бы владельцу тому
кто-то контракт создал и вообще решил там самокатами заниматься но при этом в этой
функции прям публично можно было представить смарт-контракте написано типа если время как
бы меньше чем там декабрь короче 2018 года идите нафиг как бы эфир до этого времени я забыл забрать
если баланс короче говоря меньше чем 1000 эфира то есть если как бы мне накидали денег меньше чем
1000 эфира как бы все идите нафиг как бы то есть можете забрать свои деньги как
бы и выйти из если они не наберу на свой проект 1000 эфира на запах самокатов то как бы извините
вот такой как бы как этот kickstarter по сути как бы просто аналог kickstarter и как бы но
написанный в виде по 1 смарт-контракта при этом у тех кто как бы участвует у них остаются вот эти
вот токены баланса как бы они ими могут дальше пользоваться там как угодно и там уже миллион
идей там типа этими токи нами расплачиваться там за
не знаю там еще там смотреть там кино короче говоря собирать краудфандинг на создание фильма здесь
можно тоже конечно куча всяких идей там всякие там и scroll какие-нибудь там знаменитые люди которые
будут ставить галочки типа прошел ли проект на следующую стадию на следующей стадии можно ли
ему там достать следующий кусок из этих фамилий то есть очень много всего было сделано и сама идея как
ничего можно просто краудфандинг заниматься не выходя вообще никуда из эфира вот очень просто
как бы и проекта на этом многие там миллиард собрали понятно что трэша там было очень много
то что такое такая свобода просто конечно не дается вот это значит что касается там токенов
и а из рассказа давайте посмотрим теперь собственно как наверное уже немножечко прям зацепим как бы
разработку в которой вам придется довольно много работать я в общем-то показываю такой движок такой
фреймворк который называется hard head это для тех кто любит больше java script чем питон вот
для тех кто любит больше питон как бы есть очень похожий фреймворк называется брауни вот у меня есть
hard head потому что там есть там демонстрации некоторых всяких штук
по сути представьте что я просто решил как бы создать свой контракт не знаю там токина который
просто чуть-чуть поумнее там у него там не знаю что он берет комиссии там еще что-нибудь у меня
есть вот этот oversight hard head этоisiónет желестный короче там этот package Zlojko это
качество называется значит он позволит вам на вашем компьютере вам на вашем компьютере
хорошо свет сатру
он на вашем компьютере поднимает но до такую как бы девелоперскую свою собственную которая
вроде бы как как бы манит блоки вы пишете как бы смарт-контракт этот смарт-контракт затем
выполняете как бы java скриптовый тест в этом java скриптовом тесте есть диплой этого контракта
вы это диплой как бы дипло из вот это вот как бы в игрушечный эфир в этом же как бы внутреннем
в этом скрипте как бы вы станете владельцем адреса на котором есть много много эфира 100 миллионов
там такой там эфира вы можете здесь же притвориться любым другим адресом в обчине то есть стать как
бы им там полезно не знаю изменить старич контракты так далее там возможности очень
много вот на по сути вы можете сделать диплой какой как вот в этом
виртуальную ноду а потом начать соответственно делать различные вызовы там тесты как бы и так
далее то есть работать ровно так как он будет работать в блокчейне ваш контракт то есть
проводить тесты в такой локальный девелопер ноде вот штука крайне удобно ее как бы легко
запускать как бы и легко программировать сидишь в двух файлах один файл пишешь на солидите второй
как бы тест на джейсе и в общем то никуда как бы из этой штуки не выходишь как бы тебе ни эфир
не нужен никакой там не будет
блокчейн как бы не криптовалюта просидишься в локальном окружении она достаточно удобно и
а сам hard head как бы и брауни и последние фреймворки чем они круты тем что вот вместо
вот этого вместо вот этого я могу прицепить майнет начиная с любого блока то есть я могу
сказать внутри вот этого своего теста джества я хочу сказать я могу сказать так возьми пожалуйста
как бы ford не сделай прям копию боевого эфира начиная с блока там такого-то такого-то прям вот
в точности вот прям полностью его состоянии после этого я хочу стать васей вот прям причем реальным
васи вот прям вот отсюда то есть реальным васи который вот здесь вот там славки это транзакции
там так далее хочу стать вот этим вот адресом что у меня на балансе был эфир как бы вот такие вот
то есть ты становишься как вот этим вот адресом он тебя имперсонирует и после этого ты делаешь
там любые вызовы делаешь либо чего хочешь там эмулируешь работу там с любым протоколом и он
тебе исполняет это в таком как бы в блокчейне который от почковывается от майонета то есть
там никого кроме тебя нету как бы и ты там делаешь что хочешь именно в этом кроется как раз причина
то есть почему как бы здесь хаки такие частые как бы почему хаки такие как бы там большие почему
как бы хакерам здесь так фривольно потому что у них есть именно вот это вот возможность они
могут сказать взять в прям в текущем виде как бы прям протокол где лежит там не знаю там 100
миллионов долларов на разных и в депозитах прикинуться там таким-то как бы участникам
или просто взойти как бы новым участникам и полностью про эмулировать как бы все атаку там
со практически со стопроцентной вероятность то есть все данные готовы как бы все состояние
контракта все будет воспроизведено со стопроцентной точностью не считая конечно то что здесь
пользователем могут видеть как бы транзакции за это время helping этого не увидит но для так это
как вне суть то есть вы можете воспроизвести любой контракт в майонете прямо вот в его
пол к чистом в виде со стопроцентной точностью без особых проблем как это позволяет сделать
там тоже несколько строчек и то
Это мега удобно для тестирования.
У меня здесь есть контракт, их там несколько.
У меня есть там контракт токена.
Вот, он такой достаточно как бы тупой.
Так, давайте я лучше с подсветочкой как-нибудь.
Так, это тест, это тест.
Давайте контракт с токеном.
Так, промахнулся.
У меня тут много их.
Ну, соответственно, там солидити указывается версия, как бы солидити.
Там импорт это относится только к хардкату,
который дает суперскую возможность писать в консоль из контрактов,
потому что так-то, когда вы там тестите контракты в блокчейне,
конечно, там ни консоли нет, ничего, никакого вывода, ничего такого.
Я писал название своего токена.
Вот этот мой...
Public name, по сути, превратился в getter,
то есть такую функцию name,
которая возвращает как бы вот такое название,
my hard hat token.
Мы уже такой getter видели,
когда смотрели с вами в rapid эфир.
Так, где он там?
Вот, в rapid эфир, как бы, когда мы его смотрели с вами,
у него тоже можно спросить, как бы, какой у тебя name,
как бы он возвращает имя в rapid ether.
Вот такое неявное.
Очень похоже все-все на OOP.
Значит, описали, кто владелец данного контракта,
это, в общем, владельцем будет тот, кто его задеплоил,
то есть тот, кто отправил транзакцию создать токен,
как бы он станет олднером.
И у меня есть просто ассоциативный массив, там dict, как в питоне,
который эфириумный адрес отображает uint-256.
uint-256, привыкайте, как бы это будет вообще любимый тип данных ваших.
Вот, который говорит, у вас есть 100 токенов, у Пети 200 токенов и так далее.
Вот прям вот примитивно совершенно.
Затем у меня есть конструктор.
Когда я буду деплоить этот контракт, у меня пропишется,
что у того, кто создал данный контракт,
у него будет вот столько-то токенов, total supply,
вот сколько у него будет здесь соответственно,
один миллион токенов, я его сделал, как будто переменную.
То есть все вот эти токены будут на моем балансе,
когда я это задеплою.
То есть я буду их владельцем.
И я же буду владельцем данного контракта.
Если у меня будут какие-то админские функции,
которые будут,
которые только для Овнер,
я могу в них делать проверку,
типа что транзакцию отправил только вот этот чувак Овнер.
Вот эти вещи, опять же, в Solidity,
то есть почему похоже на JavaScript,
но на самом деле совсем не то программирование,
потому что на самом деле вот это не явно,
это запись storage.
То есть то, что я здесь присваиваю переменные,
это просто для удобства,
а на самом деле здесь происходит именно запись в переменной storage,
потому что описанные вот здесь переменные глобальные для всего этого класса контракта,
они в общем по дефолту отправляются в storage.
То есть это не временные какие-то переменные.
Стоит мне изменить total supply,
и с меня спишут там сколько-то тысяч газа за запись в storage,
и это изменится в блокчейне, если транзакция пройдет.
Затем функция transfer.
Я же хочу, чтобы у меня был токен,
совместимый с кошельками,
чтобы они знали, какую функцию дергать,
поэтому у меня функция такая, как и у других.
Принимает адрес, называется transfer.
Сначала она проверяет, что у меня достаточно токенов,
чтобы сделать этот перевод.
А что означает external?
External то же самое, что public.
Тоже будем разбирать.
Посчитайте, что это как бы то же самое, что и public,
как бы просто чуть лучше работает,
если эта функция...
Вызывается только снаружи исключительно,
то есть как бы только в транзакциях.
Public работает лучше, если она еще и вызывается из других контрактов.
Газа потребляет меньше.
Значит, require это типа ассерта.
Здесь есть, кстати, и ассерт, но типовая как бы это require.
История такая же, как и в программировании,
там на C, на C++.
Если у вас вообще там логика в хламину как бы разломалась,
и все там автум.
А require это типа не хватает баланса.
Все как бы, иди отсюда, произойдет реверт.
То есть если не выполнится эта штука, то будет реверт.
Затем консоль лог, которая кроме hardhat у вас не сработает.
То есть вы, конечно, такой как бы не скомпилите ничем кроме hardhat.
Вот такую как бы штуку в эфире.
Потому что там нет никакой консоли как бы.
Но это позволит нам подебажить как бы это дело.
Ну и дальше прям все просто как бы.
У sender удалили, сняли 100 токенов как бы,
а recipient добавили.
Еще тоже довольно важная как бы штука в смарт-контрактах,
что в смарт-контрактах все, что не определено, то ноль.
Вот все, что неизвестно что, короче говоря, вот оно ноль.
Вот мы посылаем, короче, Пете,
а у Пети как бы у него и адресы,
он адрес там от балды какой-нибудь там рандомный назвал там.
И вообще как бы у него там ни баланса, ничего нету.
Что здесь будет как бы?
На самом деле как бы по дефолту вот эта баланса 100 как бы будет равно нулю.
К нулю прибавится имаунт как бы.
И будет создана как бы запись в ассоциативном массиве как бы вот с этим вот имаунтом.
То есть в этом плане как бы solidity как бы здесь достаточно все просто.
Если что-то нету, то это ноль.
Если что-то не вышло, как бы это ноль.
Вы можете обратиться там к любому там адресу в памяти, куда угодно.
Как бы никто вам по рукам бить не будет.
Просто как бы отдадут вам ноль и все как бы.
Это тоже сделано из-за детерминизма.
У меня там тоже любимая фраза.
Да, смарт-контракты должны исполняться детерминированно.
То есть результаты как бы работы смарт-контракта должны быть детерминированы.
Но они и ломаться даже должны быть детерминированно.
То есть одна и та же ошибка на всех компьютерах,
должна приводить ровно к одному и тому же результату.
Это тоже достаточно важно.
Ну и вот у меня функция balance of balance,
которая просто возвращает баланс у аккаунта.
Такой прям самый-самый дубовый-дубовый прям вообще в никакую как бы токен.
Как я его, соответственно, тестирую?
Здесь там фреймворк какой-то JavaScript для тестов.
Chai там очень модный с каким-то describe'ами и так далее.
С асинхронщиной с различными.
Вот здесь уже можете упражняться, как вам нравится, как бы в этих тестах.
Есть, соответственно, модификатор, что перед каждым тестом,
который я буду запускать, должны выполниться следующие функции.
И вот они нам достаточно интересны.
То есть первое, как бы здесь используется библиотека ethers,
которая позволяет работать с эфиром, там деплоить контракты, вызывать их там и так далее.
Таких библиотек на самом деле в JS несколько.
Есть web3.js.
Есть ethers.
Есть еще какие-то.
Вот здесь используется ethers.
Я делаю, так называемую, фабрику контрактов.
То есть он возьмет мой токен .sol, вот этот мой как бы с алиэйти, скомпилит его
и инициализирует такой как бы код, который сможет его в блокчейн как бы деплоить.
Затем я возьму и вот этим вот переменным назначу значение getSigners.
То есть это по сути там такой десяток синтетических аккаунтов, которые у меня будут созданы.
То есть мне будет создан owner, у которого будет там 100 тысяч эфира на балансе,
адрес 1 со 100 тысячами эфира на балансе, адрес 2,
чтобы я мог изображать из себя как бы пользователя моего протокола.
То есть у меня в тестах же, наверное, много участников.
И поэтому как бы таким образом я это все инициализирую.
Затем вызываю функцию deploy.
Здесь все как бы асинхронное.
То есть если я не сделаю как бы это wait, я получу promise на как бы на транзакцию,
которую мне придется подождать.
Вот тут я дождался, короче говоря, и теперь у меня, ну, соответственно,
вот этот hardhat токен как бы будет задеплоен таким вот образом.
Теперь как бы у меня перед каждым, перед каждым моим тестом будет выполняться
вот эта вот штука.
То есть я каждый раз перед каждым тестом буду заново деплоить свой токен.
У меня вот в этой переменной будет лежать вот этот контракт.
За меня будет сгенерирован вот это ABI, интерфейс к нему.
То есть я теперь к этому токену смогу обращаться просто как в объектно-ориентированной штуке.
То есть есть у него переменная owner публичная, вот она, она public.
Значит, существует как бы getter публичный, вот такая вот функция как бы,
которая будет возвращать значение вот этой переменной.
И я, соответственно, могу как бы проверить то, что овнером стал как бы тот овнер,
который деплоил этот контракт.
Ну, там, ну, по дефолту вот здесь вот как бы он от адреса овнера и задеплоил.
А теперь там протестируем там транзакции.
То есть я беру как бы hardhat токен своего адреса овнера по дефолту,
у которого там миллион этих токенов, на адрес 1 перевожу как бы 50 токенов.
Затем как бы вызываю функцию balanceof и проверяю то, что баланс получателя стал равен 50.
Вот, там, я по-моему, где-то тест запущен.
Вот, можно, соответственно, посмотреть как бы то, что в трансфер вот этот мой консоль,
консоль лог написал, что я перевожу вот с этого адреса на этот 50 токенов,
и с этого на этот 50 токенов.
Вот, ну и тесты там проходят.
Понятно, что я могу здесь все вывести, там, все попечатать.
Вот, затем точно так же теперь я как бы становлюсь адресом 1,
то есть у которого 50 токенов, и пытаюсь их перевести на адрес 2.
Вот, и, ну, ожидаю как бы, что на адресе 2 как бы теперь тоже будет 50 токенов.
То есть там уже как бы пользователи начинают это делать.
Дальше, соответственно, проверки как бы, что там все должно падать,
если не хватает токенов.
Да, там, адрес 1 теперь как бы токенов ноль как бы,
а он кому-то пытается один токен перевести,
и как бы тоже как бы все должно упасть.
По сути это, да, такой как бы, не знаю, template как бы,
если захотите как бы начать там разрабатывать.
Здесь это, как видите, довольно несложно.
При этом все, что мы здесь делаем, вообще не знаем, где там какой адрес,
не знаем, где там какой-то там эфир, короче, какие-то блоки,
что-то там майнится как бы и так далее.
То есть пока вы не начнете тестировать какие-то более сложные паттерны,
то есть когда там типа надо задепозитить, подождать пока пройдет там, не знаю, 30 дней,
чтобы потом пришел как бы второй там какой-нибудь чувак, там третий,
что будет, если несколько транзакций в один блок как бы затолкать,
как бы как это все сделать, как бы, то здесь все достаточно просто.
Вот, и учитывая небольшое, ну, там, например,
там, да, что балансы должны все правильно апдейтиться, там, и так далее, и так далее.
То есть здесь там куча всяких разных тестов.
И если вы будете делать как бы курсовой проект,
это именно как бы разработка смарт-контрактов на Solidity,
то вот такой вот репозиторий, это, по сути, как раз то, что вы будете,
то, что вы будете задавать.
То есть вы мне будете как бы задавать линк на GitHub-репозиторий,
там у вас в ритме будет описано, как его там поставить, запустить,
короче, и что это вообще за проект, что он делает, вот.
Возможно, как бы там во многих местах как бы очень мне хочется,
чтобы прям в ритме был вот этот вот вывод в консоли,
и чтобы там хоть какая-то, короче, вот такая вот инфа в консоли выводилась.
А вот здесь, короче говоря, у нас там человек пришел,
там, не знаю, зарегистрировал диплом.
А вот здесь пришел там верифайер, короче, и подтвердил как бы этот диплом.
А вот он его, значит, принес как бы проверяющим,
как бы ему там вот это вот, у него вот это проверяют и так далее, и так далее.
То есть чтобы вот эту вот трассу можно было более-менее так нормально
как бы посмотреть в домашнем задании, вот.
Ну, чтобы я мог заглянуть там, не знаю, там буквально там в тесты,
посмотреть, насколько они полные, заглянуть в сам контракт,
посмотреть, как бы насколько он полный.
И желательно, если я как бы залипну с какими-нибудь версиями там Node.js там
или там Brownie и так далее,
я не могу запустить, что я хотя бы мог увидеть в ритме вашу трассу
и исполнение как бы вашего теста.
Этого, в принципе, уже как бы по большей части достаточно, вот,
для того, чтобы сделать именно протокол работающий.
Значит, я, мы там не будем особо сильно смотреть на то,
насколько вы там красивые как бы интерфейсы нарисовали,
но, конечно, если вы прям хотите делать там, не знаю, там NFT, там еще что-то, IPFS использовать,
то, конечно, какие-то базовые вещи.
Вы должны как бы показать, да, если у вас там JPEG заливаются как бы какие-то,
ну, как бы их надо все-таки в браузере отобразить, вот.
Но как бы на дизайн смотреть они будут точно как бы, скорее всего, именно на тесты.
Вот, поэтому разработка довольно комфортная.
Здесь сидишь себе как бы в нескольких, в нескольких файликах в Solidity как бы в тестах,
гоняешь их как бы туда-сюда, вот.
Особо это как бы не сильно требовательная штука, и можешь легко вот эту же историю,
как бы попробовать прямо задеплоить в MyNet.
То есть ты, ну, хардхед, как бы, так как вот эти вот функции, которые я здесь сделал, короче,
вот этот вот деплой, по-хорошему, израилу своему неважно, куда как бы этот деплой делать.
То есть вот эти все вот эти сложные как бы функции, выкладки,
вы можете точно так же хардхед подключить прямо к реальному кошельку,
ну, точнее, к не реальному кошельку, а как бы указать,
что действуй вот с этого адреса, вот тебе публичный, вот тебе секретный ключ от этого адреса,
на нем есть там сколько-то там боевого эфира, переключись на боевую сеть и иди как бы туда деплой.
И, в общем-то, проекты так и деплоятся.
То есть они выкладываются как раз вот при помощи хардхеда,
здесь есть там специальный как бы JavaScript-овый сценарий,
если вам надо там задеплоить там 3-4 контракта, правильно их инициализировать,
то есть вы сделали как бы первый контракт, потом создали второй,
во втором указали адрес первого, сказали он будет мной управлять, потом создали третий,
то есть все вот это как бы удобно не в голове держать, да,
а именно весь этот деплоймент как бы иметь вот здесь вот в тестах.
Эта штука как бы крайне, крайне удобная.
И можете это проделать на форке майнета,
то есть попробовать просто весь сценарий боевой своего деплоя проверить
прямо со 100% гарантией прямо на копии как бы текущего эфира,
что все у вас сработает как бы,
что у вас получится.
Вот в этом плане разработка крайне удобная.
Так, ну и, соответственно, там по поводу как бы общих тасков,
мы много очень будем смотреть всяких разных проектов с вами там пересматривать, вот,
но, конечно, хотелось бы, чтобы вы как бы почитали сами, что пишется.
Скорее всего, вы прям сразу закопаетесь в тонны как бы проектов, посвященных финансам,
там, положил, вынул деньги туда-сюда, у нас под это будут отдельные лекции,
значит, как я сказал, финансы крайне популярные,
потому что не надо выходить из эфира никуда.
Все, как бы, у тебя есть DAB, у тебя, у пользователей есть метамаски,
у тебя есть смарт-контракты, все.
Все остальное как бы это уже такая аналитическая обстройка,
как бы она может там существовать по сути как бы самостоятельно, вот.
Это мега удобно, работа с финансами, как бы.
Поэтому они и победили как бы сейчас, пока что, вот.
А так-то как бы среди тем, которые там, я считаю, как бы крайне перспективными,
это вообще как бы создание DAO, то есть создание как бы на смарт-контрактах
таких организаций, ну, по сути, смарт-контракты, управляющие конкретными бизнесами, вот.
Потому что у каждого бизнеса есть своя собственная там специфика, там, DAO для,
там, не знаю, для доставки дронами, как бы, DAO для, там, не знаю,
аудита кода, DAO для выполнения, там, не знаю, там, заказов, не знаю, там,
подписки на услуги, там, фитнес-тренера, как бы.
Ну, то есть неважно, у них у всех есть свои нюансы.
Где-то там надо деньги списывать вестингом, где-то нужны какие-то, там,
экспертные сообщества, которые голосуют, как бы, там, за что-то и так далее.
То есть здесь фантазия может как угодно, как бы, работать.
И, как бы, DAO тема такая, как бы, очень интересная, организация бизнесов на блокчейне.
Еще тема – это вот эти self-serving identity, verified credentials,
то есть когда у нас эфир используется просто как публичная база данных,
в которой можно хранить публичные ключи, адреса, как бы, и вот, ну, адреса,
которые, по сути, есть как публичные ключи, и доказывать, что ты, там, находишься
в каком-то там реестре, имеешь какой-то документ, имеешь какой-то пропуск, билет на мероприятие,
там, или еще что-то. Тоже делается очень красиво, как бы, на контрактах, минималистично, как бы,
и закончено, вот. Ну, NFT, как бы, это сами, как бы, разберетесь, там, не знаю, там, игры,
представленные NFT, там, это тоже инфы, как бы, очень много.
Вот, в общем, есть здесь, что поделать, вот, думайте. Вот, на сегодня, наверное, все
в качестве post-reader к этой лекции. Ну, значит, что, как бы, важно почитать?
Ethereum Official Docs – это, по сути,
вообще, как бы, просто рекомендую, у них хорошая очень документация.
Есть очень хорошая статья, типа, что происходит, когда вы отправляете один DAI.
DAI – это токен такой, как бы, ERC-20, там, одного проекта, как бы, крайне популярный,
который к доллару привязан. Вот, вот там, прям, подробно, вместе со ссылками на,
прям, вместе со ссылками на исходный код ноды, описывается все, вообще, что происходит
в момент отправки транзакции. И как она готовится, и что она делает, как бы, на ноде,
и там, трейсы всяких, как бы, транзакций, и как она обрабатывается, как газ обрабатывается,
как смарт-контракт исполняется. То есть, это такая чтива на, прям, на несколько часов.
Но, если прочтете, как бы, то предыдущая лекция по эфиру, как бы, она, в общем-то,
вам тоже не особо будет нужна. Ну, либо, прям, супер дополнит, вообще, полностью
понимание того, как эта штука функционирует. Еще раз напоминаю, что другие блокчейны,
они не сильно отличаются, на самом деле. Ну, то есть, архитектурно не сильно.
У всех одни и те же требования. У всех БФТ, у всех детерминизм, у всех газ.
У всех, как бы, execution restriction. Все похожим образом решают.
Еще одна ссылка, вот здесь вот, это про то, как вычисляется газ динамически.
То есть, здесь довольно, там, много, вроде бы, как кажется, что это сложно,
на самом деле, как врубитесь, там, не знаю, в первый, второй этап,
пункт, а остальные все очень легко, как бы, прочитать. По сути, это описание того,
как высчитывается, сколько вы должны заплатить, если вы в память записываете
x байт какой-то информации. Сколько это будет стоить, потому что здесь, там,
нулевые байты стоят дешевле, ненулевые байты стоят дороже. Все это выравнивается
слотами по 32 байта, как бы, здесь это, вот это все описано. Это тоже, как бы,
можно, там, почитать, как бы, для общего развития. Но, вот, как бы, я,
рекомендую крайне вот эту вот статью, прям она очень классная. Вот, в принципе,
все. В следующий раз все уже поедем, там, по солидите, уже будет смотреть
всякие контракты, паттерны, как бы, подразумевается, что, как работает эфир,
вы, в общем-то, знаете.
А пример кода с тестами пришлете?
Имейте в виду вот этот хардхед, да?
Да.
А, да-да-да-да, закинул. Да, хорошо. Там, пингонетики,
ну, это открытая репа. Все тогда. Ладно, тогда мы сегодня завершаем.
Всем хорошего дня.
До свидания.
До свидания.
До свидания.
